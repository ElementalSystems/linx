{"source_files":[{"name":"src/SpecIndex.js","source":"\"use strict\";\n\nvar _       = require(\"lodash\"),\n    Divhide = require(\"./Index.js\");\n\n/**\n *\n * Specs main module.\n *\n * This exposes the specs that are on .readme folder. Note that the\n * spec files are included on the generated documentation\n *\n */\nvar SpecIndex = _.extend({}, Divhide, {\n\n    /**\n     *\n     * Expose sub-modules. These will be used for unit-tests\n     *\n     * @type {Object}\n     *\n     */\n    SubModules: {\n\n        Url: {\n            Parser: require(\"./Common/Url/Parser\")\n        },\n\n        Assert: {\n            Array: require(\"./Common/Assert/Array\"),\n            Max: require(\"./Common/Assert/Max\"),\n            Min: require(\"./Common/Assert/Min\"),\n            Number: require(\"./Common/Assert/Number\"),\n            Regex: require(\"./Common/Assert/Regex\"),\n            Required: require(\"./Common/Assert/Required\"),\n            String: require(\"./Common/Assert/String\"),\n            Object: require(\"./Common/Assert/Object\"),\n            InstanceOf: require(\"./Common/Assert/InstanceOf\"),\n        },\n\n        Chain: {\n            ChainContext: require(\"./Common/Chain/ChainContext\"),\n            ChainFunction: require(\"./Common/Chain/ChainFunction\"),\n        },\n\n        Schema: {\n\n            SchemaDefinition: require(\"./Common/Schema/SchemaDefinition\"),\n            SchemaResultNode: require(\"./Common/Schema/SchemaResultNode\"),\n            \n            Mixins: {\n                SchemaExecution: require(\"./Common/Schema/Mixins/SchemaExecution\"),\n                SchemaExecutionHelper: require(\"./Common/Schema/Mixins/SchemaExecutionHelper\")\n            }\n\n        }\n\n    },\n\n    Specs: {\n\n        ArrExample                  : function() { require(\"../.readme/includes/Arr/ArrExample\"); },\n        AssertionExample            : function() { require(\"../.readme/includes/Assertion/AssertionExample\"); },\n        AssertExample               : function() { require(\"../.readme/includes/Assert/AssertExample\"); },\n        ChainExample                : function() { require(\"../.readme/includes/Chain/ChainExample\"); },\n        ExceptionDocExample         : function() { require(\"../.readme/includes/Exception/ExceptionDocExample\"); },\n        ExceptionListDocExample     : function() { require(\"../.readme/includes/Exception/ExceptionListDocExample\"); },\n        I18NStringDocExample        : function() { require(\"../.readme/includes/I18N/I18NStringDocExample\"); },\n        ObjExample                  : function() { require(\"../.readme/includes/Obj/ObjExample\"); },\n        SafeArrayExample            : function() { require(\"../.readme/includes/Safe/SafeArrayExample\"); },\n        SafeBooleanExample          : function() { require(\"../.readme/includes/Safe/SafeBooleanExample\"); },\n        SafeFunctionExample         : function() { require(\"../.readme/includes/Safe/SafeFunctionExample\"); },\n        SafeLengthExample           : function() { require(\"../.readme/includes/Safe/SafeLengthExample\"); },\n        SafeNumberExample           : function() { require(\"../.readme/includes/Safe/SafeNumberExample\"); },\n        SafeObjectExample           : function() { require(\"../.readme/includes/Safe/SafeObjectExample\"); },\n        SafeRegexExample            : function() { require(\"../.readme/includes/Safe/SafeRegexExample\"); },\n        SafeStringExample           : function() { require(\"../.readme/includes/Safe/SafeStringExample\"); },\n        SafeValueExample            : function() { require(\"../.readme/includes/Safe/SafeValueExample\"); },\n        SchemaAnyExample            : function() { require(\"../.readme/includes/Schema/SchemaAnyExample\"); },\n        SchemaArrayExample          : function() { require(\"../.readme/includes/Schema/SchemaArrayExample\"); },\n        SchemaNumberExample         : function() { require(\"../.readme/includes/Schema/SchemaNumberExample\"); },\n        SchemaObjectExample         : function() { require(\"../.readme/includes/Schema/SchemaObjectExample\"); },\n        SchemaOverview              : function() { require(\"../.readme/includes/Schema/SchemaOverview\"); },\n        SchemaStringExample         : function() { require(\"../.readme/includes/Schema/SchemaStringExample\"); },\n        SchemaSerializationExample  : function() { require(\"../.readme/includes/Schema/SchemaSerializationExample\"); },\n        TypeExample                 : function() { require(\"../.readme/includes/Type/TypeExample\"); },\n\n    }\n\n});\n\nmodule.exports = SpecIndex;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,null,null,null,null,null,1,null]},{"name":"src/Index.js","source":"'use strict';\n\nvar Common = {\n\n    /**\n     *\n     * Type utility\n     *\n     * @type {Object}\n     *\n     */\n    Type: require(\"./Common/Type\"),\n\n    /**\n     *\n     * Safe utility\n     *\n     * @type {Object}\n     *\n     */\n    Safe: require(\"./Common/Safe\"),\n\n    /**\n     *\n     * Array utility\n     *\n     * @type {Object}\n     *\n     */\n    Arr: require(\"./Common/Arr\"),\n\n    /**\n     *\n     * Object utility\n     *\n     * @type {Object}\n     *\n     */\n    Obj: require(\"./Common/Obj\"),\n\n    /**\n     *\n     * I18N utility\n     *\n     * @type {Object}\n     *\n     */\n    I18N: {\n\n        /**\n         *\n         * I18NString utility\n         *\n         * @type {I18NString}\n         *\n         */\n        String: require(\"./Common/I18N/String\"),\n\n    },\n\n    /**\n     *\n     * Exceptions package\n     *\n     * @type {Object}\n     *\n     */\n    Exception: {\n\n        /**\n         *\n         * Exception Class\n         *\n         * @type {Exception}\n         *\n         */\n        Exception: require(\"./Common/Exception/Exception\"),\n\n        /**\n         *\n         * ExceptionList\n         *\n         * @type {ExceptionList}\n         *\n         */\n        ExceptionList: require(\"./Common/Exception/ExceptionList\"),\n\n    },\n\n    /**\n     *\n     * Url utility\n     *\n     * @type {Function}\n     *\n     */\n    Url: require(\"./Common/Url\"),\n\n    /**\n     *\n     * Chain facility\n     *\n     * @type {Object}\n     *\n     */\n    Chain: require(\"./Common/Chain\"),\n\n    /**\n     *\n     * Default Assertion instance utility. This provides access to the default\n     * Assert functions.\n     *\n     * @type {Object}\n     *\n     */\n    Assert: require(\"./Common/Assert\"),\n\n    /**\n     *\n     * Assertion utility\n     *\n     * @type {Function}\n     *\n     */\n    Assertion: require(\"./Common/Assertion\"),\n\n    /**\n     *\n     * Schema utility\n     *\n     * @type {Object}\n     *\n     */\n    Schema: require(\"./Common/Schema\"),\n\n    /**\n     *\n     * Custom Schema\n     *\n     * @type {Object}\n     *\n     */\n    CustomSchema: require(\"./Common/CustomSchema\"),\n\n\n};\n\nmodule.exports = Common;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null]},{"name":"src/Common/Type.js","source":"'use strict';\r\n\r\nvar Internal = {};\r\n\r\n/**\r\n *\r\n * The regular expression format\r\n *\r\n * @type {RegExp}\r\n *\r\n */\r\nInternal.RegExpFormat = /^\\/.*\\/(\\w*)$/;\r\n\r\n\r\n\r\nvar Type = {};\r\n\r\n/*\r\n * Get the type of the value\r\n * Possible values are: undefined, object, array, number, string\r\n *\r\n * @param{obj}\r\n * @return{string}\r\n *\r\n */\r\nType.of = function (obj) {\r\n\r\n    var t = typeof obj;\r\n\r\n    if(t == \"object\" && obj instanceof Array){\r\n        return \"array\";\r\n    }\r\n    else if(t == \"object\" && typeof(obj) == \"boolean\"){\r\n        return \"boolean\";\r\n    }\r\n\r\n    return t;\r\n};\r\n\r\n\r\n/*\r\n * Checks if the given value is an array\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isArray = function (value) {\r\n\r\n    return (value instanceof Array);\r\n\r\n};\r\n\r\n\r\n/*\r\n * Checks if the given value is an array\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isBoolean = function (value) {\r\n\r\n    return typeof(value) === \"boolean\";\r\n\r\n};\r\n\r\n\r\n/*\r\n * Checks if the given value is an array\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isFunction = function (value) {\r\n\r\n    return typeof(value) === \"function\";\r\n\r\n};\r\n\r\n\r\n/*\r\n * Checks if the given value is a string\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isString = function (value) {\r\n\r\n    return typeof(value) === \"string\" ||\r\n           value instanceof String;         /// support to custom String declarations\r\n\r\n};\r\n\r\n\r\n/*\r\n * Checks if the given value is an object\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isObject = function (value) {\r\n\r\n    // null or undefined values are objects, but we don't care\r\n    /* jshint -W041 */\r\n    if(value == null) return false;\r\n    if(Type.isArray(value)) return false;\r\n\r\n    return typeof(value) === \"object\";\r\n\r\n};\r\n\r\n/**\r\n * Checks if the given value is a regular expression\r\n *\r\n * @param  {*}          value\r\n * @return {Boolean}\r\n */\r\nType.isRegExp = function (value) {\r\n\r\n    return (value instanceof RegExp);\r\n\r\n};\r\n\r\n/**\r\n * Is value on the regexp string format\r\n *\r\n * @param  {*}          value\r\n * @return {Boolean}\r\n *\r\n */\r\nType.isRegExpStr = function (value) {\r\n\r\n    if(!Type.isString(value)){\r\n        return false;\r\n    }\r\n\r\n    return !!Internal.RegExpFormat.exec(value);\r\n\r\n};\r\n\r\n/*\r\n * Checks if the given value is a number\r\n *\r\n * @param{value} value to check\r\n * @return True|False\r\n *\r\n */\r\nType.isNumber = function (value) {\r\n\r\n    var type = typeof(value);\r\n    if(type != \"number\" && type != \"string\"){\r\n        return false;\r\n    }\r\n\r\n    /// empty strings are equal to 0\r\n    if(type == \"string\" && !value){\r\n        return false;\r\n    }\r\n\r\n    value = Number(value);\r\n    return !isNaN(value);\r\n\r\n};\r\n\r\n\r\n/*\r\n * Test if the value is defined or not\r\n *\r\n * @param {void} value\r\n *\r\n * @return {Boolean}\r\n */\r\nType.isDefined = function(value){\r\n\r\n    /* jshint -W041 */\r\n    if(value != null){\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n\r\n};\r\n\r\n/**\r\n *\r\n * Test if value is instanceOf 'fn'\r\n *\r\n * @param {*} value\r\n * @param {*} fn\r\n * \r\n * @return {Boolean}\r\n * \r\n */\r\nType.instanceOf = function(value, fn){\r\n\r\n    /// take care of javascript quirks first!\r\n    \r\n    if(Type.isString(value) && fn == String){\r\n        return true;\r\n    }\r\n    else if(Type.isNumber(value) && fn == Number){\r\n        return true;   \r\n    }\r\n    else if(Type.isBoolean(value) && fn == Boolean){\r\n        return true;\r\n    }\r\n\r\n    return (value instanceof fn);\r\n    \r\n};\r\n\r\n/**\r\n *\r\n * Tests if the value is Empty\r\n *\r\n * @param  {*}  value\r\n *\r\n * @return {Boolean}\r\n *\r\n */\r\nType.isEmpty = function(value){\r\n\r\n    if( !Type.isDefined(value) ){\r\n\r\n        return true;\r\n    }\r\n\r\n    if( Type.isString(value) ){\r\n\r\n        return value === \"\";\r\n    }\r\n\r\n    if( Type.isObject(value) || Type.isArray(value) ){\r\n\r\n        for (var key in value) {\r\n            // cancel iteration because it has some data\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n};\r\n\r\n\r\nmodule.exports = Type;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,735,null,735,136,null,599,0,null,null,599,null,null,null,null,null,null,null,null,null,null,1,null,25020,null,null,null,null,null,null,null,null,null,null,null,1,null,4962,null,null,null,null,null,null,null,null,null,null,null,1,null,16032,null,null,null,null,null,null,null,null,null,null,null,1,null,5597,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,19923,18427,null,18262,null,null,null,null,null,null,null,null,null,1,null,20,null,null,null,null,null,null,null,null,null,null,1,null,35,4,null,null,31,null,null,null,null,null,null,null,null,null,null,1,null,2097,2097,1711,null,null,null,386,39,null,null,347,347,null,null,null,null,null,null,null,null,null,null,null,1,null,null,4474,858,null,null,3616,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,1225,2,null,1223,0,null,1223,1,null,null,1222,null,null,null,null,null,null,null,null,null,null,null,null,1,null,243,null,230,null,null,13,null,2,null,null,11,null,10,null,2,null,null,8,null,null,null,1,null,null,null,null,1,null]},{"name":"src/Common/Safe.js","source":"'use strict';\r\n\r\n\r\nvar _       = require('lodash'),\r\n    Type    = require('./Type');\r\n\r\n\r\nvar Internal = {};\r\n\r\n/**\r\n *\r\n * The regular expression format\r\n *\r\n * @type {RegExp}\r\n *\r\n */\r\nInternal.RegExpFormat = /^\\/.*\\/(\\w*)$/;\r\n\r\n/**\r\n *\r\n * Converts a strings to a RegExp\r\n *\r\n * @param  {String} str\r\n * @return {RegExp}\r\n */\r\nInternal.stringToRegExp = function(str){\r\n\r\n    str = Safe.string(str);\r\n\r\n    var flags = \"\",\r\n        regexp = Internal.RegExpFormat.exec(str);\r\n\r\n    if(regexp){\r\n\r\n        /// if the string is on // format remove the references\r\n        str = str.replace(/^\\//, \"\")\r\n                .replace(/\\/$/, \"\")\r\n                .trim();\r\n\r\n        flags = regexp[1];\r\n\r\n    }\r\n    else {\r\n        /// strict search\r\n        str = \"^\" + str + \"$\";\r\n    }\r\n\r\n    return new RegExp(str, flags);\r\n\r\n};\r\n\r\n\r\nvar Safe = {};\r\n\r\n/*\r\n * Safelly get array from value\r\n *\r\n * @param {*} value The value to get\r\n * @param {*} defaultValue The value to get\r\n *\r\n * @return {Array}\r\n *\r\n */\r\nSafe.array = function(value, defaultValue){\r\n\r\n    /// if value is null and there is a default value, then\r\n    /// fallback\r\n    /* jshint -W041 */\r\n    if(value == null && defaultValue != null){\r\n        return Safe.array(defaultValue);\r\n    }\r\n\r\n    var isArray = Type.isArray(value);\r\n\r\n    /* jshint -W041 */\r\n    if(!isArray && value != null){\r\n        value = [value];\r\n    }\r\n    else if(!isArray && value == null){\r\n        value = [];\r\n    }\r\n\r\n    return value;\r\n\r\n};\r\n\r\n/*\r\n * Safelly get Boolean from value\r\n *\r\n * @param {*} value The value to get\r\n *\r\n * @return {Boolean}\r\n *\r\n */\r\nSafe.boolean = function(value, defaultValue){\r\n\r\n    if(Type.isBoolean(value)){\r\n        return Boolean(value);\r\n    }\r\n\r\n    /// fallback to the default value\r\n    if(defaultValue !== undefined){\r\n        return Safe.boolean(!!defaultValue);\r\n    }\r\n\r\n    /// if is Number\r\n    if(Type.isNumber(value)){\r\n        value = Number(value);\r\n        return Boolean(value);\r\n    }\r\n\r\n    /// if is String\r\n    if(Type.isString(value)){\r\n        return !!value;\r\n    }\r\n\r\n    return !Type.isEmpty(value);\r\n\r\n};\r\n\r\n\r\n/*\r\n * Safelly get Boolean from value\r\n *\r\n * @param {*} value\r\n * @param {*} defaultValue\r\n *\r\n * @return {String}\r\n *\r\n */\r\nSafe.string = function(value, defaultValue){\r\n\r\n    if(Type.isString(value)){\r\n        return value;\r\n    }\r\n\r\n    return defaultValue !== undefined ?\r\n                Safe.string(defaultValue) : \"\";\r\n\r\n};\r\n\r\n\r\n/*\r\n * Safelly get Object from value\r\n *\r\n * @param {value}           The value to get\r\n * @param {defaultValue}    The default value\r\n *\r\n * @return {Object}\r\n *\r\n */\r\nSafe.object = function(value, defaultValue){\r\n\r\n    if(Type.isObject(value)){\r\n        return value;\r\n    }\r\n\r\n    return defaultValue !== undefined ?\r\n                Safe.object(defaultValue) : {};\r\n\r\n};\r\n\r\n\r\n/*\r\n * Safelly get Number from value\r\n *\r\n * @param {*} value The value to get\r\n * @param {*} defaultValue The default value\r\n *\r\n * @return {Number} The number or 0 if was not success\r\n *\r\n */\r\nSafe.number = function(value, defaultValue){\r\n\r\n    if(Type.isNumber(value)){\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return  defaultValue !== undefined ?\r\n                Safe.number(defaultValue) : 0;\r\n    }\r\n\r\n};\r\n\r\n\r\n/*\r\n * Safelly get Function from value\r\n *\r\n * @param {*} value         The value to get\r\n * @param {*} defaultValue  The value to get\r\n *\r\n * @return {Function}\r\n *\r\n */\r\nSafe.function = function(value, defaultValue){\r\n\r\n    if(Type.isFunction(value)){\r\n        return value;\r\n    }\r\n\r\n    if( Type.isFunction(defaultValue) ){\r\n        value = defaultValue;\r\n    }\r\n\r\n    if(!value){\r\n        value = function(){ };\r\n    }\r\n\r\n    return value;\r\n\r\n};\r\n\r\n\r\n/*\r\n * Safelly get the value. This never return undefined!\r\n *\r\n * @param {*} value         The value to get\r\n * @param {*} defaultValue  The value to get\r\n *\r\n * @return {*}\r\n *\r\n */\r\nSafe.value = function(value, defaultValue){\r\n\r\n    if(Type.isDefined(value)){\r\n        return value;\r\n    }\r\n\r\n    if( Type.isDefined(defaultValue) ){\r\n        return Safe.value(defaultValue);\r\n    }\r\n\r\n    return null;\r\n\r\n};\r\n\r\n/**\r\n *\r\n * Safelly gets an instance of the Class. If the value is an instance of Class\r\n * return it, otherwise return a new instance.\r\n *\r\n * @param  {Object} value\r\n * @param  {Function} Class\r\n * @param  {Array} args\r\n *\r\n * @return {Object}\r\n *\r\n */\r\nSafe.instanceOf = function(value, Class){\r\n\r\n    value   = Safe.object(value);\r\n    Class   = Safe.function(Class);\r\n\r\n    if( value instanceof Class )\r\n    {\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return new Class();\r\n    }\r\n\r\n};\r\n\r\n\r\n/**\r\n *\r\n * Safelly gets the RegExp\r\n *\r\n * @param {*} value\r\n * @param {*} defaultValue\r\n *\r\n * @return {}\r\n *\r\n */\r\nSafe.regexp = function(value, defaultValue){\r\n\r\n    if(Type.isString(value)){\r\n        return Internal.stringToRegExp(value);\r\n    }\r\n\r\n    if(Type.isRegExp(value)){\r\n        return value;\r\n    }\r\n\r\n    if(Type.isDefined(defaultValue)){\r\n        return Safe.regexp(defaultValue);\r\n    }\r\n\r\n    return Internal.stringToRegExp();\r\n\r\n};\r\n\r\n/**\r\n *\r\n * Safelly get the length of the object\r\n *\r\n * @param {*} val\r\n *\r\n * @return {Number}\r\n */\r\nSafe.length = function(val){\r\n\r\n    if( Type.isString(val) || Type.isArray(val) ){\r\n        return val.length;\r\n    }\r\n\r\n    if( Type.isObject(val) ){\r\n        return _.keys(val).length;\r\n    }\r\n\r\n    if( Type.isNumber(val) ){\r\n        return val;\r\n    }\r\n\r\n    if( Type.isBoolean(val) ){\r\n        return val ? 1 : 0;\r\n    }\r\n\r\n    return 0;\r\n\r\n};\r\n\r\n\r\n/**\r\n *\r\n * Coerce the given value from the expected type\r\n *\r\n * @param  {*} value\r\n * @param  {*} expected\r\n * @return {*}\r\n *\r\n */\r\nSafe.coerce = function(value, expected){\r\n\r\n    var expectedType    = Type.of(expected),\r\n        type            = Type.of(value);\r\n\r\n    if(expectedType === type){\r\n        return value;\r\n    }\r\n\r\n    // Expecting a number\r\n    if( Type.isNumber(expected) ){\r\n\r\n        if(Type.isNumber(value)){\r\n            return Number(value);\r\n        }\r\n\r\n    }\r\n\r\n    // Expecting a string\r\n    if( Type.isString(expected) ){\r\n\r\n        if(Type.isNumber(value)){\r\n            return value.toString();\r\n        }\r\n\r\n    }\r\n\r\n    // Expecting a boolean\r\n    if(Type.isBoolean(expected)){\r\n\r\n        /// try to get it from a number\r\n        if(Type.isNumber(value)){\r\n\r\n            value = Safe.number(value);\r\n            if(value === 1){\r\n                return Boolean(true);\r\n            }\r\n            else if(value === 0){\r\n                return Boolean(false);\r\n            }\r\n\r\n        }\r\n        /// try to get it from a string\r\n        else if(Type.isString(value)){\r\n\r\n            value = value.toLowerCase();\r\n\r\n            if(value == \"true\"){\r\n                return Boolean(true);\r\n            }\r\n            else if(value == \"false\"){\r\n                return Boolean(false);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return value;\r\n\r\n};\r\n\r\nmodule.exports = Safe;\r\n","coverage":[null,null,null,1,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,24,null,24,null,null,24,null,null,7,null,null,null,7,null,null,null,null,17,null,null,24,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,5745,7,null,null,5738,null,null,5738,278,null,5460,1793,null,null,5738,null,null,null,null,null,null,null,null,null,null,null,1,null,3436,2451,null,null,null,985,746,null,null,null,239,8,8,null,null,null,231,0,null,null,231,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,3276,1552,null,null,1724,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,19013,17577,null,null,1436,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,106,87,null,null,19,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,2998,1912,null,null,1086,1082,null,null,1086,4,null,null,1086,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1650,712,null,null,938,2,null,null,936,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,65,65,null,65,null,1,null,null,null,64,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,31,19,null,null,12,4,null,null,8,3,null,null,5,null,null,null,null,null,null,null,null,null,null,null,1,null,67,32,null,null,35,10,null,null,25,16,null,null,9,2,null,null,7,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,163,null,null,163,100,null,null,null,63,null,12,3,null,null,null,null,null,60,null,24,17,null,null,null,null,null,43,null,null,10,null,5,5,3,null,2,1,null,null,null,null,5,null,4,null,4,1,null,3,2,null,null,null,null,null,null,36,null,null,null,1,null]},{"name":"src/Common/Arr.js","source":"'use strict';\r\n\r\nvar _           = require(\"lodash\"),\r\n    Type        = require(\"./Type\"),\r\n    Safe        = require(\"./Safe\");\r\n\r\n\r\n\r\nvar Arr = {\r\n\r\n    /**\r\n     * Get index value\r\n     *\r\n     * @param {Array}   array\r\n     * @param {Number}  index\r\n     *\r\n     * @return {*}\r\n     *\r\n     */\r\n    index: function(array, index){\r\n\r\n        array = Safe.array(array);\r\n        index = Safe.number(index);\r\n\r\n        if(index < 0 || index > array.length - 1)\r\n            return null;\r\n\r\n        return array[index];\r\n\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Get last value of the array\r\n     *\r\n     * @param {Array}   array\r\n     *\r\n     * @return {Object}\r\n     *\r\n     */\r\n    last: function(array){\r\n\r\n        array = Safe.array(array);\r\n\r\n        return Arr.index(array, array.length - 1);\r\n\r\n    },\r\n\r\n    /*\r\n     * Get first value of the array\r\n     *\r\n     * @param {Array}   array\r\n     *\r\n     * @return {Object}\r\n     *\r\n     */\r\n    first: function(array){\r\n\r\n        return Arr.index(array);\r\n\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Returns the length of the array\r\n     *\r\n     * @param {Array}   array\r\n     *\r\n     * @return {Number}\r\n     *\r\n     */\r\n    length: function(array){\r\n\r\n        array = Safe.array(array);\r\n\r\n        return array.length;\r\n\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Inserts the value in the specified index of the array\r\n     *\r\n     * @param {Array}   array\r\n     * @param {*}       value\r\n     * @param {Number}  index\r\n     *\r\n     * @return {Array}\r\n     *\r\n     */\r\n    insert: function(array, value, index){\r\n\r\n        array = Safe.array(array);\r\n        value = Safe.array(value);\r\n\r\n        /* jshint -W041 */\r\n        if(index == null){\r\n            index = Arr.length(array);\r\n        } else {\r\n            index = Safe.number(index);\r\n        }\r\n\r\n        // merge the structures\r\n        _.each(\r\n            value.reverse(),\r\n            function(item){\r\n                array.splice(index, 0, item);\r\n            }\r\n        );\r\n\r\n        return array;\r\n\r\n    },\r\n\r\n    /*\r\n     * Remove index of the array. If no index is specified the first\r\n     * element is removed.\r\n     *\r\n     * Returns the removed elements.\r\n     *\r\n     * @param {Array}   index\r\n     * @param {Number}  index\r\n     * @param {Number}  n\r\n     *\r\n     * @return {Array}\r\n     *\r\n     */\r\n    remove: function(array, index, n){\r\n\r\n        array   = Safe.array(array);\r\n        index   = Safe.number(index, 0);\r\n        n       = Safe.number(n, 1);\r\n\r\n        return array.splice(index, n);\r\n\r\n    }\r\n\r\n};\r\n\r\n\r\nmodule.exports = Arr;\r\n\r\n","coverage":[null,null,1,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,11,11,null,11,5,null,6,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,7,null,null,7,3,null,4,null,null,null,7,null,null,9,null,null,null,7,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,7,7,null,7,null,null,null,null,null,null,1,null,null]},{"name":"src/Common/Obj.js","source":"'use strict';\r\n\r\nvar _           = require(\"lodash\"),\r\n    Safe        = require(\"./Safe\");\r\n\r\n\r\nvar Obj = {\r\n\r\n    /**\r\n     *\r\n     * Get the object keys. If a filter is specified it returns the keys\r\n     * that match the filter regular expression.\r\n     *\r\n     * @param {Object}          obj\r\n     * @param {String|RegExp}   filter\r\n     *\r\n     * @return {Array}\r\n     *\r\n     */\r\n    filter: function(obj, filter){\r\n\r\n        obj         = Safe.object(obj);\r\n        filter      = Safe.regexp(filter, \"/.*/\");\r\n\r\n        return _.transform(\r\n            obj,\r\n            function(result, val, key){\r\n\r\n                if(filter.exec(key)){\r\n                    result.push(key);\r\n                }\r\n\r\n                return result;\r\n\r\n            },\r\n            []);\r\n\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Obj;","coverage":[null,null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,null,3,null,null,null,6,3,null,null,6,null,null,null,null,null,null,null,null,1]},{"name":"src/Common/I18N/String.js","source":"\"use strict\";\n\nvar _       = require(\"lodash\"),\n    Safe    = require(\"../Safe\");\n\n\n/**\n *\n * Internal methdos\n *\n * @type {Object}\n *\n */\nvar Internal = {};\n\n/**\n *\n * Apply the template. The scope of the function is the string.\n *\n * @throws {Error} If template data its missing or wrong\n *\n * @param  {String} name\n * @param  {Object} data\n * @param  {Object} messages\n * @param  {Object} customMessages\n *\n * @return {String}\n *\n */\nInternal.applyTemplate = function(name, data, messages, customMessages){\n\n    name            = Safe.string(name);\n    data            = Safe.object(data);\n    messages        = Safe.object(messages);\n    customMessages  = Safe.object(customMessages);\n\n    messages = _.extend({}, messages, customMessages);\n\n    var tmplStr = Safe.string(messages[name]) || name;\n\n    return _.template(tmplStr)(data);\n\n};\n\n/**\n *\n * Template String class. Each string is identified by a name. The template string\n * can be changed when calling toString.\n *\n * @param {String} name\n * @param {Object} data\n * @param {Object} messages\n *\n * @example\n * var str = new I18nString(\"asas\", {}, {});\n *\n */\nvar I18NString = function(name, data, messages){\n\n    name        = Safe.string(name);\n    data        = Safe.object(data);\n    messages    = Safe.object(messages);\n\n    /**\n     *\n     * toString()\n     *\n     * @throws {Error} If template is not correct\n     *\n     * @param  {String} messages\n     * @param  {Object} data\n     * @return {String}\n     *\n     */\n    this.toString = function(customMessages){\n\n        try{\n\n            return Internal.applyTemplate.apply(this, [ name, data, messages, customMessages ]);\n\n        } catch(e){\n\n            var error = _.template(\n                \"Error on template '<%= name %>': <%= error %>\")({\n                    name: name,\n                    error: e.message\n                });\n\n            throw new Error(error);\n\n        }\n\n    };\n\n    /// Initialize string by calling .super()\n    String.call( this, this.toString() );\n\n};\n\n/// inherit from String\n/* jshint -W053 */\nI18NString.prototype = new String();\nI18NString.prototype.constructor = I18NString;\n\nmodule.exports = I18NString;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,258,258,258,258,null,258,null,258,null,258,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,105,105,105,null,null,null,null,null,null,null,null,null,null,null,null,105,null,258,null,258,null,null,null,1,null,null,null,null,null,1,null,null,null,null,null,null,105,null,null,null,null,null,1,1,null,1,null]},{"name":"src/Common/Exception/Exception.js","source":"\"use strict\";\n\nvar _           = require(\"lodash\"),\n    Type        = require(\"../Type\"),\n    Safe        = require(\"../Safe\"),\n    I18NString  = require(\"../I18N/String\"),\n    Messages    = require(\"../I18N/Messages\");\n\n\n/**\n *\n * Internal methods\n *\n * @type {Object}\n *\n */\nvar Internal = {};\n\n/**\n *\n * Get message\n *\n * @param  {Object} messages\n *\n * @return {I18NMessage}\n *\n */\nInternal.getI18NMessage = function(message, messageData){\n\n    messageData = Safe.object(messageData);\n\n    if( message instanceof I18NString ){\n        return message;\n    }\n\n    /// if message is null or empty\n    if( Type.isString(message) ){\n        return new I18NString(message, messageData, Messages);\n    }\n\n    return new I18NString(\"\");\n\n};\n\n/**\n *\n * Get the stack trace\n *\n * @return {String}\n *\n */\nInternal.getStackTrace = function(){\n\n    var error    = new Error(),\n        stackStr = Safe.string(error.stack),\n        stack    = stackStr.split('\\n');\n\n    /// Remove Error message + 2 first lines of the stack trace\n    stack.splice(0,3);\n\n    return stack.join('\\n');\n\n};\n\n/**\n *\n * @class Error Class\n *\n * @param {String|I18NString} message\n *\n */\nvar Exception = function(message, messageData) {\n\n    message     = Internal.getI18NMessage(message, messageData);\n    messageData = Safe.object(messageData);\n\n    /// get the stack trace\n    var stack = Internal.getStackTrace();\n\n    /// define the error message\n    Object.defineProperty(\n        this,\n        \"message\",\n        {\n            get: function(){\n                return this.toString();\n            },\n            configurable: false\n        }\n    );\n\n    /// define the this.stack to return the created Error\n    /// stack\n    Object.defineProperty(\n        this,\n        'stack', {\n        get: function() {\n            return this.toString() + \"\\n\" + stack;\n        },\n        configurable: false\n    });\n\n    /**\n     *\n     * ToString method with i18n support\n     *\n     * @param  {Object} translations\n     *\n     * @return {String}\n     *\n     */\n    this.toString = function(translations){\n        return message.toString(translations);\n    };\n\n};\n\nException.prototype = new Error();\nException.prototype.constructor = Exception;\n\nmodule.exports = Exception;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,98,null,98,1,null,null,null,97,97,null,null,0,null,null,null,null,null,null,null,null,null,null,1,null,98,null,null,null,null,98,null,98,null,null,null,null,null,null,null,null,null,null,1,null,98,98,null,null,98,null,null,98,null,null,null,null,17,null,null,null,null,null,null,null,98,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,98,145,null,null,null,null,1,1,null,1,null]},{"name":"src/Common/I18N/Messages.js","source":"\"use strict\";\n\nvar Messages = {};\n\n/**\n *\n * Invalid value\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_INVALID_VALUE = \"<%= value %> is invalid.\";\n\n/**\n *\n * Required value\n *\n * @type {String}\n */\nMessages.VALIDATION_REQUIRED = \"Value is required.\";\n\n/**\n *\n * Array expected\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_TYPE = \"'<%= expected %>' was expected but found '<%= value %>' instead.\";\n\n/**\n *\n * Max exceed\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_MAX = \"The maximum value allowed is <%= value %>.\";\n\n/**\n *\n * Min exceed\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_MIN = \"The minimum value allowed is <%= value %>.\";\n\n/**\n *\n * Min exceed\n *\n * @type {String}\n *\n */\nMessages.REGEXP = \"Regular expression '<%= value %>' doesn't match.\";\n\n/**\n *\n * Invalid List lenght\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_INVALID_LIST_LENGTH = \"Expected list with <%= expected %> items but found <%= value %>.\";\n\n/**\n *\n * Invalid List\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_INVALID_LIST_LENGTH_MULTIPLE_OF = \"Expected list length to be multiple of <%= expected %> but found length of <%= value %>.\";\n\n/**\n *\n * Invalid List\n *\n * @type {String}\n *\n */\nMessages.VALIDATION_INSTANCEOF = \"Expected instance of '<%= value %>'.\";\n\nmodule.exports = Messages;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,1,null]},{"name":"src/Common/Exception/ExceptionList.js","source":"\"use strict\";\n\nvar _               = require(\"lodash\"),\n    Type            = require(\"../Type\"),\n    Safe            = require(\"../Safe\"),\n    Exception       = require(\"./Exception\");\n\n/**\n *\n * Get the stack trace\n *\n * @return {String}\n *\n */\nvar getStackTrace = function(){\n\n    var error    = new Error(),\n        stackStr = Safe.string(error.stack),\n        stack    = stackStr.split('\\n');\n\n    /// Remove Error message + 2 first lines of the stack trace\n    stack.splice(0,3);\n\n    return stack.join('\\n');\n\n};\n\n/**\n *\n * Error class that can contain multiple errors\n * @class\n *\n */\nvar ExceptionList = function() {\n\n    /// instance of error\n    var items  = [];\n\n    /// get the stack trace\n    var stack = getStackTrace();\n\n    /// define the this.stack to return the created Error\n    /// stack\n    Object.defineProperty(\n        this,\n        'stack', {\n        get: function() {\n            return this.toString() + \"\\n\" + stack;\n        }\n    });\n\n    Object.defineProperty(\n        this,\n        \"message\",\n        {\n            get: function(){\n                return this.toString();\n            },\n            configurable: false\n        }\n    );\n\n    Object.defineProperty(\n        this,\n        \"items\",\n        {\n            get: function(){\n                return _.clone(items);\n            },\n            configurable: false\n        }\n    );\n\n    Object.defineProperty(\n        this,\n        \"length\",\n        {\n            get: function(){\n                return items.length;\n            },\n            configurable: false\n        }\n    );\n\n    /**\n     *\n     * Adds an element to the error list\n     *\n     * @throws {Error} If invalid argument\n     *\n     * @param {*} errors\n     *\n     */\n    this.push = function(errors){\n\n        var scope = this;\n\n        /// if argument is an ExceptionList\n        if(errors instanceof ExceptionList){\n            errors = errors.items;\n        }\n\n        /// make sure errors is an array\n        errors = Safe.array(errors);\n\n        /// adds the elements to the list\n        _.each(\n            errors,\n            function(error){\n\n                /// if error is on string format add it as an Exception\n                if( Type.isString(error) ){\n                    error = new Exception(error);\n                }\n\n                if( !(error instanceof Error) ){\n                    throw new Error(\"Expected instance of type Error\");\n                }\n\n                items.push(error);\n\n            });\n\n    };\n\n    /**\n     *\n     * Clear the error list\n     *\n     * @return\n     *\n     */\n    this.clear = function(){\n        while(items.length) items.pop();\n    };\n\n    /**\n     *\n     * ToString\n     *\n     * @param {Object} translations\n     *\n     * @return {String}\n     *\n     */\n    this.toString = function(translations){\n\n        var str         = \"\",\n            length      = items.length,\n            separator   = \", \";\n\n        _.each(\n            items,\n            function(error, index){\n\n                if(error instanceof Exception){\n                    str += error.toString(translations);\n                }\n                else {\n                    str += error.toString();\n                }\n\n                /// add the separator if its not the last element\n                if(index != length-1){\n                    str += separator;\n                }\n\n            });\n\n        return str;\n\n    };\n\n};\n\nExceptionList.prototype = new Error();\nExceptionList.prototype.constructor = ExceptionList;\n\n\nmodule.exports = ExceptionList;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,670,null,null,null,null,670,null,670,null,null,null,null,null,null,null,null,null,1,null,null,670,null,null,670,null,null,null,670,null,null,null,0,null,null,null,670,null,null,null,null,13,null,null,null,null,null,670,null,null,null,null,52,null,null,null,null,null,670,null,null,null,null,515,null,null,null,null,null,null,null,null,null,null,null,null,null,null,670,null,88,null,null,88,33,null,null,null,88,null,null,88,null,null,null,null,91,4,null,null,91,1,null,null,90,null,null,null,null,null,null,null,null,null,null,null,null,670,3,null,null,null,null,null,null,null,null,null,null,null,670,null,65,null,null,null,65,null,null,null,71,71,null,null,0,null,null,null,71,6,null,null,null,null,65,null,null,null,null,null,1,1,null,null,1,null]},{"name":"src/Common/Url.js","source":"'use strict';\n\nvar _           = require(\"lodash\"),\n    UrlParser   = require(\"./Url/Parser\");\n\n\n/**\n *\n * @class\n * The Url object\n *\n * @param {[type]} url The Url\n *\n */\nvar Url = function(url){\n\n    url = UrlParser.normalize(url);\n\n    var _this = {\n\n        /**\n         * Tests if the url is absolute\n         *\n         * @return {Boolean}\n         *\n         */\n        isAbsolute: function(){\n            return UrlParser.isAbsolute(url);\n        },\n\n        /**\n         * Gets the baseUrl\n         *\n         * @return {String}\n         *\n         */\n        baseUrl: function(){\n            return UrlParser.baseUrl(url);\n        },\n\n        /**\n         * Gets the protocol\n         *\n         * @return {String}\n         *\n         */\n        protocol: function(){\n            return UrlParser.protocol(url);\n        },\n\n        /**\n         * Gets the path of the url\n         *\n         * @return {String}\n         *\n         */\n        path: function(){\n            return UrlParser.path(url);\n        },\n\n        /**\n         * Gets the file name\n         * @return {String}\n         */\n        filename: function(){\n            return UrlParser.filename(url);\n        },\n\n        /**\n         * Gets the file path\n         * @return {String}\n         */\n        filepath: function(){\n            return UrlParser.filepath(url);\n        },\n\n        /**\n         * Gets the path of the url\n         *\n         * @return {String}\n         *\n         */\n        setPath: function(path){\n\n            path = UrlParser.normalize(path);\n\n            var isAbsolute = UrlParser.isAbsolute(path);\n            if(isAbsolute){ return false; }\n\n            if(path.indexOf(\"/\") === 0){\n                url = UrlParser.normalize( _this.baseUrl() + path );\n            }\n            else{\n                url = UrlParser.normalize( _this.baseUrl() + _this.path() + path );\n            }\n\n            return true;\n\n        },\n\n        /**\n         *\n         * @return {[type]} [description]\n         */\n        toString: function(){\n            return UrlParser.normalize(url);\n        }\n\n    };\n\n\n    return _this;\n\n};\n\n\nmodule.exports = Url;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,14,null,14,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,5,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,5,null,5,5,null,5,1,null,null,4,null,null,5,null,null,null,null,null,null,null,null,8,null,null,null,null,null,14,null,null,null,null,1,null]},{"name":"src/Common/Url/Parser.js","source":"'use strict';\r\n\r\n\r\nvar _       = require(\"lodash\"),\r\n    Type    = require(\"../Type\");\r\n\r\n\r\n/// regular expression to get the baseUrl\r\nvar BaseUrlRegExStr = '^[a-z]+://[a-z.-]+(?::[0-9]+)?';\r\n/// regular expression to get the protocol\r\nvar ProtocolRegExStr = '^([a-z]+)://';\r\n\r\n\r\n\r\nvar UrlParser = {\r\n\r\n    /**\r\n     * Normalize url\r\n     *\r\n     * @return{String} the current url\r\n     */\r\n    normalize: function(url) {\r\n    \r\n        if(!url) return \"\";\r\n\r\n        /// replace all //// to a single slash\r\n        url = url.replace(/\\/+/g, \"/\");\r\n        /// because previouly all // were replaced lets fix the protocol syntax (http://)\r\n        url = url.replace(/:\\//g, \"://\");\r\n\r\n        return url;\r\n\r\n    },\r\n\r\n    /**\r\n     * Test if the url is absolute\r\n     * \r\n     * @return {Boolean}\r\n     * \r\n     */\r\n    isAbsolute: function(url){\r\n\r\n        var regex = new RegExp(BaseUrlRegExStr, \"i\");\r\n        return !! regex.exec(url);\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the protocol of the url \r\n     * \r\n     * @param  {String} url\r\n     * @return {String}\r\n     */\r\n    protocol: function(url){\r\n\r\n        var regex = new RegExp(ProtocolRegExStr, \"gi\");\r\n        var result = regex.exec(url);\r\n        if(result) return result[1];\r\n        \r\n        return \"\";\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the baseUrl for the given url\r\n     * \r\n     * @param  {String} url\r\n     * @return {String}\r\n     */\r\n    baseUrl: function(url){\r\n\r\n        var regex = new RegExp(BaseUrlRegExStr, \"i\");\r\n\r\n        var result = \"\",\r\n            regexResult = regex.exec(url);\r\n\r\n        if(regexResult){\r\n            /// always add / at the end of baseUrl\r\n            result = regexResult.shift() + \"/\";\r\n        }\r\n\r\n        return UrlParser.normalize(result);\r\n\r\n    },\r\n\r\n    /**\r\n     * Get the path of the url\r\n     * \r\n     * @param  {String} url\r\n     * @return {String}\r\n     */\r\n    path: function(url){\r\n\r\n        // sanitize input\r\n        url = url || \"\";\r\n\r\n        var baseUrl = UrlParser.baseUrl(url) || \"\";\r\n\r\n        // remove the base url\r\n        url = url.replace(baseUrl, \"\");\r\n\r\n        // remove the last part of the url. this may be a \"/\"\" or \"filehandler\"\r\n        var urlParts = url.split(\"/\");\r\n        urlParts.pop();\r\n        urlParts.push(\"\");\r\n        \r\n        // join all\r\n        url = urlParts.join(\"/\");\r\n\r\n        return UrlParser.normalize(url);\r\n    },\r\n\r\n    /**\r\n     * Get the file name\r\n     * \r\n     * @return {[type]} [description]\r\n     * \r\n     */\r\n    filename: function(url){\r\n\r\n        // sanitize input\r\n        url = url || \"\";\r\n\r\n        var urlParts = url.split(\"/\");\r\n        \r\n        var filename = urlParts.pop().replace(/\\?.*$/, \"\");\r\n        \r\n        return filename;\r\n\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the entire File Path\r\n     * \r\n     * @param  {String} url\r\n     * @return {String}\r\n     */\r\n    filepath: function(url){ \r\n\r\n        return UrlParser.normalize(\r\n            UrlParser.baseUrl(url) + \r\n            UrlParser.path(url) + \r\n            UrlParser.filename(url));\r\n\r\n    },\r\n\r\n    /**\r\n     * get's the query string part of the url\r\n     *\r\n     * @param{href} The full url or null to get the current\r\n     * @param{separator} The url qs separator. Normally is ?\r\n     * @return{String} The query string part of the url\r\n     */\r\n    queryString: function(href, separator) {\r\n\r\n        href = href || \"\";\r\n        separator = separator || '?';\r\n\r\n        var hrefSplit = href.split(separator) || [];\r\n        \r\n        if(hrefSplit.length > 1){\r\n            \r\n            // query strin can be malformed like ?a=1&?b=2\r\n            // we can fix this\r\n            var qStringPart = hrefSplit.splice(1, hrefSplit.length-1);\r\n            var qString = \"\";\r\n            _.forEach(qStringPart, function(qs){\r\n                qString += qs;\r\n            });\r\n\r\n            return qString;\r\n        }\r\n\r\n        return \"\";\r\n    },\r\n\r\n    /*\r\n     * Parse query string from url\r\n     *\r\n     * @param{separator} The url qs separator. Normally is ?\r\n     * @return An hash with all the query string key/value's\r\n     */\r\n    queryStringObj: function(href, separator) {\r\n    \r\n        href = href || \"\";\r\n\r\n        var qString = UrlParser.queryString(href, separator),\r\n            values = {};\r\n\r\n        qString = decodeURI(qString || \"\");\r\n        _.each(\r\n            qString.split(\"&\"),\r\n            function(keyValue){\r\n\r\n                // ignore if \r\n                if(!keyValue) return;\r\n\r\n                var pair = keyValue.split(\"=\");\r\n                \r\n                if(pair.length>1)\r\n                    values[pair[0]] = pair[1];\r\n                else\r\n                    values[pair[0]] = true; // it's more easy to use on conditions\r\n                    \r\n\r\n            });\r\n\r\n        return values;\r\n    }\r\n\r\n\r\n\r\n};\r\n\r\nmodule.exports = UrlParser;\r\n","coverage":[null,null,null,1,null,null,null,null,1,null,1,null,null,null,1,null,null,null,null,null,null,null,null,90,null,null,63,null,63,null,63,null,null,null,null,null,null,null,null,null,null,null,10,10,null,null,null,null,null,null,null,null,null,null,null,4,4,4,null,2,null,null,null,null,null,null,null,null,null,null,null,33,null,33,null,null,33,null,22,null,null,33,null,null,null,null,null,null,null,null,null,null,null,null,16,null,16,null,null,16,null,null,16,16,16,null,null,16,null,16,null,null,null,null,null,null,null,null,null,null,null,12,null,12,null,12,null,12,null,null,null,null,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,null,4,null,4,null,null,null,2,2,2,2,null,null,2,null,null,2,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,2,2,null,null,null,null,3,null,2,null,2,2,null,0,null,null,null,null,2,null,null,null,null,null,null,1,null]},{"name":"src/Common/Chain.js","source":"'use strict';\n\nvar _    = require(\"lodash\"),\n    Type = require(\"./Type\"),\n    Safe = require(\"./Safe\"),\n    ChainContext    = require(\"./Chain/ChainContext\");\n\n\n\n/**\n *\n * Module internal code\n *\n * @type {Object}\n *\n */\nvar Internal = {};\n\n/**\n *\n * Gets the argument list\n *\n * @param  {Object} argsObj\n * @return {Array}\n *\n */\nInternal.getArgumentList = function(argsObj){\n\n    var args = [];\n\n    _.each(argsObj, function(obj, index){\n        args.push(obj);\n    });\n\n    return args;\n\n};\n\n/**\n *\n * Wraps the chainable function\n *\n * @param {Internal.ChainContext} context\n * @param {Function}    fn\n * @param {Object}      chainableFns\n * @param {Object}      evaluationFns\n * @param {Object}      options\n *\n * @return {Function}\n *\n */\nInternal.wrapChainableFunction = function(context, fn, chainableFns, evaluationFns, options){\n\n    options = Safe.object(options);\n\n    return function() {\n\n        var curContext  = context,\n            args        = Internal.getArgumentList(arguments);\n\n        /// initialize context if needed\n        if(!curContext){\n            curContext = new ChainContext(options);\n        }\n\n        /// add the function to the curContext\n        curContext.add(fn, args);\n\n        /// this is usefull to create \"typed\" instances of the Chain\n        var ChainClass = Safe.function(options.type, Chain);\n\n        return new ChainClass(chainableFns, evaluationFns, options, curContext);\n\n    };\n\n};\n\n/**\n *\n * Wraps a returnable function. The last argument of the function is always the error, or null\n * if doesn't exists.\n *\n * @param {Internal.ChainContext} context\n * @param {Function}    fn\n * @param {Object}      chainableFns\n * @param {Object}      evaluationFns\n * @param {Object}      options\n *\n * @return {Function}\n *\n */\nInternal.wrapReturnableFunction = function(context, fn, chainableFns, evaluationFns, options){\n\n    options = Safe.object(options);\n\n    return function() {\n\n        var curContext  = context,\n            args        = Internal.getArgumentList(arguments);\n\n        /// initialize context if needed\n        if(!curContext){\n            curContext = new ChainContext(options);\n        }\n\n        var result  = null,\n            err     = null;\n\n        /// wrap the arguments to .apply call. The last argument should be the one defined\n        /// on the options.\n        var _args = [ args.shift() ];\n\n        /// sets the scope of the context\n        var scope = curContext.setScope(options.scope);\n\n        try {\n            /// execute all the chained functions\n            result = curContext.exec(_args, options.argument);\n        }\n        catch(e){\n            err = e;\n        }\n\n        /// if its on pipe mode, wrap the result so it can be correctly .apply()\n        if(options.pipe){\n            result = [ result ];\n        }\n\n        /// create the evaluation function arguments\n        var fnArgs = Safe.array(result, [ null ])\n            /// concat the arguments if they are not undefined\n            .concat(Safe.array(args))\n            /// concat the argument if is not undefined\n            .concat(Safe.array(options.argument))\n            /// concat the err as last argument\n            .concat([err]);\n\n        return fn.apply(scope, fnArgs);\n\n    };\n\n};\n\n/**\n *\n * Get chain functions\n *\n * @param  {Internal.CurrentAssertionContext} assertionContext\n * @param  {Object} chainableFns\n * @param  {Object} evaluationFns\n * @param  {Object} options\n *\n * @return {Object}\n *\n */\nInternal.getChainFunctions = function(context, chainableFns, evaluationFns, options){\n\n    /// merge the default fns and the custom functions\n    var fns = _.assign({}, chainableFns);\n\n    /// wrap the chainable functions\n    _.each(\n        fns,\n        function(fn, name){\n\n            if(Type.isFunction(fn)){\n                fns[name] = Internal.wrapChainableFunction(context, fn, chainableFns, evaluationFns, options);\n            }\n\n        });\n\n    /// wrap the returning functions\n    _.each(\n        evaluationFns,\n        function(fn, name){\n\n            if(Type.isFunction(fn)){\n                fns[name] = Internal.wrapReturnableFunction(context, fn, chainableFns, evaluationFns, options);\n            }\n\n        });\n\n    return fns;\n\n};\n\n/**\n *\n * Chain constructor\n * @class\n *\n * @param {Object}          chainableFns\n * @param {Object}          evaluationFns\n * @param {Object}          options\n * @param {ChainContext}    context\n *\n * @return {Object}\n *\n *\n * @example\n *\n * new Chain(\n *\n *     /// chainable fns\n *     {\n *         \"fn\": function(){}\n *     },\n *\n *     /// evaluation fns\n *     {},\n *\n *     /// options fns\n *     {\n *         type         : {},\n *         pipe         : [true|false],\n *         scope        : Function,\n *         argument     : undefined\n *     },\n *\n *     /// context\n *     {}\n *\n * );\n *\n *\n */\nvar Chain = function(chainableFns, evaluationFns, options, context){\n\n    var scope   = this;\n\n    /// chain the functions\n    var fns = Internal.getChainFunctions(context, chainableFns, evaluationFns, options);\n\n    /// initialize this context\n    _.each(fns, function(val, key){\n        scope[key] = val;\n    });\n\n};\n\nChain.prototype = {};\n\n\nmodule.exports = Chain;\n\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,1678,null,1678,1564,null,null,1678,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,8700,null,8700,null,868,null,null,null,868,792,null,null,null,868,null,null,868,null,868,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,2252,null,2252,null,810,null,null,null,810,3,null,null,810,null,null,null,null,810,null,null,810,null,810,null,810,null,null,6,null,null,null,810,5,null,null,null,810,null,null,null,null,null,null,null,810,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,908,null,null,908,null,null,null,8700,8700,null,null,null,null,null,908,null,null,null,2252,2252,null,null,null,null,908,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,908,null,null,908,null,null,908,10952,null,null,null,null,1,null,null,1,null,null]},{"name":"src/Common/Chain/ChainContext.js","source":"'use strict';\n\nvar _    = require(\"lodash\"),\n    Safe = require(\"../Safe\"),\n    Type = require(\"../Type\"),\n\n    ChainFunction   = require(\"./ChainFunction\");\n\n\n/**\n *\n * A chain context keeps track of the current chainable state\n * @class\n *\n * @param {Object} options\n *\n * @example\n *\n * new ChainContext({\n *\n *     pipe:\n * })\n */\nvar ChainContext = function(options){\n\n    options = Safe.object(options);\n\n    /**\n     * The context registered functions\n     *\n     * @type { [Internal.AssertionFunction] }\n     *\n     */\n    this.fns = [];\n\n    /**\n     *\n     * The shared fn context\n     *\n     * @type {Object}\n     *\n     */\n    this.scope = this.setScope(options.scope);\n\n    /**\n     *\n     * Pipe mode context\n     *\n     * @type {Boolean}\n     *\n     */\n    this.pipe = Safe.boolean(options.pipe);\n\n};\n\n/**\n *\n * Sets the scope of this context.\n *\n * @param  {Object|Function} scope\n * @return {Object}\n */\nChainContext.prototype.setScope = function(scope){\n\n    if(Type.isDefined(scope)){\n        scope = Type.isFunction(scope) ? scope() : scope;\n    }\n\n    /// Maintain the current context if not defined\n    scope = scope || this.scope;\n\n    /// set the context\n    this.scope = Safe.object(scope, {});\n\n    return this.scope;\n\n};\n\n/**\n *\n * Chain the given function\n *\n * @param  {Function|Object}   fn\n * @param  {Array}  args\n *\n * @return {Internal.Chain}\n *\n */\nChainContext.prototype.add = function(fn, args){\n\n    if(Type.isFunction(fn)) {\n\n        fn = new ChainFunction({ fn: fn, args: args });\n\n        this.fns.push( fn );\n\n    }\n\n};\n\n/**\n *\n * Execute the context using the given argument as parameter\n *\n * @param  {*}          args\n * @param  {Array}      extraArgs\n * @param  {Funcion}    errCallback\n *\n * @return {*}\n **\n */\nChainContext.prototype.exec = function(args, extraArgs, errCallback){\n\n    extraArgs   = Safe.value(extraArgs);\n    errCallback = Safe.function(errCallback, function(err){ throw err; });\n\n    var self    = this,\n        result  = args,\n        error   = null;\n\n    /// execute the functions\n    _.each(\n        this.fns,\n        function(fn, index){\n\n            try {\n\n                /// really execute the function\n                var value = fn.apply(self.scope, result, extraArgs);\n\n                /// if chain return values between the functions\n                if(self.pipe) {\n                    result = value;\n                }\n\n            } catch(e){\n                error = e;\n            }\n\n            /// stop iterating\n            if(error !== null){\n                return false;\n            }\n\n        });\n\n    /// if an error exists\n    if(error){\n        errCallback(error);\n        return null;\n    }\n\n    /// returns\n    return result;\n\n};\n\nmodule.exports = ChainContext;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,800,null,null,null,null,null,null,null,800,null,null,null,null,null,null,null,null,800,null,null,null,null,null,null,null,null,800,null,null,null,null,null,null,null,null,null,null,1,null,1610,109,null,null,null,1610,null,null,1610,null,1610,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,883,null,880,null,880,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,815,815,null,815,null,null,null,null,815,null,null,null,917,null,null,917,null,null,910,20,null,null,null,7,null,null,null,917,7,null,null,null,null,null,815,7,1,null,null,null,808,null,null,null,1,null]},{"name":"src/Common/Chain/ChainFunction.js","source":"'use strict';\r\n\r\nvar _    = require(\"lodash\"),\r\n    Type = require(\"../Type\"),\r\n    Safe = require(\"../Safe\");\r\n\r\n/**\r\n * @class\r\n * The ChainFunction wraps the functionality of a function executed\r\n * on a chain context.\r\n *\r\n * @param {Object} options\r\n *\r\n * @example\r\n * new ChainFunction({\r\n *     fn   : function(){},\r\n *     args : []\r\n * });\r\n *\r\n */\r\nvar ChainFunction = function(options){\r\n\r\n    options = Safe.object(options);\r\n\r\n    this.name   = Safe.string(options.name, \"?\");\r\n    this.fn     = Safe.function(options.fn, function(){});\r\n    this.args   = Safe.array(options.args);\r\n\r\n};\r\n\r\n/**\r\n *\r\n * Execute the function within the context of the given scope and args.\r\n *\r\n * The arguments of the function will be the concatenation of the given\r\n * args and the instance arguments.\r\n *\r\n * @param  {*} scope\r\n * @param  {*} args\r\n * @param  {*} extraArgs\r\n *\r\n * @return {*}\r\n *\r\n */\r\nChainFunction.prototype.apply = function(scope, args, extraArgs) {\r\n\r\n    scope       = Safe.object(scope);\r\n    args        = Safe.array(args);\r\n    extraArgs   = Safe.array(extraArgs);\r\n\r\n    /// the given args should always exist\r\n    if(args.length === 0) args = [ null ];\r\n\r\n    /// concatenate the given arguments with the instance\r\n    args = args.concat(this.args).concat(extraArgs);\r\n\r\n    /// execute function with obj scope and the given arguments\r\n    return this.fn.apply(scope, args);\r\n\r\n};\r\n\r\n\r\nmodule.exports = ChainFunction;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,883,null,883,883,883,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,921,921,921,null,null,921,null,null,921,null,null,921,null,null,null,null,1,null]},{"name":"src/Common/Assert.js","source":"'use strict';\r\n\r\nvar Assertion = require(\"./Assertion\");\r\n\r\nmodule.exports = new Assertion();\r\n","coverage":[null,null,1,null,1,null]},{"name":"src/Common/Assertion.js","source":"'use strict';\r\n\r\nvar _               = require(\"lodash\"),\r\n    Safe            = require(\"./Safe\"),\r\n    Chain           = require(\"./Chain\"),\r\n    ChainContext    = require(\"./Chain/ChainContext\");\r\n\r\n\r\n/**\r\n *\r\n * The Chainable functions\r\n *\r\n * @type {Object}\r\n *\r\n */\r\nvar ChainableFns = {};\r\n\r\nChainableFns.required   = require(\"./Assert/Required\");\r\nChainableFns.string     = require(\"./Assert/String\");\r\nChainableFns.object     = require(\"./Assert/Object\");\r\nChainableFns.array      = require(\"./Assert/Array\");\r\nChainableFns.number     = require(\"./Assert/Number\");\r\nChainableFns.max        = require(\"./Assert/Max\");\r\nChainableFns.min        = require(\"./Assert/Min\");\r\nChainableFns.regex      = require(\"./Assert/Regex\");\r\nChainableFns.instanceOf = require(\"./Assert/InstanceOf\");\r\n\r\n/**\r\n *\r\n * The Assertion functions\r\n *\r\n * @type {Object}\r\n *\r\n */\r\nvar AssertionFns = {};\r\n\r\n/**\r\n *\r\n * Tests if the combination of rules are valid\r\n *\r\n * @param  {*}          result\r\n * @param  {Error}      err\r\n * @return {Boolean}\r\n */\r\nAssertionFns.isValid = function(result, err){\r\n    return !err;\r\n};\r\n\r\n/**\r\n *\r\n * Assert\r\n *\r\n * @param  {*}      result\r\n * @param  {Error}  err\r\n * @return {}\r\n *\r\n */\r\nAssertionFns.assert = function(result, err){\r\n\r\n    if(err){\r\n        throw err;\r\n    }\r\n\r\n    return result;\r\n\r\n};\r\n\r\n/**\r\n *\r\n * Construct a new Assertion provider. This can have some custom actions.\r\n * @class\r\n *\r\n * @param {Object} fns\r\n *\r\n * @return {Object}\r\n *\r\n * @example\r\n *\r\n * Assertion({})\r\n *     .required()\r\n *     .string()\r\n *     .max(10)\r\n *     .min(5)\r\n *     [ .isValid(\"aaaa\") | .assert(\"aaaa\") ]\r\n *\r\n */\r\nvar Assertion = function(fns){\r\n\r\n    fns = Safe.object(fns);\r\n    fns = _.assign({}, fns, ChainableFns);\r\n\r\n    /// Get the current ChainContext of the assertion, in order\r\n    /// to keep the assertion state.\r\n    var context = null;\r\n    _.each(arguments, function(arg){\r\n\r\n        if(arg instanceof ChainContext){\r\n            context = arg;\r\n            return false;\r\n        }\r\n\r\n    });\r\n\r\n    /// Apply Cahin to the same context\r\n    /// this is important because we can invoke \"instaceof Assertion\"\r\n    Chain.apply(this, [fns, AssertionFns, { pipe: false, type: Assertion }, context]);\r\n\r\n};\r\n\r\nmodule.exports = Assertion;\r\n\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,1,1,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,5,null,null,null,null,null,null,null,null,null,null,null,1,null,736,3,null,null,733,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,769,769,null,null,null,769,769,null,3062,765,765,null,null,null,null,null,null,769,null,null,null,1,null,null]},{"name":"src/Common/Assert/Required.js","source":"'use strict';\r\n\r\nvar Type        = require(\"../Type\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * IsRequired\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {*}\r\n *\r\n */\r\nvar Required = function(val){\r\n\r\n    var v = Type.isDefined(val);\r\n\r\n    if(!v) {\r\n        throw new Exception(\"VALIDATION_REQUIRED\");\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Required;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,17,null,17,2,null,null,15,null,null,null,1,null]},{"name":"src/Common/Assert/String.js","source":"'use strict';\r\n\r\nvar Type        = require(\"../Type\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test if value is a string\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {String}\r\n *\r\n */\r\nvar Str = function(val){\r\n\r\n    var v = Type.isString(val);\r\n\r\n    if(!v){\r\n        throw new Exception(\"VALIDATION_TYPE\", { value: Type.of(val), expected: Type.of(\"\") });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Str;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,15,null,15,5,null,null,10,null,null,null,1,null]},{"name":"src/Common/Assert/Object.js","source":"'use strict';\r\n\r\nvar Type        = require(\"../Type\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test if value is an object\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {Object}\r\n *\r\n */\r\nvar Obj = function(val){\r\n\r\n    var v = Type.isObject(val);\r\n\r\n    if(!v){\r\n        throw new Exception(\"VALIDATION_TYPE\", { value: Type.of(val), expected: Type.of({}) });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Obj;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,5,null,5,4,null,null,1,null,null,null,1,null]},{"name":"src/Common/Assert/Array.js","source":"'use strict';\r\n\r\nvar Type        = require(\"../Type\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test if value is an array\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {Array}\r\n *\r\n */\r\nvar Arr = function(val){\r\n\r\n    var v = Type.isArray(val);\r\n\r\n    if(!v){\r\n        throw new Exception(\"VALIDATION_TYPE\", { value: Type.of(val), expected: Type.of([]) });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Arr;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,7,null,7,4,null,null,3,null,null,null,1,null]},{"name":"src/Common/Assert/Number.js","source":"'use strict';\r\n\r\nvar Type        = require(\"../Type\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test if value is a number\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {Number}\r\n *\r\n */\r\nvar Numb = function(val){\r\n\r\n    var v = Type.isNumber(val);\r\n\r\n    if(!v){\r\n        throw new Exception(\"VALIDATION_TYPE\", { value: Type.of(val), expected: Type.of(0) });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Numb;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,8,null,8,5,null,null,3,null,null,null,1,null]},{"name":"src/Common/Assert/Max.js","source":"'use strict';\r\n\r\nvar _           = require(\"lodash\"),\r\n    Type        = require(\"../Type\"),\r\n    Safe        = require(\"../Safe\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n\r\n\r\n/**\r\n *\r\n * Test the max length of any kind of object\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {*}\r\n *\r\n */\r\nvar Max = function(val, max){\r\n\r\n    max = Safe.number(max);\r\n    var length = Safe.length(val);\r\n\r\n    if(length > max){\r\n        throw new Exception(\"VALIDATION_MAX\", { value: max });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Max;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,31,31,null,31,12,null,null,19,null,null,null,1,null]},{"name":"src/Common/Assert/Min.js","source":"'use strict';\r\n\r\nvar _           = require(\"lodash\"),\r\n    Type        = require(\"../Type\"),\r\n    Safe        = require(\"../Safe\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test the min length of any kind of object\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*} val\r\n * @return {*}\r\n *\r\n */\r\nvar Min = function(val, min){\r\n\r\n    min = Safe.number(min);\r\n    var length = Safe.length(val);\r\n\r\n    if(length < min){\r\n        throw new Exception(\"VALIDATION_MIN\", { value: min });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Min;\r\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,23,23,null,23,8,null,null,15,null,null,null,1,null]},{"name":"src/Common/Assert/Regex.js","source":"'use strict';\r\n\r\nvar _           = require(\"lodash\"),\r\n    Type        = require(\"../Type\"),\r\n    Safe        = require(\"../Safe\"),\r\n    Exception   = require(\"../Exception/Exception\");\r\n\r\n/**\r\n *\r\n * Test the regex\r\n *\r\n * @throws {Exception}\r\n *\r\n * @param {*}               val\r\n * @param {String|Regex}    regex\r\n * @return {*}\r\n *\r\n */\r\nvar Regex = function(val, regex){\r\n\r\n    regex = Safe.regexp(regex);\r\n\r\n    var isValid = !!regex.exec(val);\r\n\r\n    if(!isValid){\r\n        throw new Exception(\"REGEXP\", { value: val });\r\n    }\r\n\r\n    return val;\r\n\r\n};\r\n\r\nmodule.exports = Regex;","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,7,null,7,null,7,4,null,null,3,null,null,null,1]},{"name":"src/Common/Assert/InstanceOf.js","source":"'use strict';\n\nvar _           = require(\"lodash\"),\n    Type        = require(\"../Type\"),\n    Exception   = require(\"../Exception/Exception\");\n\n/**\n *\n * Get function name\n * \n * @param  {Function} fn\n * @return {String}\n * \n */\nvar getFnName = function(fun) {\n\n\tvar ret = fun.toString();\n\tret = ret.substr('function '.length);\n\tret = ret.substr(0, ret.indexOf('('));\n\treturn ret;\n\n};\n\n\n/**\n *\n * InstanceOf assertion. \n *\n * @throws {Exception}\n *\n * @param {*} val\n * @param {*} value\n * \n * @return {*}\n *\n */\nvar InstanceOf = function(val, value){\n\n\t/// test with instanceof\n\tif(!Type.instanceOf(val, value)){\n\t\tthrow new Exception(\"VALIDATION_INSTANCEOF\", { value: getFnName(value) });\n\t}\n\n    return val;\n\n};\n\nmodule.exports = InstanceOf;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,2,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,731,2,null,null,729,null,null,null,1,null]},{"name":"src/Common/Schema.js","source":"\"use strict\";\n\nvar Schema = require(\"./CustomSchema\");\n\nmodule.exports = new Schema();","coverage":[null,null,1,null,1]},{"name":"src/Common/CustomSchema.js","source":"'use strict';\n\nvar _                        = require(\"lodash\"),\n    Type                     = require(\"./Type\"),\n    Safe                     = require(\"./Safe\"),\n    Chain                    = require(\"./Chain\"),\n    ChainContext             = require(\"./Chain/ChainContext\"),\n    Types                    = require(\"./Schema/Types\"),\n    SchemaDefinition         = require(\"./Schema/SchemaDefinition\"),\n    SchemaEvaluator          = require(\"./Schema/SchemaEvaluator\");\n\n/**\n *\n * Internal methods wrapper\n *\n * @type {Object}\n *\n */\nvar Internal = {};\n\n/**\n *\n * Wraps the validation functions in order to change the SchemaDefinition context\n * when applied.\n *\n * @param  {String} name\n *\n * @return {ValidationFunction}\n *\n */\nInternal.wrapValidationFunction = function(name){\n\n    /// arguments normalization\n    name = Safe.string(name);\n\n    /// return the wrapped function\n    return function(){\n\n        /// get the actual arguments\n        var args = _.toArray(arguments);\n\n        /// first argument is the eval object, so discard it.\n        args.shift();\n        \n        /// last argument is the chain argument option, so discard it\n        args.pop();\n\n        /// add the value definition to the SchemaDefinition list\n        this.validations.push({\n            name: name,\n            args: args\n        });\n\n    };\n\n};\n\n/**\n *\n * SchemaDefinition compile options.\n *\n * @type {Object}\n * \n */\nInternal.compileOptions = {\n\n    /**\n     *\n     * Prepare the given value for the SchemaDefinition \n     * conversion. If the value is instance of Schema get \n     * its SchemaDefinition value for the conversions\n     *\n     * @param  {*} val\n     * \n     * @return {*}\n     * \n     */\n    prepare: function(val){\n\n        if(Type.instanceOf(val, Types.Schema)){\n            var schemaData = val.serialize();\n            val = new SchemaDefinition(schemaData, { \n                prepare: function(val){\n                    return new SchemaDefinition(val, { compile: false });\n                }\n            });\n        }\n\n        return val;\n\n    }\n\n};\n\n/**\n *\n * The Schema Chainable functions\n *\n * @type {Object}\n *\n */\nvar SchemaChainableFns = {\n\n    any: function(){\n        this.any = true;\n        this.schema = null;\n    },\n\n    strict: function(){\n        this.strict = true;\n    },\n\n    string : function(val, obj){\n        this.schema = \"\";\n        this.required = true;\n        this.any = false;\n    },\n\n    object : function(val, obj){\n        obj = Safe.object(obj, {});\n        this.schema = obj;\n        this.required = true;\n        this.any = false;\n    },\n\n    array : function(val, obj){\n        obj = Safe.array(obj, []);\n        this.schema = obj;\n        this.required = true;\n        this.any = false;\n    },\n\n    function : function(){\n        this.schema = function(){};\n        this.required = true;\n        this.any = false;\n    },\n\n    number : function(){\n        this.schema = 0;\n        this.required = true;\n        this.any = false;\n    },\n\n    boolean : function(){\n        this.schema = Boolean(true);\n        this.required = true;\n        this.any = false;\n    },\n\n    default : function(val, defaultValue){\n        this.default = defaultValue;\n    },\n\n    required : function(){\n        this.required = true;\n    },\n\n    optional : function(){\n        this.required = false;\n    },\n\n    repeatable: function(){\n        this.repeatable = true;\n    }\n\n};\n\n/**\n *\n * The default Custom Chainable Functions\n *\n * @type {Object}\n *\n */\nvar CustomChainableFns = {\n    \"min\": require(\"./Assert/Min\"),\n    \"max\": require(\"./Assert/Max\"),\n    \"regex\": require(\"./Assert/Regex\"),\n};\n\n/**\n *\n * The evaluation functions\n *\n * @type {Object}\n *\n */\nvar EvaluationFns = {\n\n    /**\n     *\n     * Compile the rule and return the facade\n     *\n     * @return {SchemaEvaluator}\n     *\n     */\n    compile: function(result, argument, err){\n\n        /// throw error if there was some in the chain\n        if(err){\n            throw err;\n        }\n\n        return new SchemaEvaluator(this, argument, Internal.compileOptions);\n\n    },\n\n    /**\n     *\n     * Apply the schema rules and return the value.\n     *\n     * @throws {Error} If the value is invalid\n     *\n     * @param  {*}      result\n     * @param  {Object} argument\n     * @return {*}\n     *\n     */\n    value: function(result, argument, err){\n\n        /// throw error if there was some in the chain\n        if(err){\n            throw err;\n        }\n\n        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);\n        return r.value(result);\n\n    },\n\n    /**\n     *\n     * Get the list of errors\n     *\n     * @param  {*}      result\n     * @param  {Object} argument\n     * @return {*}\n     *\n     */\n    errors: function(result, argument, err){\n\n        /// throw error if there was some in the chain\n        if(err){\n            throw err;\n        }\n\n        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);\n        return r.errors(result);\n\n    },\n\n    /**\n     *\n     * Check if the object is valid\n     *\n     * @param  {*}      result\n     * @param  {Object} argument\n     * @return {Boolean}\n     *\n     */\n    isValid: function(result, argument, err){\n\n        /// throw error if there was some in the chain\n        if(err) {\n            throw err;\n        }\n\n        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);\n        return r.isValid(result);\n\n    },\n\n    /**\n     *\n     * Serialize the schema rule\n     *\n     * @return {Object}\n     *\n     */\n    serialize: function(result, argument, err){\n\n        var evaluator = new SchemaEvaluator(this, argument, Internal.compileOptions);\n        return evaluator.serialize();\n\n    },\n\n    /**\n     *\n     * Deserialize from the schema from the given value.\n     *\n     * @return {SchemaEvaluator}\n     *\n     */\n    deserialize: function(value, argument, err){\n\n        var evaluator = new SchemaEvaluator(this, argument, Internal.compileOptions);\n        return evaluator.deserialize(value);\n\n    }\n\n};\n\n/**\n *\n * Schema Chain Facility\n *\n * @param {Object} customFns\n *\n *\n */\nvar Schema = function(customFns){\n\n    customFns = Safe.object(customFns);\n\n    /// get the Schema validation functions. This is an extension point\n    /// for the schema validation.\n    var validationFns = _.extend({}, customFns, CustomChainableFns);\n\n    /// Get the current ChainContext of the assertion, in order\n    /// to keep the assertion state.\n    var chainContext = null;\n    _.each(arguments, function(arg){\n        if(arg instanceof ChainContext){\n            chainContext = arg;\n            return false;\n        }\n    });\n\n    /// if there's no chain context initialize the default functions by\n    /// wrapping them in a compatible API\n    if(!chainContext){\n\n        /// assign the default validation functions\n        var schemaFns = _.extend({}, SchemaChainableFns);\n\n        /// transform the custom validation functions, to use the Schema\n        /// runner\n        var wrappedFns = _.extend({}, CustomChainableFns, customFns);\n        _.each(wrappedFns, function(fn, name){\n            wrappedFns[name] = Internal.wrapValidationFunction(name);\n        });\n\n        /// give precedence to schemaFns\n        customFns = _.extend(wrappedFns, schemaFns);\n\n    }\n\n    /// the chain options\n    var chainOptions = {\n\n        /// do not pipe the chainable fns objects\n        pipe: false,\n\n        /// Use the Schema type for each chaninable return statement\n        type: Schema,\n\n        /// set the scope for each chainable function execution.\n        scope: function() {\n            return new SchemaDefinition(null, { compile: false });\n        },\n\n        /// Evaluation argument. This argument will be present in every\n        /// evalFn invocation without interfere with the chain scope.\n        argument: validationFns\n\n    };\n\n    /// Inherit from Chains\n    Chain.apply(this, [ customFns, EvaluationFns, chainOptions, chainContext ]);\n\n    return new Types.Schema(this);\n\n};\n\nmodule.exports = Schema;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,87,null,null,87,null,null,22,null,null,22,null,null,22,null,null,22,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,99,16,16,null,20,null,null,null,null,99,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,13,13,null,null,null,2,null,null,null,14,14,14,null,null,null,12,12,12,12,null,null,null,8,8,8,8,null,null,null,2,2,2,null,null,null,4,4,4,null,null,null,6,6,6,null,null,null,7,null,null,null,13,null,null,null,20,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,5,0,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,25,0,null,null,25,25,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,0,null,null,5,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,null,3,3,null,null,null,null,null,null,null,null,null,null,null,null,21,21,null,null,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,115,null,null,null,115,null,null,null,115,115,344,86,86,null,null,null,null,null,115,null,null,29,null,null,null,29,29,87,null,null,null,29,null,null,null,null,115,null,null,null,null,null,null,null,null,null,108,null,null,null,null,null,null,null,null,null,115,null,115,null,null,null,1,null]},{"name":"src/Common/Schema/Types.js","source":"\"use strict\";\n\nvar _ = require(\"lodash\");\n\n/**\n *\n * List of internal Schema package Types.\n *\n * This is useful while using the revealing module pattern and wanting\n * at the same time to use strong type checking.\n *\n */\nvar Types = {\n\n    /**\n     *\n     * @class\n     * Schema\n     *\n     */\n    Schema: function Schema(options){ _.extend(this, options); },\n\n    /**\n     *\n     * @class\n     * Schema\n     *\n     */\n    SchemaDefinition: function SchemaDefinition(options){ _.extend(this, options); },\n\n    /**\n     *\n     * @class\n     * SchemaEvaluator\n     *\n     */\n    SchemaEvaluator: function SchemaEvaluator(options){ _.extend(this, options); },\n\n    /**\n     *\n     * @class\n     * SchemaResult\n     *\n     */\n    SchemaResult: function SchemaResult(options){ _.extend(this, options); },\n\n    /**\n     *\n     * @class\n     * SchemaResultNode\n     *\n     */\n    SchemaResultNode: function SchemaResultNode(options){ _.extend(this, options); }\n\n};\n\nmodule.exports = Types;","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,115,null,null,null,null,null,null,null,385,null,null,null,null,null,null,null,65,null,null,null,null,null,null,null,172,null,null,null,null,null,null,null,178,null,null,null,1]},{"name":"src/Common/Schema/SchemaDefinition.js","source":"\"use strict\";\n\nvar _               = require(\"lodash\"),\n    Types           = require(\"./Types\"),\n    Type            = require(\"../Type\"),\n    Safe            = require(\"../Safe\"),\n    Assert          = require(\"../Assert\");\n\n/**\n *\n * Default conversion between the value and a SchemaDefinition.\n * This converts a primitive value to a SchemaDefinition with defaults\n * value.\n *\n * @type {Object}\n *\n */\nvar Defaults = {\n\n    array: function(value){\n\n        if(!Type.isArray(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: value,\n            required: true\n        });\n\n        return value;\n\n    },\n\n    object: function(value){\n\n        if(!Type.isObject(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: value,\n            required: true\n        });\n\n        return value;\n\n    },\n\n    string: function(value){\n\n        if(!Type.isString(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: \"\",\n            required: true\n        });\n\n        return value;\n\n    },\n\n    number: function(value){\n\n        if(!Type.isNumber(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: 0,\n            required: true\n        });\n\n        return value;\n\n    },\n\n    boolean: function(value){\n\n        if(!Type.isBoolean(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: Boolean(value),\n            required: true\n        });\n\n        return value;\n\n    },\n\n    function: function(value){\n\n        if(!Type.isFunction(value)){\n            return;\n        }\n\n        // no default value and its required!\n        value = new SchemaDefinition({\n            schema: function(){},\n            required: true\n        });\n\n        return value;\n\n    },\n\n};\n\n/**\n *\n * Normalize the schema value in order to avoid storing unnecessary \n * data and keep the values consistent across usages.\n * \n * @param  {String} value\n * @return {*}\n * \n */\nvar normalizeSchemaValue = function(value){\n\n    value = Safe.value(value);\n\n    if(Type.isString(value)){\n        return \"\";\n    }\n\n    if(Type.isNumber(value)){\n        return 0;\n    }\n\n    if(Type.isBoolean(value)){\n        return true;\n    }\n\n    return value;\n\n};\n\n/**\n *\n * Compile the given schema definition or compatible \n * structure.\n *\n * @param {*}       schema\n * @param {Object}  options\n *\n * @return {SchemaDefinition}\n *\n */\nvar compile = function(schema, options){\n\n    /// extensibility point - prepare the value before the \n    /// compilation\n    schema = options.prepare(schema);\n\n    /// apply the defaults and create the SchemaDefinition if an object \n    /// has been provided\n    if(!Type.instanceOf(schema, Types.SchemaDefinition)){\n        schema = Defaults.object(schema) || Defaults.array(schema) ||\n                Defaults.string(schema) || Defaults.number(schema) ||\n                Defaults.boolean(schema) || Defaults.function(schema);\n    }\n\n    /// convert the schema\n    var isArray  = Type.isArray(schema.schema),\n        isObject = Type.isObject(schema.schema);\n\n    /// iterate over the structure in order to compile the schema\n    if(isArray || isObject){\n\n        _.each(schema.schema, function(val, index){\n            var innerSchema = compile(val, options);\n            schema.schema[index] = innerSchema;\n        });\n\n    }\n\n    return schema;\n\n};\n\n/**\n *\n * A SchemaDefinition class. Contains all the rules that should be applied when\n * evaluating it against a value.\n *\n * @param {Object} options\n *\n */\nvar SchemaDefinition = function(options){\n\n    options = Safe.object(options);\n\n    /**\n     *\n     * SchemaDefinition module API\n     * \n     * @type {Object}\n     * \n     */\n    var self = {\n\n        /**\n         *\n         * The type of schema\n         *\n         * @type {SchemaDefinition}\n         *\n         */\n        schema: normalizeSchemaValue(options.schema),\n\n        /**\n         *\n         * Flag that enables strict convertion.\n         *\n         * @type {Boolean}\n         *\n         */\n        strict: Safe.boolean(options.strict, false),\n\n        /**\n         *\n         * Any flag. This means that any value is accepted.\n         *\n         * @type {Boolean}\n         *\n         */\n        any: Safe.boolean(options.any, false),\n\n        /**\n         *\n         * The default value of the schema\n         *\n         * @type {*}\n         */\n        default: options.default,\n\n        /**\n         *\n         * IsRequired flag\n         *\n         * @type {Boolean}\n         *\n         */\n        required: Safe.boolean(options.required, true),\n\n        /**\n         *\n         * Repeatable flag. This means, e.g. if the schema is an array the inner schema can\n         * be repeatable by elements.\n         *\n         * @type {Boolean}\n         */\n        repeatable: Safe.boolean(options.repeatable),\n\n        /**\n         *\n         * The validation functions to apply to this Schema node. Each validation function is\n         * represented by: { name: 'fn', args: '' }\n         *\n         * @type {Array}\n         *\n         */\n        validations: Safe.array(options.validations),\n\n    };\n\n    return new Types.SchemaDefinition(self);\n\n};\n\n/**\n *\n * @class\n * A SchemaDefinition compiled class. This represents a fully compiled \n * instance of all inner structures that represents a Schema.\n *\n * A full iteration over the entire schema structure will be performed.\n * \n * @param {Object} options  The SchemaDefinition data \n * @param {Object} cOptions The compilation options\n *\n */\nvar CompiledSchemaDefinition = function(options, cOptions){\n\n    /// normalize the given compilation options\n    cOptions = Safe.object(cOptions);\n    cOptions.compile = Safe.boolean(cOptions.compile, true);\n    cOptions.prepare = Safe.function(cOptions.prepare, function(v){ return v; });\n\n    /* jshint -W064 */\n    var schema = SchemaDefinition(options);\n\n    /// traverse the schema structure compiling its inner elements\n    if(cOptions.compile){\n        return compile(schema, cOptions);    \n    }\n    \n    return schema;\n\n};\n\n/// include type checking Mixin\nrequire(\"./Mixins/SchemaType\")\n    .call(Types.SchemaDefinition.prototype);\n\n/// include clone Mixin functionality\nrequire(\"./Mixins/SchemaClone\")\n    .apply(Types.SchemaDefinition.prototype, [ CompiledSchemaDefinition ]);\n\n/// include execution Mixin functionality\nrequire(\"./Mixins/SchemaExecution\")\n    .call(Types.SchemaDefinition.prototype);\n\n/// include serialization functionality\nrequire(\"./Mixins/SchemaSerialization\")\n    .call(Types.SchemaDefinition.prototype);\n\nmodule.exports = CompiledSchemaDefinition;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,54,54,null,null,null,0,null,null,null,null,0,null,null,null,null,null,55,54,null,null,null,1,null,null,null,null,1,null,null,null,null,null,54,47,null,null,null,7,null,null,null,null,7,null,null,null,null,null,47,0,null,null,null,47,null,null,null,null,47,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,385,null,385,63,null,null,322,72,null,null,250,7,null,null,243,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,379,null,null,null,379,55,null,null,null,null,null,379,null,null,null,379,null,108,185,185,null,null,null,null,379,null,null,null,null,null,null,null,null,null,null,null,1,null,385,null,null,null,null,null,null,null,null,385,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,385,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,330,330,330,null,null,330,null,null,330,194,null,null,136,null,null,null,null,1,null,null,null,1,null,null,null,1,null,null,null,1,null,null,1,null]},{"name":"src/Common/Schema/Mixins/SchemaType.js","source":"\"use strict\";\n\nvar Type = require(\"../../Type\");\n\n/**\n *\n * Schema type methods\n *\n * @scope {SchemaDefinition}\n * \n * @type {Object}\n *\n */\nvar SchemaType = function(){\n\n    /**\n     *\n     * Checks if the schema is an array\n     * \n     * @return {Boolean}\n     * \n     */\n    this.isArray = function(){\n        return Type.isArray(this.schema);\n    };\n\n    /**\n     *\n     * Checks if the schema is an object\n     * \n     * @return {Boolean}\n     * \n     */\n    this.isObject = function(){\n        return Type.isObject(this.schema);\n    };\n\n};\n\nmodule.exports = SchemaType;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,180,null,null,null,null,null,null,null,null,null,1,239,null,null,null,null,1,null]},{"name":"src/Common/Schema/Mixins/SchemaClone.js","source":"\"use strict\";\n\n\nvar _                 = require(\"lodash\"),\n    Assert            = require(\"../../Assert\"),\n    Types             = require(\"../Types\");\n\n/**\n *\n * Schema clone methods\n *\n * @type {Object}\n *\n */\nvar SchemaClone = function(Class){\n\n    /**\n     *\n     * Clone the current schema. If `options` is defined it will override the\n     * current instance data of the new SchemaDefinition.\n     * \n     * @param  {Object} options\n     * @return {Class}\n     * \n     */\n    this.clone = function(options){\n\n        Assert.instanceOf(Types.SchemaDefinition)\n            .assert(this);\n\n        var instance = new Class(\n            _.extend({}, this, options));\n\n        return instance;\n\n    };\n\n};\n\nmodule.exports = SchemaClone;\n\n","coverage":[null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,36,null,null,36,null,null,36,null,null,null,null,null,1,null,null]},{"name":"src/Common/Schema/Mixins/SchemaExecution.js","source":"\"use strict\";\n\nvar _                       = require(\"lodash\"),\n    Safe                    = require(\"../../Safe\"),\n    Type                    = require(\"../../Type\"),\n    Assert                  = require(\"../../Assert\"),\n    Exception               = require(\"../../Exception/Exception\"),\n    Types                   = require(\"../Types\"),\n    SchemaResult            = require(\"../SchemaResult\"),\n    SchemaExecutionHelper   = require(\"./SchemaExecutionHelper\");\n\n/**\n *\n * Iterate over the complex value\n *\n * @param  {SchemaDefinition} schema\n * @param  {*} value\n * \n * @return {SchemaResult}\n *\n */\nvar execute = function(schema, value, validationFns){\n\n    /* jshint -W064 */\n    var result = SchemaResult(schema, value);\n\n    /// get the value from the schema\n    try {\n        value = result.value = SchemaExecutionHelper.prepareValue(schema, value, validationFns);\n    }\n    catch(e){\n        result.errors.push(e);    \n        return result;\n    }\n\n    /// if value is null there's no need to iterate\n    /* jshint -W041 */\n    if(value == null){\n        return result;\n    }\n\n    /// if is expecting any value return it straight away\n    if(schema.any){\n        return result;\n    }\n\n    /// if is not a complex value return the value\n    if(!schema.isArray() && !schema.isObject()){\n        return result;\n    }\n\n    /// prepare the schema for execution against the value. This will expand \n    /// the schema to match the value\n    try {\n        schema = SchemaExecutionHelper.prepareSchema(schema, value, validationFns);\n    }\n    catch(e){\n        result.errors.push(e);    \n        return result;\n    }\n\n    /// reset the result value before iterating\n    result = SchemaResult(schema, schema.isObject() ? {} : []);\n    \n    /// recursion over the inner values of the schema\n    _.each(schema.schema, function(schema, key){\n\n        /// recursive execute the schema\n        var innerResult = schema.execute(value[key], validationFns);\n\n        /// add result to errors\n        if(innerResult.errors.length){\n            result.errors.push(innerResult.errors);\n            return;\n        }\n\n        /// if is an object and value is not required ignore!\n        if(result.schema.isObject() && innerResult.value == null && !schema.required){\n            return;\n        }\n\n        /// set the value\n        result.set(innerResult.value, {\n            index: key\n        });\n\n    });\n\n    return result;\n\n};\n\n/**\n *\n * Schema execution methods.\n *\n * @type {Object}\n *\n */\nvar Execution = function(){\n\n    /**\n     *\n     * Execute Schema against the value. This will perform a top-down recursion on\n     * the given structure.\n     *\n     * @param {SchemaDefinition} schema\n     * @param {*} value\n     * @param {Object} options\n     *\n     * @return {SchemaResult}\n     *\n     */\n    this.execute = function(value, validationFns){\n\n        /// validate and normalize arguments\n        Assert.instanceOf(Types.SchemaDefinition)\n            .assert(this);\n\n        /// if it has no errors iterate over the object\n        var result = execute(this, value, validationFns);\n        \n        /// if there's error try to recover by applying the default value\n        if(result.errors.length){\n\n            /// try to fallback to the default value if it can\n            /* jshint -W041 */\n            if(this.default != null){\n                \n                var dresult = execute(this, this.default, validationFns);\n                \n                /// if default value is valid use it, otherwise use the given \n                /// value\n                if(!dresult.errors.length){\n                    result = dresult;\n                }\n\n            }\n\n        }\n\n        return result;\n\n    };\n\n};\n\nmodule.exports = Execution;\n\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,141,null,null,141,141,null,null,24,24,null,null,null,null,117,10,null,null,null,107,12,null,null,null,95,60,null,null,null,null,35,35,null,null,4,4,null,null,null,31,null,null,31,null,null,64,null,null,64,4,4,null,null,null,60,2,null,null,null,58,null,null,null,null,null,31,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,134,null,null,null,134,null,null,134,null,null,null,32,null,7,null,null,null,7,7,null,null,null,null,null,null,134,null,null,null,null,null,1,null,null]},{"name":"src/Common/Schema/SchemaResult.js","source":"\"use strict\";\n\nvar Safe                = require(\"../Safe\"),\n    Type                = require(\"../Type\"),\n    Assert              = require(\"../Assert\"),\n    ExceptionList       = require(\"../Exception/ExceptionList\"),\n    Types               = require(\"./Types\"),\n    SchemaResultNode    = require(\"./SchemaResultNode\");\n\n/**\n *\n * @class\n * Stores the result of a schema evaluation. It will keep reference to \n * the global structure and the evaluation tree as well.\n *\n * @param {*} schema\n * @param {*} value\n *\n *\n */\nvar SchemaResult = function(schema, value){\n\n    /// validate schema\n    Assert.instanceOf(Types.SchemaDefinition)\n        .assert(schema);\n    \n    value = Safe.value(value);\n\n    /**\n     *\n     * Top-down global error tracking\n     * \n     * @type {ExceptionList}\n     * \n     */\n    var errors = new ExceptionList();\n\n    /**\n     *\n     * Hierarchical evaluation reference node\n     * \n     * @type {SchemaResultNode}\n     * \n     */\n    var node = new SchemaResultNode(schema);\n    \n    /**\n     *\n     * SchemaResult API\n     * \n     * @type {Object}\n     * \n     */\n    var self = {\n\n        /// TODO\n        schema: schema,\n        value: value,\n        errors: errors,\n\n        /**\n         *\n         * Set the value of the given index.\n         * \n         * @param {*} value\n         * @param {Object} options\n         *\n         */\n        set: function(value, options) {\n\n            options = Safe.object(options);\n            options.index   = Safe.value(options.index, null);\n            options.errors  = Safe.instanceOf(options.errors, ExceptionList);\n\n            /// just set the value if is an array or an object\n            if(!(schema.isArray() || schema.isObject())){\n                return;\n            }\n\n            this.value[options.index] = value;\n\n        }\n\n    };\n\n    /// expose module as 'Typed' SchemaResult instance\n    return new Types.SchemaResult(self);\n\n};\n\nmodule.exports = SchemaResult;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,172,null,null,172,null,null,null,null,null,null,null,null,172,null,null,null,null,null,null,null,null,172,null,null,null,null,null,null,null,null,172,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,58,58,58,null,null,58,0,null,null,58,null,null,null,null,null,null,172,null,null,null,1,null]},{"name":"src/Common/Schema/SchemaResultNode.js","source":"\"use strict\";\n\nvar _                   = require(\"lodash\"),\n    Type                = require(\"../Type\"),\n    Safe                = require(\"../Safe\"),\n    Assert              = require(\"../Assert\"),\n    ExceptionList       = require(\"../Exception/ExceptionList\"),\n    Types               = require(\"./Types\");\n\n/**\n *\n * SchemaResultNode stores a Schema evaluation result of a given hierarchical item.\n *\n * - Each inner value of a complex object must be an instance of SchemaResultNode.\n * - Each error of a SchemaResultNode is associated with the value itself and not\n * his inner values.\n *\n *\n * @class\n *\n * @param {SchemaDefinition} schema\n *\n */\nvar SchemaResultNode = function(schema) {\n\n    Assert.instanceOf(Types.SchemaDefinition)\n        .assert(schema);\n\n    /**\n     *\n     * Is the value an array flag\n     *\n     * @type {Boolean}\n     *\n     */\n    var isArray = Type.isArray(schema.schema);\n\n    /**\n     *\n     * Is the value an array flag\n     *\n     * @type {Boolean}\n     *\n     */\n    var isObject = Type.isObject(schema.schema);\n\n    /**\n     *\n     * The schema associated value. This value will hold a\n     * SchemaResultNode.\n     *\n     * @type {*}\n     *\n     */\n    var value = null;\n\n    /// initialize the value with the expected type\n    if(isArray){\n        value = [];\n    }\n    else if(isObject){\n        value = {};\n    }\n\n    /**\n     *\n     * The list of errors associated with the Schema\n     * conversion.\n     *\n     * @type {ExceptionList}\n     *\n     */\n    var errors = new ExceptionList();\n\n    /**\n     *\n     * Module API\n     *\n     * @type {Object}\n     *\n     */\n    var self = {\n\n        /**\n         *\n         * The schema value being evaluated.\n         * Returns a cloned copy of the value is returned.\n         *\n         * @return {*}\n         *\n         */\n        getValue: function(){\n            return _.clone(value);\n        },\n\n        /**\n         *\n         * Set the SchemaResultNode for the given value.\n         *\n         * @throws {Error} If val is not an instance of SchemaResultNode\n         * \n         * @param {SchemaResultNode} val\n         * @param {*} index\n         *\n         * @return {*} The added SchemaResultNode\n         *\n         */\n        setValue: function(val, index){\n\n            /// validate setValue arguments\n            var isIndexValid     = Type.isNumber(index) || Type.isString(index),\n                isSchemaResultNode = val instanceof Types.SchemaResultNode;\n\n            /// if current schema is expecting an index and the given index is not valid or\n            /// not a SchemaResultNode, throw Error\n            if(isObject && (!isIndexValid || !isSchemaResultNode)){\n                throw new Error(\"Invalid operation!\");\n            }\n\n            /// if the value is an array the value should be SchemaResultNode and\n            /// no index should be specified\n            if(isArray && (!isSchemaResultNode || isIndexValid)){\n                throw new Error(\"Invalid operation!\");\n            }\n\n            /// if the value is a primitive value the value shouldn't be\n            /// a SchemaResultNode and no index should be specified\n            if(!isObject && !isArray && (isSchemaResultNode || isIndexValid)){\n                throw new Error(\"Invalid operation!\");\n            }\n\n            /// set the index\n            if(isObject){\n                value[index] = val;\n            }\n            else if(isArray){\n                value.push(val);\n            }\n            else {\n                value = val;\n            }\n\n            return val;\n        },\n\n        /**\n         *\n         * Get the error list\n         *\n         * @return {ExceptionList}\n         *\n         */\n        getErrors: function(){\n            return errors;\n        },\n\n        /**\n         *\n         * Add errors to the\n         *\n         * @param {Error} error\n         *\n         */\n        addErrors: function(error){\n            errors.push(error);\n        },\n\n        /**\n         *\n         * Pretty print the current schema value and its errors\n         *\n         * @return {String}\n         *\n         */\n        toString: function(){\n\n        }\n\n    };\n\n    return new Types.SchemaResultNode(self);\n\n};\n\nmodule.exports = SchemaResultNode;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,179,null,null,null,null,null,null,null,null,null,178,null,null,null,null,null,null,null,null,178,null,null,null,null,null,null,null,null,null,178,null,null,178,32,null,146,44,null,null,null,null,null,null,null,null,null,null,178,null,null,null,null,null,null,null,null,178,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,null,null,null,9,2,null,null,null,null,7,3,null,null,null,null,4,1,null,null,null,3,1,null,2,1,null,null,1,null,null,3,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,178,null,null,null,1,null]},{"name":"src/Common/Schema/Mixins/SchemaExecutionHelper.js","source":"\"use strict\";\n\nvar _                   = require(\"lodash\"),\n    Safe                = require(\"../../Safe\"),\n    Type                = require(\"../../Type\"),\n    Assert              = require(\"../../Assert\"),\n    ExceptionList       = require(\"../../Exception/ExceptionList\"),\n    Exception           = require(\"../../Exception/Exception\"),\n    Types               = require(\"../Types\");\n    \n\n/**\n *\n * Prepares and validates the SchemaDefinition for the given \n * value.\n *\n * @throw {ExceptionList}\n *\n * @param  {SchemaDefinition} schema\n * @param  {*}      value\n * @param  {Object} validationFns\n *\n * @return {SchemaDefinition}\n *\n */\nvar prepareSchema = function(schema, value, validationFns){\n\n    value           = Safe.value(value);\n    validationFns   = Safe.object(validationFns);\n\n    /* jshint -W064 */\n    var errors = new ExceptionList();\n\n    /// If not defined and its required throw\n    /* jshint -W041 */\n    if(schema.required && value == null){\n        errors.push(\n            new Exception(\"VALIDATION_REQUIRED\"));\n    }\n    /* jshint -W041 */\n    else if(!schema.required && value == null){\n        /// continue (optional parameter)\n    }\n    /// check for compatibility of types if any flag is not used\n    else if(!schema.any && Type.of(schema.schema) !== Type.of(value)){\n        errors.push(\n            new Exception(\"VALIDATION_TYPE\", { expected: Type.of(schema.schema), value: Type.of(value) }));\n    }\n\n    /// if there's error throw them\n    if(errors.length){\n        throw errors;\n    }\n\n    return schema;\n\n};\n\n/**\n *\n * Prepares and validates the SchemaDefinition for the given \n * object.\n *\n * @throws {ExceptionList} If a validation function occurs\n * \n * @param  {SchemaDefinition} schema\n * @param  {Object} value\n *\n * @return {SchemaDefinition}\n *\n */\nvar prepareObject = function(schema, value){\n\n    value = Safe.object(value);\n\n    /* jshint -W064 */\n    var errors      = new ExceptionList(),\n        result      = {},\n        valueKeys   = _.keys(value);\n\n    _.each(\n        schema.schema,\n        function(schemaValue, key){\n\n            var isRegExp = Type.isRegExpStr(key),\n                keys     = [];\n\n            /// key is not a regexp string\n            if(!isRegExp){\n                keys = [ key ];\n            }\n            else {\n                /// key is a regexp string\n                var regexp  = Safe.regexp(key);\n                keys = _.filter(\n                    valueKeys,\n                    function(key){\n\n                        /// if there's a definition of the schema don't include it\n                        if(schema.schema[key] !== undefined){\n                            return false;\n                        }\n\n                        /// test if the regex match\n                        return !!regexp.exec(key);\n\n                    });\n            }\n\n            _.each(keys, function(val) {\n                result[val] = schemaValue;\n            });\n\n        });\n\n    return schema.clone({\n        schema: result\n    });\n\n};\n\n/**\n *\n * Prepares and validates the SchemaDefinition for the given \n * array.\n *\n * @throws {ExceptionList} If a validation error occurs\n *\n * @param  {SchemaDefinition} schema\n * @param  {Array} value\n *\n * @return {SchemaDefinition}\n *\n */\nvar prepareArray = function(schema, value){\n\n    value = Safe.array(value);\n\n    /* jshint -W064 */\n    var errors  = new ExceptionList(),\n        result  = [],\n        index   = 0;\n\n    if( !schema.repeatable && schema.schema.length != value.length ){\n        errors.push(\n            new Exception(\"VALIDATION_INVALID_LIST_LENGTH\", { value: value.length, expected: schema.schema.length }));\n    }\n\n    if(schema.repeatable){\n\n        var isRepeatable = true;\n\n        /// if the value contains elements check if its divisible by \n        /// the repeat count\n        if(value.length > 0 && value.length != schema.schema.length){\n            isRepeatable = value.length % schema.schema.length === 0;\n        }\n        /// otherwise is only repeatable if the array contains no \n        /// element\n        else {\n            isRepeatable = (value.length === schema.schema.length) && (value.length === 0);\n        }\n\n        if(!isRepeatable){\n            errors.push(\n                new Exception(\"VALIDATION_INVALID_LIST_LENGTH_MULTIPLE_OF\", { value: value.length, expected: schema.schema.length }));    \n        }\n        \n    }\n\n    /// if errors exist throw them\n    if(errors.length){\n        throw errors;\n    }\n\n    /// create the result array\n    for(var i=0; i<value.length; i++){\n\n        if(schema.repeatable && index >= schema.schema.length){\n            index = 0;\n        }\n\n        result.push(schema.schema[index++]);\n\n    }\n\n    return schema.clone({\n        schema: result\n    });\n\n};\n\n/**\n *\n * Schema Conversion conversion methods\n * \n * @type {Object}\n * \n */\nvar SchemaExecutionHelper = {\n\n    /**\n     *\n     * Get the value according to the given schema, by applying \n     * default values, coercing values, ...\n     *\n     * @throws {ExceptionList} If the validation fails\n     * \n     * @param  {SchemaDefinition} schema\n     * @param  {*} value\n     *\n     * @return {*}\n     *\n     */\n    prepareValue: function(schema, value, validationFns){\n\n        /// validate and normalize arguments\n        Assert.instanceOf(Types.SchemaDefinition)\n            .assert(schema);\n\n        value = Safe.value(value);\n\n        /// initalize the list of errors\n        var errors = new ExceptionList();\n\n        /// if not strict tries to normalize\n        /// the value (e.g. a number can be on string representation )\n        if(!schema.strict){\n            value = Safe.coerce(value, schema.schema);\n        }\n\n        /// if the value is required and it has no value, throw error\n        /* jshint -W041 */\n        if(schema.required && value == null){\n            errors.push(\n                new Exception(\"VALIDATION_REQUIRED\"));\n        }\n        else if(!schema.required && value == null){\n            /// ignore, and not fallback on the other else's\n        }\n        /// if a value exists find out if types are compatible\n        else if(!schema.any && Type.of(schema.schema) !== Type.of(value)){\n            errors.push(\n                new Exception(\"VALIDATION_TYPE\", { expected: Type.of(schema.schema), value: Type.of(value) }));\n        }\n\n        /// always run if value is required or value is specified.\n        if(schema.required || value !=null){\n\n            _.each(\n                schema.validations,\n                function(v){\n\n                    v = Safe.object(v);\n\n                    var fn      = Safe.function(validationFns[v.name]),\n                        args    = Safe.array(v.args);\n\n                    try{\n                        fn.apply({}, [value].concat(args));\n                    }catch(e){\n                        var error = new Exception(e.message);\n                        errors.push(error);\n                    }\n\n            });\n\n        }\n\n        /// check if any error was detected\n        if(errors.length){\n            throw errors;\n        }\n\n        return value;\n\n    },\n\n    /**\n     *\n     * Gets the schema for the given value. If the schema is an object it \n     * will expand its keys regular expressions. If the schema is an array \n     * it will apply its properties to the given value.\n     *\n     * @throws {ExceptionList} If a validation error occurs\n     *\n     * @param  {SchemaDefinition} schema\n     * @param  {*}      value\n     * @param  {Object} validationFns\n     * \n     * @return {SchemaDefinition}\n     * \n     */\n    prepareSchema: function(schema, value, validationFns){\n\n        Assert.instanceOf(Types.SchemaDefinition)\n            .assert(schema);\n\n        /// prepare the schema\n        schema = prepareSchema(schema, value, validationFns);\n\n        /// prepare the object\n        if(schema.isObject()){\n            return prepareObject(schema, value);\n        }\n        /// prepare the array\n        else if(schema.isArray()){\n            return prepareArray(schema, value);\n        }\n\n        return schema;\n\n    }\n\n};\n\nmodule.exports = SchemaExecutionHelper;\n","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,50,50,null,null,50,null,null,null,50,1,null,null,null,49,null,null,null,48,1,null,null,null,null,50,2,null,null,48,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,21,null,null,21,null,null,null,21,null,null,null,28,null,null,null,28,24,null,null,null,4,4,null,null,null,null,14,4,null,null,null,10,null,null,null,null,28,30,null,null,null,null,21,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,23,null,null,23,null,null,null,23,3,null,null,null,23,null,12,null,null,null,12,10,null,null,null,null,2,null,null,12,5,null,null,null,null,null,null,23,8,null,null,null,15,null,47,18,null,null,47,null,null,null,15,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,158,null,null,158,null,null,158,null,null,null,158,155,null,null,null,null,158,9,null,null,149,null,null,null,137,10,null,null,null,null,158,null,146,null,null,null,31,null,31,null,null,31,31,null,12,12,null,null,null,null,null,null,null,158,29,null,null,129,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,50,null,null,null,50,null,null,48,21,null,null,27,23,null,null,4,null,null,null,null,null,1,null]},{"name":"src/Common/Schema/Mixins/SchemaSerialization.js","source":"\"use strict\";\n\nvar _       = require(\"lodash\"),\n    Safe    = require(\"../../Safe\");\n\n/**\n *\n * Serialization methods for SchemaDefinition.\n *\n * @scope {SchemaDefinition}\n * \n * @type {Object}\n *\n */\nvar Serialization = function(){\n\n    /**\n     *\n     * Serializes the schema definition.\n     *\n     * @return {Object}\n     *\n     */\n    this.serialize = function(){\n        return _.cloneDeep(this);\n    };\n\n    /**\n     *\n     * Deserializes the object into a SchemaDefinition\n     *\n     * @return {SchemaDefinition}\n     *\n     */\n    this.deserialize = function(value){\n        return new this.constructor(value);\n    };\n\n};\n\nmodule.exports = Serialization;","coverage":[null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,21,null,null,null,null,null,null,null,null,null,1,0,null,null,null,null,1]},{"name":"src/Common/Schema/SchemaEvaluator.js","source":"\"use strict\";\n\n\nvar _                       = require(\"lodash\"),\n    Type                    = require(\"../Type\"),\n    Safe                    = require(\"../Safe\"),\n    ExceptionList           = require(\"../Exception/ExceptionList\"),\n    Types                   = require(\"./Types\"),\n    SchemaDefinition        = require(\"./SchemaDefinition\");\n\n/**\n *\n * @class\n * The schema evaluator facade. This will serve as interface to the Schema\n * execution.\n *\n * @param {*}       schema\n * @param {Object}  validationFns\n * @param {Object}  cOptions        The SchemaDefinition compilation options\n *\n */\nvar SchemaEvaluator = function(schema, validationFns, cOptions){\n\n    /* jshint -W064 */\n    /**\n     *\n     * The compiled schema\n     *\n     * @type {SchemaDefinition}\n     * \n     */\n    schema = SchemaDefinition(schema, cOptions);\n\n    /**\n     *\n     * The custom validation functions\n     *\n     * @type {Object}\n     *\n     */\n    validationFns = Safe.object(validationFns);\n\n    /**\n     *\n     * SchemaEvaluator external API\n     *\n     * @type {Object}\n     *\n     */\n    var self = {\n\n        /**\n         *\n         * Evaluate and get the errors\n         *\n         * @param  {*}      value\n         * @param  {Object} validationFns\n         *\n         * @return {[Error]}\n         *\n         */\n        errors: function(value){\n\n            var result = schema.execute(value, validationFns);\n            return result.errors;\n\n        },\n\n        /**\n         *\n         * Tests if the schema is valid against the given value.\n         *\n         * @param  {*}  value\n         *\n         * @return {Boolean}\n         *\n         */\n        isValid: function(value){\n\n            var result = schema.execute(value, validationFns);\n            return result.errors.length === 0;\n\n        },\n\n        /**\n         *\n         * Gets the value after applying the schema.\n         *\n         * @throws {ExceptionList}\n         *\n         * @param  {*} value\n         *\n         * @return {*}\n         *\n         */\n        value: function(value){\n\n            var result = schema.execute(value, validationFns);\n\n            if(result.errors.length){\n                throw result.errors;\n            }\n\n            return result.value;\n\n        },\n\n        /**\n         *\n         * Serialize the current Schema\n         *\n         * @return {Object}\n         *\n         */\n        serialize: function(){\n\n            return schema.serialize();\n\n        },\n\n        /**\n         *\n         * Deserialize the value. Returns a new instance of SchemaEvaluator.\n         *\n         * @return {SchemaEvaluator}\n         *\n         */\n        deserialize: function(value){\n\n            /// use a prepare option that builds the SchemaDefinition to \n            /// avoid fallback on the Default object builder\n            var cOptions = {\n                prepare: function(val){\n                    \n                    /// make sure that that the return value is a SchemaDefinition\n                    /// NOTE: don't compile the inner structures because the SchemaEvaluator will \n                    /// do it\n                    if(!Type.instanceOf(val, Types.SchemaDefinition)){\n                        return SchemaDefinition(val, { compile: false });    \n                    }\n\n                    return val;\n                    \n                }\n            };\n\n            return new SchemaEvaluator(value, validationFns, cOptions);\n\n        }\n\n    };\n\n    return new Types.SchemaEvaluator(self);\n\n};\n\n\nmodule.exports = SchemaEvaluator;\n","coverage":[null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,65,null,null,null,null,null,null,null,null,65,null,null,null,null,null,null,null,null,65,null,null,null,null,null,null,null,null,null,null,null,null,null,5,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,6,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,43,null,43,12,null,null,31,null,null,null,null,null,null,null,null,null,null,null,null,21,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,11,8,null,null,3,null,null,null,null,3,null,null,null,null,null,65,null,null,null,null,1,null]},{"name":".readme/includes/Arr/ArrExample.js","source":"\nvar Arr = Divhide.Arr;\n\nvar value = Arr.index([1 ,2, 3], 0);\nexpect(value).toBe(1);\n\nvar value = Arr.index([1 ,2, 3], 10);\nexpect(value).toBeNull();\n\nvar first = Arr.first([1 ,2, 3]);\nexpect(first).toBe(first);\n\nvar last = Arr.last([1 ,2, 3]);\nexpect(last).toBe(3);\n\nvar length = Arr.length([1 ,2, 3]);\nexpect(last).toBe(3);\n\nvar array = [1, 2, 3];\nArr.insert(array, 4);\nexpect(array).toEqual([1, 2, 3, 4]);\n\nvar array = Arr.insert([1 ,2, 3], [4, 5]);\nexpect(array).toEqual([1, 2, 3, 4, 5]);\n\nvar array = Arr.insert([1 ,2, 3], -1, 0);\nexpect(array).toEqual([-1, 1, 2, 3]);\n\nvar array = [1, 2, 3];\nArr.remove(array, 0);\nexpect(array).toEqual([2, 3]);\n\nvar array = [1, 2, 3];\nArr.remove(array, 0, 2);\nexpect(array).toEqual([3]);\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,1,null,1,1,null,1,1,null,1,1,1,null,1,1,1,null]},{"name":".readme/includes/Assert/AssertExample.js","source":"\nvar Assert = Divhide.Assert;\n\n/// Test if the value is valid\nvar isValid = Assert.required()\n    .string()\n    .regex(\"^M\")\n    .max(10)\n    .min(5)\n    .isValid(\"Mary\");\n\nexpect(isValid)\n    .toBe(false);\n\n\n/// Valid assertion:\nvar obj = Assert.required()\n    .array()\n    .max(5)\n    .assert([1, 2, 4, 5]);\n\nexpect(obj)\n    .equals([1, 2, 4, 5]);\n\n\n/// Invalid assertion:\nvar fn = function(){\n\n    Assert.required()\n        .array()\n        .max(1) /// will be on array context\n        .assert([\"first\", \"second\"]);\n\n};\n\nexpect(fn)\n    .toThrow();\n\n","coverage":[null,1,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,1,null,null,null,null,null,null,1,null,null,null]},{"name":".readme/includes/Assertion/AssertionExample.js","source":"\n/// Assertion builder\nvar Assertion = Divhide.Assertion;\n\n/// Create the custom Assert facility\nvar Assert = new Assertion({\n\n    /**\n     *\n     * Tests if the string starts with the given value\n     *\n     * @param  {String} val\n     * @param  {String} str\n     * @return {String}\n     */\n    startsWith: function(val, str){\n\n        if(val.indexOf(str) !== 0){\n            throw new Error(\"Does not starts with \" + str);\n        }\n\n    }\n\n});\n\n/// Test if the value is valid\nvar isValid = Assert\n                .required()\n                .string()\n                .startsWith(\"Mary\")\n                .isValid(\"Mary and Peter\");\n\nexpect(isValid)\n    .toBe(true)\n\n\n/// Assert value\nvar value = Assert\n            .required()\n            .string()\n            .startsWith(\"Mary\")\n            .assert(\"Mary and Peter\");\n\nexpect(value)\n    .equals(\"Mary and Peter\");\n\n","coverage":[null,null,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,2,0,null,null,null,null,null,null,null,1,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,1,null,null,null]},{"name":".readme/includes/Chain/ChainExample.js","source":"\nvar Chain = Divhide.Chain;\n\n\nvar Maths = new Chain(\n\n    /// the chaining fns\n    {\n        sum: function(i,j){\n            return i + j;\n        },\n\n        sub: function(i, j){\n            return i - j;\n        }\n    },\n\n    /// the evaluation fns\n    {\n        calculate: function(result, err){\n            return result;\n        }\n    },\n\n    /// the options\n    {\n\n        /// if true the return of a function is passed as an argument to the next one\n        /// if false, the evaluation arguments are passed to every chain function (default)\n        pipe: true\n\n    });\n\n\nvar value = Maths.sum(5)\n    .sub(3)\n    .sum(10)\n    .calculate(0);\n\nexpect(value)\n    .toBe(12);\n","coverage":[null,1,null,null,1,null,null,null,null,2,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null]},{"name":".readme/includes/Exception/ExceptionDocExample.js","source":"\nvar Exception = Divhide.Exception.Exception;\n\n/// the external translation data\nvar Portuguese = {\n    \"The maximum value allowed is <%= value %>.\": \"Valor máximo é <%= value %>.\"\n};\n\nvar error = new Exception(\n    \"The maximum value allowed is <%= value %>.\",\n    { value: 10 });\n\n/// Exception instance is an error!\nexpect(error instanceof Error)\n    .equals(true);\n\n/// Exception message\nexpect(error.toString())\n    .equals(\"The maximum value allowed is 10.\");\n\n/// I18N Exception message\nexpect(error.toString(Portuguese))\n    .equals(\"Valor máximo é 10.\");\n","coverage":[null,1,null,null,1,null,null,null,1,null,null,null,null,1,null,null,null,1,null,null,null,1,null,null]},{"name":".readme/includes/Exception/ExceptionListDocExample.js","source":"\nvar Exception       = Divhide.Exception.Exception,\n    ExceptionList   = Divhide.Exception.ExceptionList;\n\n\nvar errors = new ExceptionList();\n\n/// is an instance of Error\nexpect(errors instanceof Error)\n    .toEqual(true);\n\n/// adding errors to ExceptionList ( you can also merge other ExceptionList! )\nerrors.push( new Exception(\"Error1\") );\nerrors.push( new Exception(\"Error2\") );\nerrors.push( new Exception(\"Error3\") );\n\n/// get length of the list\nexpect(errors.length)\n    .toEqual(3);\n\n/// get an error from the list\nexpect(errors.items[0].toString())\n    .toEqual(\"Error1\");\n\n/// get the translated error\nexpect(errors.toString({ \"Error1\": \"Error 1\", \"Error2\": \"Error 2\", \"Error3\": \"Error 3\" }))\n    .toEqual(\"Error 1, Error 2, Error 3\");\n\n","coverage":[null,1,null,null,null,1,null,null,1,null,null,null,1,1,1,null,null,1,null,null,null,1,null,null,null,1,null,null,null]},{"name":".readme/includes/I18N/I18NStringDocExample.js","source":"\nvar I18NString = Divhide.I18N.String;\n\n/// the external translation data\nvar Portuguese = {\n    \"hello <%= username %>\": \"olá <%= username %>\"\n};\n\n/// create a I18NString (message + data)\nvar message = new I18NString(\"hello <%= username %>\", { username: \"oscar\" });\n\n/// Gets the English message\nvar en = message.toString();\nexpect(en)\n    .toBe(\"hello oscar\");\n\n/// Gets the Portuguese message\nvar en = message.toString(Portuguese);\nexpect(en)\n    .toBe(\"olá oscar\");","coverage":[null,1,null,null,1,null,null,null,null,1,null,null,1,1,null,null,null,1,1,null]},{"name":".readme/includes/Obj/ObjExample.js","source":"\nvar Obj = Divhide.Obj;\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 });\nexpect(results)\n    .toEqual([\"one\", \"two\"]);\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 }, \"one\");\nexpect(results)\n    .toEqual([\"one\"]);\n\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 }, \"three\");\nexpect(results)\n    .toEqual([]);","coverage":[null,1,null,1,1,null,null,1,1,null,null,null,1,1,null]},{"name":".readme/includes/Safe/SafeArrayExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.array(1);\nexpect(value)\n    .equals([1]);\n\nvar value = Safe.array(1);\nexpect(value)\n    .equals([1]);\n\nvar value = Safe.array([1, 2]);\nexpect(value)\n    .equals([1, 2]);\n\nvar value = Safe.array(null, [ 1, 2 ]);\nexpect(value)\n    .equals([1, 2]);\n\nvar value = Safe.array(\"1\", [1, 2]);\nexpect(value)\n    .equals([\"1\"]);\n","coverage":[null,1,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null]},{"name":".readme/includes/Safe/SafeBooleanExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.boolean(true);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(false);\nexpect(value).toBe(false);\n\nvar value = Safe.boolean(1);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(\"1\");\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(\"0\");\nexpect(value).toBe(false);\n\nvar value = Safe.boolean({});\nexpect(value).toBe(false);\n\nvar value = Safe.boolean({}, true);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean([]);\nexpect(value).toBe(false);\n\nvar value = Safe.boolean(null);\nexpect(value).toBe(false);\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null]},{"name":".readme/includes/Safe/SafeFunctionExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar fn = Safe.function(function(){});\nexpect(fn())\n    .toBe(undefined);\n\nvar fn = Safe.function(\"\");\nexpect(fn())\n    .toBe(undefined);\n\nvar fn = Safe.function(\"\", function(){ return 1; });\nexpect(fn())\n    .toBe(1);\n","coverage":[null,1,null,1,1,null,null,1,1,null,null,1,1,null,null]},{"name":".readme/includes/Safe/SafeLengthExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.length([1, 2]);\nexpect(value).toBe(2);\n\nvar value = Safe.length({ one: 1, two: 2});\nexpect(value).toBe(2);\n\nvar value = Safe.length(2);\nexpect(value).toBe(2);\n\nvar value = Safe.length(\"hello\");\nexpect(value).toBe(5);\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null]},{"name":".readme/includes/Safe/SafeNumberExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.number(1);\nexpect(value).equals(1);\n\nvar value = Safe.number(\"\");\nexpect(value).equals(0);\n\nvar value = Safe.number(\"1\");\nexpect(value).equals(1);\n\nvar value = Safe.number({});\nexpect(value).equals(0);\n\nvar value = Safe.number(\"\", 1);\nexpect(value).equals(1);\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null]},{"name":".readme/includes/Safe/SafeObjectExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.object({ one: 1 });\nexpect(value).equals({ one: 1 });\n\nvar value = Safe.object([]);\nexpect(value).equals({});\n\nvar value = Safe.object([], { one: 1 });\nexpect(value).equals({ one: 1 });\n\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,null]},{"name":".readme/includes/Safe/SafeRegexExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.regexp(/regexp/);\nexpect(value)\n    .toEqual(/regexp/);\n\nvar value = Safe.regexp(\"/regexp/\");\nexpect(value)\n    .toEqual(/regexp/);\n\nvar value = Safe.regexp(\"\");\nexpect(value)\n    .toEqual(/^$/);\n\nvar value = Safe.regexp(\"name\");\nexpect(value)\n    .toEqual(/^name$/);\n\nvar value = Safe.regexp({}, /regexp/);\nexpect(value)\n    .toEqual(/regexp/);\n","coverage":[null,1,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null]},{"name":".readme/includes/Safe/SafeStringExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.string(\"\");\nexpect(value).toBe(\"\");\n\nvar value = Safe.string({});\nexpect(value).toBe(\"\");\n\nvar value = Safe.string({}, \"default\");\nexpect(value).toBe(\"default\");\n\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,null]},{"name":".readme/includes/Safe/SafeValueExample.js","source":"\nvar Safe = Divhide.Safe;\n\nvar value = Safe.value(1);\nexpect(value).toBe(1);\n\nvar value = Safe.value(\"1\");\nexpect(value).toBe(\"1\");\n\nvar value = Safe.value(null);\nexpect(value).toBe(null);\n\nvar value = Safe.value(undefined);\nexpect(value).toBe(null);\n\nvar value = Safe.value(null, 1);\nexpect(value).toBe(1);\n\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,null]},{"name":".readme/includes/Schema/SchemaOverview.js","source":"\nvar Schema = Divhide.Schema;\n\n\n/// get the schema\nvar schema = Schema.object({\n\n        /// array with multiple strings\n        data: Schema.array([ \"\" ]).repeatable().max(10),\n\n        /// every other object key is optional\n        \"/.*/\": Schema.number().optional()\n\n    }).required();\n\n\n/// apply the schema to the value\nvar value = schema.value({\n    data: [ 1, 2, 3, 4, 5, 6],\n    timestamp: \"1404373579473\"\n});\n\n\n/// test the value\nexpect(value).equals({\n    data: [ '1', '2', '3', '4', '5' , '6'],\n    timestamp: 1404373579473\n});","coverage":[null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null]},{"name":".readme/includes/Schema/SchemaStringExample.js","source":"\nvar Schema = Divhide.Schema;\n\nvar serialized =\n        Schema.object({\n            \"name\"      : \"\",\n            \"friends\"   : Schema.array([\n                {\n                    name: \"\"\n                }\n            ]).optional(),\n        })\n        .required()\n        .serialize();\n\n/// deserialize the object\nvar schema = Schema.deserialize(serialized);\n\n/// let's get the object\nvar value = schema.value({\n    id: 1,\n    name: \"Oscar\",\n    friends: [{ name: \"Solange\" }]\n});\n\nexpect(value).equals({\n    name: \"Oscar\",\n    friends: [{ name: \"Solange\" }]\n});\n\n","coverage":[null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,1,null,null,null,null,null,1,null,null,null,null,null]},{"name":".readme/includes/Schema/SchemaNumberExample.js","source":"\nvar Schema = Divhide.Schema;\n\nvar schema = Schema.number()\n                .optional()\n                .min(3)\n                .max(5)\n                .compile();\n\n\n/// value is correct\nvar value = schema.value(3);\nexpect(value).toBe(3);\n\n\n/// optional value\nvar value = schema.value();\nexpect(value).equals(null);\n\n\n/// value is undefined\nexpect(\n    function(){\n        schema.value(0);\n    })\n    .toThrow(\n        new Error(\"The minimum value allowed is 3.\")\n    );\n\n\n/// values exceed the max\nexpect(\n    function(){\n        schema.value(10);\n    })\n    .toThrow(\n        new Error(\"The maximum value allowed is 5.\")\n    );\n\n\n/// because is optional, is valid!\nvar isValid = schema.isValid();\nexpect(isValid).toBe(true);\n\n\nisValid = schema.isValid(3);\nexpect(isValid).toBe(true);\n\n\nisValid = schema.isValid(10);\nexpect(isValid).toBe(false);\n\n","coverage":[null,1,null,1,null,null,null,null,null,null,null,1,1,null,null,null,1,1,null,null,null,1,null,1,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,1,1,null,null,1,1,null,null,1,1,null,null]},{"name":".readme/includes/Schema/SchemaAnyExample.js","source":"\nvar Schema = Divhide.Schema;\n\nvar schema = Schema\n            .any()\n            .required()\n            .compile();\n\n\n/// valid string value!\nvar value = schema.value(\"str\");\nexpect(value).equals(value);\n\n\n/// valid array value!\nvalue = schema.value([1,2]);\nexpect(value).equals([1,2]);\n\n\n/// because its required it fails\nexpect(\n    function(){\n        schema.value(null);\n    })\n    .toThrow(\n        new Error(\"Value is required.\")\n    );","coverage":[null,1,null,1,null,null,null,null,null,null,1,1,null,null,null,1,1,null,null,null,1,null,1,null,null,null,null]},{"name":".readme/includes/Schema/SchemaObjectExample.js","source":"\nvar Schema = Divhide.Schema;\n\nvar schema =\n        Schema.object({\n            \"/^optional/\"   : Schema.string().optional(),\n            \"number\"        : 0,\n            \"string\"        : \"\",\n        })\n        .required()\n        /// TIP: When compiled the schema is faster\n        .compile();\n\n\n/// let's get the object\nvar value = schema.value({\n    string      : \"awesome!\",\n    number      : \"0\",\n    optional1   : \"1\",\n    optional2   : \"2\",\n    other       : 1\n});\n\n\n/// Please notice that some of the object properties were\n/// not included!\nexpect(value).equals({\n    \"number\": 0,\n    \"string\": \"awesome!\",\n    \"optional1\": \"1\",\n    \"optional2\": \"2\"\n});\n\n","coverage":[null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null]},{"name":".readme/includes/Schema/SchemaArrayExample.js","source":"\nvar Schema = Divhide.Schema;\n\n\n/// Array schema ( no repeatable)\nvar schema = Schema\n    .array([ Schema.string().default(\"value\"), Schema.number(), Schema.string() ])\n    .optional()\n    .compile();\n\n\n/// because its optional it returns null\nvar value = schema.value();\nexpect(value).toBe(null);\n\n\n/// The value is right!\nvalue = schema.value([ '1', 2, '3' ]);\nexpect(value).equals([ '1', 2, '3']);\n\n\n/// array have more items than it should\nexpect(\n    function(){\n        schema.value([ '1', 2, '3', 4, 5, 6 ])\n    })\n    .toThrow(\n        new Error(\"Expected list with 3 items but found 6.\")\n    );\n\n\n/// Wrong type!\nexpect(\n    function(){\n        schema.value(10);\n    })\n    .toThrow(\n        new Error(\"'array' was expected but found 'number' instead.\")\n    );\n\n\n///\n/// Just another way to write the rule!\n///\n\n\nvar schema = Schema\n    .array([ Schema.string(), Schema.number() ])\n    .repeatable()\n    .optional()\n    .compile();\n\n\n// Get the value\nvar value = schema.value([\"1\", 2, \"3\", 4]);\nexpect(value).equals([\"1\", 2, \"3\", 4]);\n\n\n// because the number of item on the array must be multiple of 2\n// an error is thrown\nexpect(\n    function(){\n        schema.value([\"1\", 2, \"3\"])\n    })\n    .toThrow(\n        new Error(\"Expected list length to be multiple of 2 but found length of 3.\")\n    );\n\n","coverage":[null,1,null,null,null,1,null,null,null,null,null,null,1,1,null,null,null,1,1,null,null,null,1,null,1,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,1,null,null,null,null,1,null,1,null,null,null,null,null,null]},{"name":".readme/includes/Schema/SchemaSerializationExample.js","source":"\nvar Schema = Divhide.Schema;\n\n\n/// String schema\nvar schema = Schema.string()\n                .required()\n                .min(3)\n                .max(5);\n\n\n/// returns the value\nvar value = schema.value(\"hello\");\nexpect(value).toBe(\"hello\");\n\n\n/// value is required!\nexpect(\n    function(){\n        schema.value();\n    })\n    .toThrowError(\"Value is required., The minimum value allowed is 3.\");\n\n\n/// value is required!\nexpect(\n    function(){\n        schema.value(\"hello world\");\n    })\n    .toThrow(new Error(\"The maximum value allowed is 5.\"));\n\n\n/// Check if is valid\nvar isValid = schema.isValid(\"\");\nexpect(isValid).toBe(false);\n\n\nvar isValid = schema.isValid(\"hello\");\nexpect(isValid).toBe(true);\n\n\nvar isValid = schema.isValid(\"hello world\");\nexpect(isValid).toBe(false);\n\n","coverage":[null,1,null,null,null,1,null,null,null,null,null,null,1,1,null,null,null,1,null,1,null,null,null,null,null,1,null,1,null,null,null,null,null,1,1,null,null,1,1,null,null,1,1,null,null]},{"name":".readme/includes/Type/TypeExample.js","source":"\nvar Type = Divhide.Type;\n\nvar type = Type.of({});\nexpect(type).toBe(\"object\");\n\nvar type = Type.of([]);\nexpect(type).toBe(\"array\");\n\nvar type = Type.of(1);\nexpect(type).toBe(\"number\");\n\nvar type = Type.of(\"name\");\nexpect(type).toBe(\"string\");\n\nvar type = Type.of(true);\nexpect(type).toBe(\"boolean\");\n\nvar isArray = Type.isArray([]);\nexpect(isArray).toBe(true);\n\nvar isBoolean = Type.isBoolean(true);\nexpect(isBoolean).toBe(true);\n\nvar isFunction = Type.isFunction(function(){});\nexpect(isFunction).toBe(true);\n\nvar isString = Type.isString(\"\");\nexpect(isString).toBe(true);\n\nvar isObject = Type.isObject({});\nexpect(isObject).toBe(true);\n\nvar isObject = Type.isObject(null);\nexpect(isObject).toBe(false);\n\nvar isRegExp = Type.isRegExp(/reg/);\nexpect(isRegExp).toBe(true);\n\nvar isNumber = Type.isNumber(1);\nexpect(isNumber).toBe(true);\n\nvar isNumber = Type.isNumber(\"1.1\");\nexpect(isNumber).toBe(true);\n\nvar isDefined = Type.isDefined(null);\nexpect(isDefined).toBe(false);\n\nvar isDefined = Type.isDefined(undefined);\nexpect(isDefined).toBe(false);\n\nvar isEmpty = Type.isEmpty(\"\");\nexpect(isEmpty).toBe(true);\n\nvar isEmpty = Type.isEmpty([]);\nexpect(isEmpty).toBe(true);\n\nvar isEmpty =  Type.isEmpty({});\nexpect(isEmpty).toBe(true);\n\nvar isEmpty =  Type.isEmpty(null);\nexpect(isEmpty).toBe(true);\n\nvar isString = Type.instanceOf(\"string\", String);\nexpect(isString).toBe(true);\n","coverage":[null,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null,1,1,null]}],"git":{"head":{"id":"cf98ea11cf1f904e244fbaf134d4d52f982657b1","author_name":"Oscar Brito","author_email":"aetheon@gmail.com","committer_name":"Oscar Brito","committer_email":"aetheon@gmail.com","message":"Code coverage support #31 Changed 'grunt dev' to 'grunt test'"},"branch":"master","remotes":[{"name":"origin","url":"git@github.com:divhide/divhide-core.git"}]},"run_at":"2015-07-05T14:10:10.642Z","service_name":"travis-ci","repo_token":"nEvYibR5F2sm4L0SKTfkXL9W29A618NaO"}