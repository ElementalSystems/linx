"use strict";


/// lodash titanium shim. If window is undefined set global variable
var global = undefined, isBrowser = false;
try{ isBrowser = (window !== undefined); }catch(e){}
if(!isBrowser){ global = this; global.global = global; }

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Divhide = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

var Arr = Divhide.Arr;

var value = Arr.index([1 ,2, 3], 0);
expect(value).toBe(1);

var value = Arr.index([1 ,2, 3], 10);
expect(value).toBeNull();

var first = Arr.first([1 ,2, 3]);
expect(first).toBe(first);

var last = Arr.last([1 ,2, 3]);
expect(last).toBe(3);

var length = Arr.length([1 ,2, 3]);
expect(last).toBe(3);

var array = [1, 2, 3];
Arr.insert(array, 4);
expect(array).toEqual([1, 2, 3, 4]);

var array = Arr.insert([1 ,2, 3], [4, 5]);
expect(array).toEqual([1, 2, 3, 4, 5]);

var array = Arr.insert([1 ,2, 3], -1, 0);
expect(array).toEqual([-1, 1, 2, 3]);

var array = [1, 2, 3];
Arr.remove(array, 0);
expect(array).toEqual([2, 3]);

var array = [1, 2, 3];
Arr.remove(array, 0, 2);
expect(array).toEqual([3]);

},{}],2:[function(require,module,exports){

var Assert = Divhide.Assert;

/// Test if the value is valid
var isValid = Assert.required()
    .string()
    .regex("^M")
    .max(10)
    .min(5)
    .isValid("Mary");

expect(isValid)
    .toBe(false);


/// Valid assertion:
var obj = Assert.required()
    .array()
    .max(5)
    .assert([1, 2, 4, 5]);

expect(obj)
    .equals([1, 2, 4, 5]);


/// Invalid assertion:
var fn = function(){

    Assert.required()
        .array()
        .max(1) /// will be on array context
        .assert(["first", "second"]);

};

expect(fn)
    .toThrow();


},{}],3:[function(require,module,exports){

/// Assertion builder
var Assertion = Divhide.Assertion;

/// Create the custom Assert facility
var Assert = new Assertion({

    /**
     *
     * Tests if the string starts with the given value
     *
     * @param  {String} val
     * @param  {String} str
     * @return {String}
     */
    startsWith: function(val, str){

        if(val.indexOf(str) !== 0){
            throw new Error("Does not starts with " + str);
        }

    }

});

/// Test if the value is valid
var isValid = Assert
                .required()
                .string()
                .startsWith("Mary")
                .isValid("Mary and Peter");

expect(isValid)
    .toBe(true)


/// Assert value
var value = Assert
            .required()
            .string()
            .startsWith("Mary")
            .assert("Mary and Peter");

expect(value)
    .equals("Mary and Peter");


},{}],4:[function(require,module,exports){

var Chain = Divhide.Chain;


var Maths = new Chain(

    /// the chaining fns
    {
        sum: function(i,j){
            return i + j;
        },

        sub: function(i, j){
            return i - j;
        }
    },

    /// the evaluation fns
    {
        calculate: function(result, err){
            return result;
        }
    },

    /// the options
    {

        /// if true the return of a function is passed as an argument to the next one
        /// if false, the evaluation arguments are passed to every chain function (default)
        pipe: true

    });


var value = Maths.sum(5)
    .sub(3)
    .sum(10)
    .calculate(0);

expect(value)
    .toBe(12);

},{}],5:[function(require,module,exports){

var Exception = Divhide.Exception.Exception;

/// the external translation data
var Portuguese = {
    "The maximum value allowed is <%= value %>.": "Valor máximo é <%= value %>."
};

var error = new Exception(
    "The maximum value allowed is <%= value %>.",
    { value: 10 });

/// Exception instance is an error!
expect(error instanceof Error)
    .equals(true);

/// Exception message
expect(error.toString())
    .equals("The maximum value allowed is 10.");

/// I18N Exception message
expect(error.toString(Portuguese))
    .equals("Valor máximo é 10.");

},{}],6:[function(require,module,exports){

var Exception       = Divhide.Exception.Exception,
    ExceptionList   = Divhide.Exception.ExceptionList;


var errors = new ExceptionList();

/// is an instance of Error
expect(errors instanceof Error)
    .toEqual(true);

/// adding errors to ExceptionList ( you can also merge other ExceptionList! )
errors.push( new Exception("Error1") );
errors.push( new Exception("Error2") );
errors.push( new Exception("Error3") );

/// get length of the list
expect(errors.length)
    .toEqual(3);

/// get an error from the list
expect(errors.items[0].toString())
    .toEqual("Error1");

/// get the translated error
expect(errors.toString({ "Error1": "Error 1", "Error2": "Error 2", "Error3": "Error 3" }))
    .toEqual("Error 1, Error 2, Error 3");


},{}],7:[function(require,module,exports){

var I18NString = Divhide.I18N.String;

/// the external translation data
var Portuguese = {
    "hello <%= username %>": "olá <%= username %>"
};

/// create a I18NString (message + data)
var message = new I18NString("hello <%= username %>", { username: "oscar" });

/// Gets the English message
var en = message.toString();
expect(en)
    .toBe("hello oscar");

/// Gets the Portuguese message
var en = message.toString(Portuguese);
expect(en)
    .toBe("olá oscar");
},{}],8:[function(require,module,exports){

var Obj = Divhide.Obj;

var results = Obj.filter({ "one": 1, "two": 2 });
expect(results)
    .toEqual(["one", "two"]);

var results = Obj.filter({ "one": 1, "two": 2 }, "one");
expect(results)
    .toEqual(["one"]);


var results = Obj.filter({ "one": 1, "two": 2 }, "three");
expect(results)
    .toEqual([]);
},{}],9:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.array(1);
expect(value)
    .equals([1]);

var value = Safe.array(1);
expect(value)
    .equals([1]);

var value = Safe.array([1, 2]);
expect(value)
    .equals([1, 2]);

var value = Safe.array(null, [ 1, 2 ]);
expect(value)
    .equals([1, 2]);

var value = Safe.array("1", [1, 2]);
expect(value)
    .equals(["1"]);

},{}],10:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.boolean(true);
expect(value).toBe(true);

var value = Safe.boolean(false);
expect(value).toBe(false);

var value = Safe.boolean(1);
expect(value).toBe(true);

var value = Safe.boolean("1");
expect(value).toBe(true);

var value = Safe.boolean("0");
expect(value).toBe(false);

var value = Safe.boolean({});
expect(value).toBe(false);

var value = Safe.boolean({}, true);
expect(value).toBe(true);

var value = Safe.boolean([]);
expect(value).toBe(false);

var value = Safe.boolean(null);
expect(value).toBe(false);

},{}],11:[function(require,module,exports){

var Safe = Divhide.Safe;

var fn = Safe.function(function(){});
expect(fn())
    .toBe(undefined);

var fn = Safe.function("");
expect(fn())
    .toBe(undefined);

var fn = Safe.function("", function(){ return 1; });
expect(fn())
    .toBe(1);

},{}],12:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.length([1, 2]);
expect(value).toBe(2);

var value = Safe.length({ one: 1, two: 2});
expect(value).toBe(2);

var value = Safe.length(2);
expect(value).toBe(2);

var value = Safe.length("hello");
expect(value).toBe(5);

},{}],13:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.number(1);
expect(value).equals(1);

var value = Safe.number("");
expect(value).equals(0);

var value = Safe.number("1");
expect(value).equals(1);

var value = Safe.number({});
expect(value).equals(0);

var value = Safe.number("", 1);
expect(value).equals(1);

},{}],14:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.object({ one: 1 });
expect(value).equals({ one: 1 });

var value = Safe.object([]);
expect(value).equals({});

var value = Safe.object([], { one: 1 });
expect(value).equals({ one: 1 });


},{}],15:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.regexp(/regexp/);
expect(value)
    .toEqual(/regexp/);

var value = Safe.regexp("/regexp/");
expect(value)
    .toEqual(/regexp/);

var value = Safe.regexp("");
expect(value)
    .toEqual(/^$/);

var value = Safe.regexp("name");
expect(value)
    .toEqual(/^name$/);

var value = Safe.regexp({}, /regexp/);
expect(value)
    .toEqual(/regexp/);

},{}],16:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.string("");
expect(value).toBe("");

var value = Safe.string({});
expect(value).toBe("");

var value = Safe.string({}, "default");
expect(value).toBe("default");


},{}],17:[function(require,module,exports){

var Safe = Divhide.Safe;

var value = Safe.value(1);
expect(value).toBe(1);

var value = Safe.value("1");
expect(value).toBe("1");

var value = Safe.value(null);
expect(value).toBe(null);

var value = Safe.value(undefined);
expect(value).toBe(null);

var value = Safe.value(null, 1);
expect(value).toBe(1);


},{}],18:[function(require,module,exports){

var Schema = Divhide.Schema;

var schema = Schema
            .any()
            .required()
            .compile();


/// valid string value!
var value = schema.value("str");
expect(value).equals(value);


/// valid array value!
value = schema.value([1,2]);
expect(value).equals([1,2]);


/// because its required it fails
expect(
    function(){
        schema.value(null);
    })
    .toThrow(
        new Error("Value is required.")
    );
},{}],19:[function(require,module,exports){

var Schema = Divhide.Schema;


/// Array schema ( no repeatable)
var schema = Schema
    .array([ Schema.string().default("value"), Schema.number(), Schema.string() ])
    .optional()
    .compile();


/// because its optional it returns null
var value = schema.value();
expect(value).toBe(null);


/// The value is right!
value = schema.value([ '1', 2, '3' ]);
expect(value).equals([ '1', 2, '3']);


/// array have more items than it should
expect(
    function(){
        schema.value([ '1', 2, '3', 4, 5, 6 ])
    })
    .toThrow(
        new Error("Expected list with 3 items but found 6.")
    );


/// Wrong type!
expect(
    function(){
        schema.value(10);
    })
    .toThrow(
        new Error("'array' was expected but found 'number' instead.")
    );


///
/// Just another way to write the rule!
///


var schema = Schema
    .array([ Schema.string(), Schema.number() ])
    .repeatable()
    .optional()
    .compile();


// Get the value
var value = schema.value(["1", 2, "3", 4]);
expect(value).equals(["1", 2, "3", 4]);


// because the number of item on the array must be multiple of 2
// an error is thrown
expect(
    function(){
        schema.value(["1", 2, "3"])
    })
    .toThrow(
        new Error("Expected list length to be multiple of 2 but found length of 3.")
    );


},{}],20:[function(require,module,exports){

var Schema = Divhide.Schema;

var schema = Schema.number()
                .optional()
                .min(3)
                .max(5)
                .compile();


/// value is correct
var value = schema.value(3);
expect(value).toBe(3);


/// optional value
var value = schema.value();
expect(value).equals(null);


/// value is undefined
expect(
    function(){
        schema.value(0);
    })
    .toThrow(
        new Error("The minimum value allowed is 3.")
    );


/// values exceed the max
expect(
    function(){
        schema.value(10);
    })
    .toThrow(
        new Error("The maximum value allowed is 5.")
    );


/// because is optional, is valid!
var isValid = schema.isValid();
expect(isValid).toBe(true);


isValid = schema.isValid(3);
expect(isValid).toBe(true);


isValid = schema.isValid(10);
expect(isValid).toBe(false);


},{}],21:[function(require,module,exports){

var Schema = Divhide.Schema;

var schema =
        Schema.object({
            "/^optional/"   : Schema.string().optional(),
            "number"        : 0,
            "string"        : "",
        })
        .required()
        /// TIP: When compiled the schema is faster
        .compile();


/// let's get the object
var value = schema.value({
    string      : "awesome!",
    number      : "0",
    optional1   : "1",
    optional2   : "2",
    other       : 1
});


/// Please notice that some of the object properties were
/// not included!
expect(value).equals({
    "number": 0,
    "string": "awesome!",
    "optional1": "1",
    "optional2": "2"
});


},{}],22:[function(require,module,exports){

var Schema = Divhide.Schema;


/// get the schema
var schema = Schema.object({

        /// array with multiple strings
        data: Schema.array([ "" ]).repeatable().max(10),

        /// every other object key is optional
        "/.*/": Schema.number().optional()

    }).required();


/// apply the schema to the value
var value = schema.value({
    data: [ 1, 2, 3, 4, 5, 6],
    timestamp: "1404373579473"
});


/// test the value
expect(value).equals({
    data: [ '1', '2', '3', '4', '5' , '6'],
    timestamp: 1404373579473
});
},{}],23:[function(require,module,exports){

var Schema = Divhide.Schema;


/// String schema
var schema = Schema.string()
                .required()
                .min(3)
                .max(5);


/// returns the value
var value = schema.value("hello");
expect(value).toBe("hello");


/// value is required!
expect(
    function(){
        schema.value();
    })
    .toThrowError("Value is required., The minimum value allowed is 3.");


/// value is required!
expect(
    function(){
        schema.value("hello world");
    })
    .toThrow(new Error("The maximum value allowed is 5."));


/// Check if is valid
var isValid = schema.isValid("");
expect(isValid).toBe(false);


var isValid = schema.isValid("hello");
expect(isValid).toBe(true);


var isValid = schema.isValid("hello world");
expect(isValid).toBe(false);


},{}],24:[function(require,module,exports){

var Schema = Divhide.Schema;

var serialized =
        Schema.object({
            "name"      : "",
            "friends"   : Schema.array([
                {
                    name: ""
                }
            ]).optional(),
        })
        .required()
        .serialize();

/// deserialize the object
var schema = Schema.deserialize(serialized);

/// let's get the object
var value = schema.value({
    id: 1,
    name: "Oscar",
    friends: [{ name: "Solange" }]
});

expect(value).equals({
    name: "Oscar",
    friends: [{ name: "Solange" }]
});


},{}],25:[function(require,module,exports){

var Type = Divhide.Type;

var type = Type.of({});
expect(type).toBe("object");

var type = Type.of([]);
expect(type).toBe("array");

var type = Type.of(1);
expect(type).toBe("number");

var type = Type.of("name");
expect(type).toBe("string");

var type = Type.of(true);
expect(type).toBe("boolean");

var isArray = Type.isArray([]);
expect(isArray).toBe(true);

var isBoolean = Type.isBoolean(true);
expect(isBoolean).toBe(true);

var isFunction = Type.isFunction(function(){});
expect(isFunction).toBe(true);

var isString = Type.isString("");
expect(isString).toBe(true);

var isObject = Type.isObject({});
expect(isObject).toBe(true);

var isObject = Type.isObject(null);
expect(isObject).toBe(false);

var isRegExp = Type.isRegExp(/reg/);
expect(isRegExp).toBe(true);

var isNumber = Type.isNumber(1);
expect(isNumber).toBe(true);

var isNumber = Type.isNumber("1.1");
expect(isNumber).toBe(true);

var isDefined = Type.isDefined(null);
expect(isDefined).toBe(false);

var isDefined = Type.isDefined(undefined);
expect(isDefined).toBe(false);

var isEmpty = Type.isEmpty("");
expect(isEmpty).toBe(true);

var isEmpty = Type.isEmpty([]);
expect(isEmpty).toBe(true);

var isEmpty =  Type.isEmpty({});
expect(isEmpty).toBe(true);

var isEmpty =  Type.isEmpty(null);
expect(isEmpty).toBe(true);

var isString = Type.instanceOf("string", String);
expect(isString).toBe(true);

},{}],26:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Type        = require("./Type"),
    Safe        = require("./Safe");



var Arr = {

    /**
     * Get index value
     *
     * @param {Array}   array
     * @param {Number}  index
     *
     * @return {*}
     *
     */
    index: function(array, index){

        array = Safe.array(array);
        index = Safe.number(index);

        if(index < 0 || index > array.length - 1)
            return null;

        return array[index];

    },

    /**
     *
     * Get last value of the array
     *
     * @param {Array}   array
     *
     * @return {Object}
     *
     */
    last: function(array){

        array = Safe.array(array);

        return Arr.index(array, array.length - 1);

    },

    /*
     * Get first value of the array
     *
     * @param {Array}   array
     *
     * @return {Object}
     *
     */
    first: function(array){

        return Arr.index(array);

    },

    /**
     *
     * Returns the length of the array
     *
     * @param {Array}   array
     *
     * @return {Number}
     *
     */
    length: function(array){

        array = Safe.array(array);

        return array.length;

    },

    /**
     *
     * Inserts the value in the specified index of the array
     *
     * @param {Array}   array
     * @param {*}       value
     * @param {Number}  index
     *
     * @return {Array}
     *
     */
    insert: function(array, value, index){

        array = Safe.array(array);
        value = Safe.array(value);

        /* jshint -W041 */
        if(index == null){
            index = Arr.length(array);
        } else {
            index = Safe.number(index);
        }

        // merge the structures
        _.each(
            value.reverse(),
            function(item){
                array.splice(index, 0, item);
            }
        );

        return array;

    },

    /*
     * Remove index of the array. If no index is specified the first
     * element is removed.
     *
     * Returns the removed elements.
     *
     * @param {Array}   index
     * @param {Number}  index
     * @param {Number}  n
     *
     * @return {Array}
     *
     */
    remove: function(array, index, n){

        array   = Safe.array(array);
        index   = Safe.number(index, 0);
        n       = Safe.number(n, 1);

        return array.splice(index, n);

    }

};


module.exports = Arr;


},{"./Safe":47,"./Type":58,"lodash":"lodash"}],27:[function(require,module,exports){
'use strict';

var Assertion = require("./Assertion");

module.exports = new Assertion();

},{"./Assertion":37}],28:[function(require,module,exports){
'use strict';

var Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test if value is an array
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {Array}
 *
 */
var Arr = function(val){

    var v = Type.isArray(val);

    if(!v){
        throw new Exception("VALIDATION_TYPE", { value: Type.of(val), expected: Type.of([]) });
    }

    return val;

};

module.exports = Arr;

},{"../Exception/Exception":42,"../Type":58}],29:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Get function name
 * 
 * @param  {Function} fn
 * @return {String}
 * 
 */
var getFnName = function(fun) {

	var ret = fun.toString();
	ret = ret.substr('function '.length);
	ret = ret.substr(0, ret.indexOf('('));
	return ret;

};


/**
 *
 * InstanceOf assertion. 
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @param {*} value
 * 
 * @return {*}
 *
 */
var InstanceOf = function(val, value){

	/// test with instanceof
	if(!Type.instanceOf(val, value)){
		throw new Exception("VALIDATION_INSTANCEOF", { value: getFnName(value) });
	}

    return val;

};

module.exports = InstanceOf;

},{"../Exception/Exception":42,"../Type":58,"lodash":"lodash"}],30:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Type        = require("../Type"),
    Safe        = require("../Safe"),
    Exception   = require("../Exception/Exception");



/**
 *
 * Test the max length of any kind of object
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {*}
 *
 */
var Max = function(val, max){

    max = Safe.number(max);
    var length = Safe.length(val);

    if(length > max){
        throw new Exception("VALIDATION_MAX", { value: max });
    }

    return val;

};

module.exports = Max;

},{"../Exception/Exception":42,"../Safe":47,"../Type":58,"lodash":"lodash"}],31:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Type        = require("../Type"),
    Safe        = require("../Safe"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test the min length of any kind of object
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {*}
 *
 */
var Min = function(val, min){

    min = Safe.number(min);
    var length = Safe.length(val);

    if(length < min){
        throw new Exception("VALIDATION_MIN", { value: min });
    }

    return val;

};

module.exports = Min;

},{"../Exception/Exception":42,"../Safe":47,"../Type":58,"lodash":"lodash"}],32:[function(require,module,exports){
'use strict';

var Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test if value is a number
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {Number}
 *
 */
var Numb = function(val){

    var v = Type.isNumber(val);

    if(!v){
        throw new Exception("VALIDATION_TYPE", { value: Type.of(val), expected: Type.of(0) });
    }

    return val;

};

module.exports = Numb;

},{"../Exception/Exception":42,"../Type":58}],33:[function(require,module,exports){
'use strict';

var Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test if value is an object
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {Object}
 *
 */
var Obj = function(val){

    var v = Type.isObject(val);

    if(!v){
        throw new Exception("VALIDATION_TYPE", { value: Type.of(val), expected: Type.of({}) });
    }

    return val;

};

module.exports = Obj;

},{"../Exception/Exception":42,"../Type":58}],34:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Type        = require("../Type"),
    Safe        = require("../Safe"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test the regex
 *
 * @throws {Exception}
 *
 * @param {*}               val
 * @param {String|Regex}    regex
 * @return {*}
 *
 */
var Regex = function(val, regex){

    regex = Safe.regexp(regex);

    var isValid = !!regex.exec(val);

    if(!isValid){
        throw new Exception("REGEXP", { value: val });
    }

    return val;

};

module.exports = Regex;
},{"../Exception/Exception":42,"../Safe":47,"../Type":58,"lodash":"lodash"}],35:[function(require,module,exports){
'use strict';

var Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * IsRequired
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {*}
 *
 */
var Required = function(val){

    var v = Type.isDefined(val);

    if(!v) {
        throw new Exception("VALIDATION_REQUIRED");
    }

    return val;

};

module.exports = Required;

},{"../Exception/Exception":42,"../Type":58}],36:[function(require,module,exports){
'use strict';

var Type        = require("../Type"),
    Exception   = require("../Exception/Exception");

/**
 *
 * Test if value is a string
 *
 * @throws {Exception}
 *
 * @param {*} val
 * @return {String}
 *
 */
var Str = function(val){

    var v = Type.isString(val);

    if(!v){
        throw new Exception("VALIDATION_TYPE", { value: Type.of(val), expected: Type.of("") });
    }

    return val;

};

module.exports = Str;

},{"../Exception/Exception":42,"../Type":58}],37:[function(require,module,exports){
'use strict';

var _               = require("lodash"),
    Safe            = require("./Safe"),
    Chain           = require("./Chain"),
    ChainContext    = require("./Chain/ChainContext");


/**
 *
 * The Chainable functions
 *
 * @type {Object}
 *
 */
var ChainableFns = {};

ChainableFns.required   = require("./Assert/Required");
ChainableFns.string     = require("./Assert/String");
ChainableFns.object     = require("./Assert/Object");
ChainableFns.array      = require("./Assert/Array");
ChainableFns.number     = require("./Assert/Number");
ChainableFns.max        = require("./Assert/Max");
ChainableFns.min        = require("./Assert/Min");
ChainableFns.regex      = require("./Assert/Regex");
ChainableFns.instanceOf = require("./Assert/InstanceOf");

/**
 *
 * The Assertion functions
 *
 * @type {Object}
 *
 */
var AssertionFns = {};

/**
 *
 * Tests if the combination of rules are valid
 *
 * @param  {*}          result
 * @param  {Error}      err
 * @return {Boolean}
 */
AssertionFns.isValid = function(result, err){
    return !err;
};

/**
 *
 * Assert
 *
 * @param  {*}      result
 * @param  {Error}  err
 * @return {}
 *
 */
AssertionFns.assert = function(result, err){

    if(err){
        throw err;
    }

    return result;

};

/**
 *
 * Construct a new Assertion provider. This can have some custom actions.
 * @class
 *
 * @param {Object} fns
 *
 * @return {Object}
 *
 * @example
 *
 * Assertion({})
 *     .required()
 *     .string()
 *     .max(10)
 *     .min(5)
 *     [ .isValid("aaaa") | .assert("aaaa") ]
 *
 */
var Assertion = function(fns){

    fns = Safe.object(fns);
    fns = _.assign({}, fns, ChainableFns);

    /// Get the current ChainContext of the assertion, in order
    /// to keep the assertion state.
    var context = null;
    _.each(arguments, function(arg){

        if(arg instanceof ChainContext){
            context = arg;
            return false;
        }

    });

    /// Apply Cahin to the same context
    /// this is important because we can invoke "instaceof Assertion"
    Chain.apply(this, [fns, AssertionFns, { pipe: false, type: Assertion }, context]);

};

module.exports = Assertion;


},{"./Assert/Array":28,"./Assert/InstanceOf":29,"./Assert/Max":30,"./Assert/Min":31,"./Assert/Number":32,"./Assert/Object":33,"./Assert/Regex":34,"./Assert/Required":35,"./Assert/String":36,"./Chain":38,"./Chain/ChainContext":39,"./Safe":47,"lodash":"lodash"}],38:[function(require,module,exports){
'use strict';

var _    = require("lodash"),
    Type = require("./Type"),
    Safe = require("./Safe"),
    ChainContext    = require("./Chain/ChainContext");



/**
 *
 * Module internal code
 *
 * @type {Object}
 *
 */
var Internal = {};

/**
 *
 * Gets the argument list
 *
 * @param  {Object} argsObj
 * @return {Array}
 *
 */
Internal.getArgumentList = function(argsObj){

    var args = [];

    _.each(argsObj, function(obj, index){
        args.push(obj);
    });

    return args;

};

/**
 *
 * Wraps the chainable function
 *
 * @param {Internal.ChainContext} context
 * @param {Function}    fn
 * @param {Object}      chainableFns
 * @param {Object}      evaluationFns
 * @param {Object}      options
 *
 * @return {Function}
 *
 */
Internal.wrapChainableFunction = function(context, fn, chainableFns, evaluationFns, options){

    options = Safe.object(options);

    return function() {

        var curContext  = context,
            args        = Internal.getArgumentList(arguments);

        /// initialize context if needed
        if(!curContext){
            curContext = new ChainContext(options);
        }

        /// add the function to the curContext
        curContext.add(fn, args);

        /// this is usefull to create "typed" instances of the Chain
        var ChainClass = Safe.function(options.type, Chain);

        return new ChainClass(chainableFns, evaluationFns, options, curContext);

    };

};

/**
 *
 * Wraps a returnable function. The last argument of the function is always the error, or null
 * if doesn't exists.
 *
 * @param {Internal.ChainContext} context
 * @param {Function}    fn
 * @param {Object}      chainableFns
 * @param {Object}      evaluationFns
 * @param {Object}      options
 *
 * @return {Function}
 *
 */
Internal.wrapReturnableFunction = function(context, fn, chainableFns, evaluationFns, options){

    options = Safe.object(options);

    return function() {

        var curContext  = context,
            args        = Internal.getArgumentList(arguments);

        /// initialize context if needed
        if(!curContext){
            curContext = new ChainContext(options);
        }

        var result  = null,
            err     = null;

        /// wrap the arguments to .apply call. The last argument should be the one defined
        /// on the options.
        var _args = [ args.shift() ];

        /// sets the scope of the context
        var scope = curContext.setScope(options.scope);

        try {
            /// execute all the chained functions
            result = curContext.exec(_args, options.argument);
        }
        catch(e){
            err = e;
        }

        /// if its on pipe mode, wrap the result so it can be correctly .apply()
        if(options.pipe){
            result = [ result ];
        }

        /// create the evaluation function arguments
        var fnArgs = Safe.array(result, [ null ])
            /// concat the arguments if they are not undefined
            .concat(Safe.array(args))
            /// concat the argument if is not undefined
            .concat(Safe.array(options.argument))
            /// concat the err as last argument
            .concat([err]);

        return fn.apply(scope, fnArgs);

    };

};

/**
 *
 * Get chain functions
 *
 * @param  {Internal.CurrentAssertionContext} assertionContext
 * @param  {Object} chainableFns
 * @param  {Object} evaluationFns
 * @param  {Object} options
 *
 * @return {Object}
 *
 */
Internal.getChainFunctions = function(context, chainableFns, evaluationFns, options){

    /// merge the default fns and the custom functions
    var fns = _.assign({}, chainableFns);

    /// wrap the chainable functions
    _.each(
        fns,
        function(fn, name){

            if(Type.isFunction(fn)){
                fns[name] = Internal.wrapChainableFunction(context, fn, chainableFns, evaluationFns, options);
            }

        });

    /// wrap the returning functions
    _.each(
        evaluationFns,
        function(fn, name){

            if(Type.isFunction(fn)){
                fns[name] = Internal.wrapReturnableFunction(context, fn, chainableFns, evaluationFns, options);
            }

        });

    return fns;

};

/**
 *
 * Chain constructor
 * @class
 *
 * @param {Object}          chainableFns
 * @param {Object}          evaluationFns
 * @param {Object}          options
 * @param {ChainContext}    context
 *
 * @return {Object}
 *
 *
 * @example
 *
 * new Chain(
 *
 *     /// chainable fns
 *     {
 *         "fn": function(){}
 *     },
 *
 *     /// evaluation fns
 *     {},
 *
 *     /// options fns
 *     {
 *         type         : {},
 *         pipe         : [true|false],
 *         scope        : Function,
 *         argument     : undefined
 *     },
 *
 *     /// context
 *     {}
 *
 * );
 *
 *
 */
var Chain = function(chainableFns, evaluationFns, options, context){

    var scope   = this;

    /// chain the functions
    var fns = Internal.getChainFunctions(context, chainableFns, evaluationFns, options);

    /// initialize this context
    _.each(fns, function(val, key){
        scope[key] = val;
    });

};

Chain.prototype = {};


module.exports = Chain;


},{"./Chain/ChainContext":39,"./Safe":47,"./Type":58,"lodash":"lodash"}],39:[function(require,module,exports){
'use strict';

var _    = require("lodash"),
    Safe = require("../Safe"),
    Type = require("../Type"),

    ChainFunction   = require("./ChainFunction");


/**
 *
 * A chain context keeps track of the current chainable state
 * @class
 *
 * @param {Object} options
 *
 * @example
 *
 * new ChainContext({
 *
 *     pipe:
 * })
 */
var ChainContext = function(options){

    options = Safe.object(options);

    /**
     * The context registered functions
     *
     * @type { [Internal.AssertionFunction] }
     *
     */
    this.fns = [];

    /**
     *
     * The shared fn context
     *
     * @type {Object}
     *
     */
    this.scope = this.setScope(options.scope);

    /**
     *
     * Pipe mode context
     *
     * @type {Boolean}
     *
     */
    this.pipe = Safe.boolean(options.pipe);

};

/**
 *
 * Sets the scope of this context.
 *
 * @param  {Object|Function} scope
 * @return {Object}
 */
ChainContext.prototype.setScope = function(scope){

    if(Type.isDefined(scope)){
        scope = Type.isFunction(scope) ? scope() : scope;
    }

    /// Maintain the current context if not defined
    scope = scope || this.scope;

    /// set the context
    this.scope = Safe.object(scope, {});

    return this.scope;

};

/**
 *
 * Chain the given function
 *
 * @param  {Function|Object}   fn
 * @param  {Array}  args
 *
 * @return {Internal.Chain}
 *
 */
ChainContext.prototype.add = function(fn, args){

    if(Type.isFunction(fn)) {

        fn = new ChainFunction({ fn: fn, args: args });

        this.fns.push( fn );

    }

};

/**
 *
 * Execute the context using the given argument as parameter
 *
 * @param  {*}          args
 * @param  {Array}      extraArgs
 * @param  {Funcion}    errCallback
 *
 * @return {*}
 **
 */
ChainContext.prototype.exec = function(args, extraArgs, errCallback){

    extraArgs   = Safe.value(extraArgs);
    errCallback = Safe.function(errCallback, function(err){ throw err; });

    var self    = this,
        result  = args,
        error   = null;

    /// execute the functions
    _.each(
        this.fns,
        function(fn, index){

            try {

                /// really execute the function
                var value = fn.apply(self.scope, result, extraArgs);

                /// if chain return values between the functions
                if(self.pipe) {
                    result = value;
                }

            } catch(e){
                error = e;
            }

            /// stop iterating
            if(error !== null){
                return false;
            }

        });

    /// if an error exists
    if(error){
        errCallback(error);
        return null;
    }

    /// returns
    return result;

};

module.exports = ChainContext;

},{"../Safe":47,"../Type":58,"./ChainFunction":40,"lodash":"lodash"}],40:[function(require,module,exports){
'use strict';

var _    = require("lodash"),
    Type = require("../Type"),
    Safe = require("../Safe");

/**
 * @class
 * The ChainFunction wraps the functionality of a function executed
 * on a chain context.
 *
 * @param {Object} options
 *
 * @example
 * new ChainFunction({
 *     fn   : function(){},
 *     args : []
 * });
 *
 */
var ChainFunction = function(options){

    options = Safe.object(options);

    this.name   = Safe.string(options.name, "?");
    this.fn     = Safe.function(options.fn, function(){});
    this.args   = Safe.array(options.args);

};

/**
 *
 * Execute the function within the context of the given scope and args.
 *
 * The arguments of the function will be the concatenation of the given
 * args and the instance arguments.
 *
 * @param  {*} scope
 * @param  {*} args
 * @param  {*} extraArgs
 *
 * @return {*}
 *
 */
ChainFunction.prototype.apply = function(scope, args, extraArgs) {

    scope       = Safe.object(scope);
    args        = Safe.array(args);
    extraArgs   = Safe.array(extraArgs);

    /// the given args should always exist
    if(args.length === 0) args = [ null ];

    /// concatenate the given arguments with the instance
    args = args.concat(this.args).concat(extraArgs);

    /// execute function with obj scope and the given arguments
    return this.fn.apply(scope, args);

};


module.exports = ChainFunction;

},{"../Safe":47,"../Type":58,"lodash":"lodash"}],41:[function(require,module,exports){
'use strict';

var _                        = require("lodash"),
    Type                     = require("./Type"),
    Safe                     = require("./Safe"),
    Chain                    = require("./Chain"),
    ChainContext             = require("./Chain/ChainContext"),
    Types                    = require("./Schema/Types"),
    SchemaDefinition         = require("./Schema/SchemaDefinition"),
    SchemaEvaluator          = require("./Schema/SchemaEvaluator");

/**
 *
 * Internal methods wrapper
 *
 * @type {Object}
 *
 */
var Internal = {};

/**
 *
 * Wraps the validation functions in order to change the SchemaDefinition context
 * when applied.
 *
 * @param  {String} name
 *
 * @return {ValidationFunction}
 *
 */
Internal.wrapValidationFunction = function(name){

    /// arguments normalization
    name = Safe.string(name);

    /// return the wrapped function
    return function(){

        /// get the actual arguments
        var args = _.toArray(arguments);

        /// first argument is the eval object, so discard it.
        args.shift();
        
        /// last argument is the chain argument option, so discard it
        args.pop();

        /// add the value definition to the SchemaDefinition list
        this.validations.push({
            name: name,
            args: args
        });

    };

};

/**
 *
 * SchemaDefinition compile options.
 *
 * @type {Object}
 * 
 */
Internal.compileOptions = {

    /**
     *
     * Prepare the given value for the SchemaDefinition 
     * conversion. If the value is instance of Schema get 
     * its SchemaDefinition value for the conversions
     *
     * @param  {*} val
     * 
     * @return {*}
     * 
     */
    prepare: function(val){

        if(Type.instanceOf(val, Types.Schema)){
            var schemaData = val.serialize();
            val = new SchemaDefinition(schemaData, { 
                prepare: function(val){
                    return new SchemaDefinition(val, { compile: false });
                }
            });
        }

        return val;

    }

};

/**
 *
 * The Schema Chainable functions
 *
 * @type {Object}
 *
 */
var SchemaChainableFns = {

    any: function(){
        this.any = true;
        this.schema = null;
    },

    strict: function(){
        this.strict = true;
    },

    string : function(val, obj){
        this.schema = "";
        this.required = true;
        this.any = false;
    },

    object : function(val, obj){
        obj = Safe.object(obj, {});
        this.schema = obj;
        this.required = true;
        this.any = false;
    },

    array : function(val, obj){
        obj = Safe.array(obj, []);
        this.schema = obj;
        this.required = true;
        this.any = false;
    },

    function : function(){
        this.schema = function(){};
        this.required = true;
        this.any = false;
    },

    number : function(){
        this.schema = 0;
        this.required = true;
        this.any = false;
    },

    boolean : function(){
        this.schema = Boolean(true);
        this.required = true;
        this.any = false;
    },

    default : function(val, defaultValue){
        this.default = defaultValue;
    },

    required : function(){
        this.required = true;
    },

    optional : function(){
        this.required = false;
    },

    repeatable: function(){
        this.repeatable = true;
    }

};

/**
 *
 * The default Custom Chainable Functions
 *
 * @type {Object}
 *
 */
var CustomChainableFns = {
    "min": require("./Assert/Min"),
    "max": require("./Assert/Max"),
    "regex": require("./Assert/Regex"),
};

/**
 *
 * The evaluation functions
 *
 * @type {Object}
 *
 */
var EvaluationFns = {

    /**
     *
     * Compile the rule and return the facade
     *
     * @return {SchemaEvaluator}
     *
     */
    compile: function(result, argument, err){

        /// throw error if there was some in the chain
        if(err){
            throw err;
        }

        return new SchemaEvaluator(this, argument, Internal.compileOptions);

    },

    /**
     *
     * Apply the schema rules and return the value.
     *
     * @throws {Error} If the value is invalid
     *
     * @param  {*}      result
     * @param  {Object} argument
     * @return {*}
     *
     */
    value: function(result, argument, err){

        /// throw error if there was some in the chain
        if(err){
            throw err;
        }

        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);
        return r.value(result);

    },

    /**
     *
     * Get the list of errors
     *
     * @param  {*}      result
     * @param  {Object} argument
     * @return {*}
     *
     */
    errors: function(result, argument, err){

        /// throw error if there was some in the chain
        if(err){
            throw err;
        }

        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);
        return r.errors(result);

    },

    /**
     *
     * Check if the object is valid
     *
     * @param  {*}      result
     * @param  {Object} argument
     * @return {Boolean}
     *
     */
    isValid: function(result, argument, err){

        /// throw error if there was some in the chain
        if(err) {
            throw err;
        }

        var r = new SchemaEvaluator(this, argument, Internal.compileOptions);
        return r.isValid(result);

    },

    /**
     *
     * Serialize the schema rule
     *
     * @return {Object}
     *
     */
    serialize: function(result, argument, err){

        var evaluator = new SchemaEvaluator(this, argument, Internal.compileOptions);
        return evaluator.serialize();

    },

    /**
     *
     * Deserialize from the schema from the given value.
     *
     * @return {SchemaEvaluator}
     *
     */
    deserialize: function(value, argument, err){

        var evaluator = new SchemaEvaluator(this, argument, Internal.compileOptions);
        return evaluator.deserialize(value);

    }

};

/**
 *
 * Schema Chain Facility
 *
 * @param {Object} customFns
 *
 *
 */
var Schema = function(customFns){

    customFns = Safe.object(customFns);

    /// get the Schema validation functions. This is an extension point
    /// for the schema validation.
    var validationFns = _.extend({}, customFns, CustomChainableFns);

    /// Get the current ChainContext of the assertion, in order
    /// to keep the assertion state.
    var chainContext = null;
    _.each(arguments, function(arg){
        if(arg instanceof ChainContext){
            chainContext = arg;
            return false;
        }
    });

    /// if there's no chain context initialize the default functions by
    /// wrapping them in a compatible API
    if(!chainContext){

        /// assign the default validation functions
        var schemaFns = _.extend({}, SchemaChainableFns);

        /// transform the custom validation functions, to use the Schema
        /// runner
        var wrappedFns = _.extend({}, CustomChainableFns, customFns);
        _.each(wrappedFns, function(fn, name){
            wrappedFns[name] = Internal.wrapValidationFunction(name);
        });

        /// give precedence to schemaFns
        customFns = _.extend(wrappedFns, schemaFns);

    }

    /// the chain options
    var chainOptions = {

        /// do not pipe the chainable fns objects
        pipe: false,

        /// Use the Schema type for each chaninable return statement
        type: Schema,

        /// set the scope for each chainable function execution.
        scope: function() {
            return new SchemaDefinition(null, { compile: false });
        },

        /// Evaluation argument. This argument will be present in every
        /// evalFn invocation without interfere with the chain scope.
        argument: validationFns

    };

    /// Inherit from Chains
    Chain.apply(this, [ customFns, EvaluationFns, chainOptions, chainContext ]);

    return new Types.Schema(this);

};

module.exports = Schema;

},{"./Assert/Max":30,"./Assert/Min":31,"./Assert/Regex":34,"./Chain":38,"./Chain/ChainContext":39,"./Safe":47,"./Schema/SchemaDefinition":54,"./Schema/SchemaEvaluator":55,"./Schema/Types":57,"./Type":58,"lodash":"lodash"}],42:[function(require,module,exports){
"use strict";

var _           = require("lodash"),
    Type        = require("../Type"),
    Safe        = require("../Safe"),
    I18NString  = require("../I18N/String"),
    Messages    = require("../I18N/Messages");


/**
 *
 * Internal methods
 *
 * @type {Object}
 *
 */
var Internal = {};

/**
 *
 * Get message
 *
 * @param  {Object} messages
 *
 * @return {I18NMessage}
 *
 */
Internal.getI18NMessage = function(message, messageData){

    messageData = Safe.object(messageData);

    if( message instanceof I18NString ){
        return message;
    }

    /// if message is null or empty
    if( Type.isString(message) ){
        return new I18NString(message, messageData, Messages);
    }

    return new I18NString("");

};

/**
 *
 * Get the stack trace
 *
 * @return {String}
 *
 */
Internal.getStackTrace = function(){

    var error    = new Error(),
        stackStr = Safe.string(error.stack),
        stack    = stackStr.split('\n');

    /// Remove Error message + 2 first lines of the stack trace
    stack.splice(0,3);

    return stack.join('\n');

};

/**
 *
 * @class Error Class
 *
 * @param {String|I18NString} message
 *
 */
var Exception = function(message, messageData) {

    message     = Internal.getI18NMessage(message, messageData);
    messageData = Safe.object(messageData);

    /// get the stack trace
    var stack = Internal.getStackTrace();

    /// define the error message
    Object.defineProperty(
        this,
        "message",
        {
            get: function(){
                return this.toString();
            },
            configurable: false
        }
    );

    /// define the this.stack to return the created Error
    /// stack
    Object.defineProperty(
        this,
        'stack', {
        get: function() {
            return this.toString() + "\n" + stack;
        },
        configurable: false
    });

    /**
     *
     * ToString method with i18n support
     *
     * @param  {Object} translations
     *
     * @return {String}
     *
     */
    this.toString = function(translations){
        return message.toString(translations);
    };

};

Exception.prototype = new Error();
Exception.prototype.constructor = Exception;

module.exports = Exception;

},{"../I18N/Messages":44,"../I18N/String":45,"../Safe":47,"../Type":58,"lodash":"lodash"}],43:[function(require,module,exports){
"use strict";

var _               = require("lodash"),
    Type            = require("../Type"),
    Safe            = require("../Safe"),
    Exception       = require("./Exception");

/**
 *
 * Get the stack trace
 *
 * @return {String}
 *
 */
var getStackTrace = function(){

    var error    = new Error(),
        stackStr = Safe.string(error.stack),
        stack    = stackStr.split('\n');

    /// Remove Error message + 2 first lines of the stack trace
    stack.splice(0,3);

    return stack.join('\n');

};

/**
 *
 * Error class that can contain multiple errors
 * @class
 *
 */
var ExceptionList = function() {

    /// instance of error
    var items  = [];

    /// get the stack trace
    var stack = getStackTrace();

    /// define the this.stack to return the created Error
    /// stack
    Object.defineProperty(
        this,
        'stack', {
        get: function() {
            return this.toString() + "\n" + stack;
        }
    });

    Object.defineProperty(
        this,
        "message",
        {
            get: function(){
                return this.toString();
            },
            configurable: false
        }
    );

    Object.defineProperty(
        this,
        "items",
        {
            get: function(){
                return _.clone(items);
            },
            configurable: false
        }
    );

    Object.defineProperty(
        this,
        "length",
        {
            get: function(){
                return items.length;
            },
            configurable: false
        }
    );

    /**
     *
     * Adds an element to the error list
     *
     * @throws {Error} If invalid argument
     *
     * @param {*} errors
     *
     */
    this.push = function(errors){

        var scope = this;

        /// if argument is an ExceptionList
        if(errors instanceof ExceptionList){
            errors = errors.items;
        }

        /// make sure errors is an array
        errors = Safe.array(errors);

        /// adds the elements to the list
        _.each(
            errors,
            function(error){

                /// if error is on string format add it as an Exception
                if( Type.isString(error) ){
                    error = new Exception(error);
                }

                if( !(error instanceof Error) ){
                    throw new Error("Expected instance of type Error");
                }

                items.push(error);

            });

    };

    /**
     *
     * Clear the error list
     *
     * @return
     *
     */
    this.clear = function(){
        while(items.length) items.pop();
    };

    /**
     *
     * ToString
     *
     * @param {Object} translations
     *
     * @return {String}
     *
     */
    this.toString = function(translations){

        var str         = "",
            length      = items.length,
            separator   = ", ";

        _.each(
            items,
            function(error, index){

                if(error instanceof Exception){
                    str += error.toString(translations);
                }
                else {
                    str += error.toString();
                }

                /// add the separator if its not the last element
                if(index != length-1){
                    str += separator;
                }

            });

        return str;

    };

};

ExceptionList.prototype = new Error();
ExceptionList.prototype.constructor = ExceptionList;


module.exports = ExceptionList;

},{"../Safe":47,"../Type":58,"./Exception":42,"lodash":"lodash"}],44:[function(require,module,exports){
"use strict";

var Messages = {};

/**
 *
 * Invalid value
 *
 * @type {String}
 *
 */
Messages.VALIDATION_INVALID_VALUE = "<%= value %> is invalid.";

/**
 *
 * Required value
 *
 * @type {String}
 */
Messages.VALIDATION_REQUIRED = "Value is required.";

/**
 *
 * Array expected
 *
 * @type {String}
 *
 */
Messages.VALIDATION_TYPE = "'<%= expected %>' was expected but found '<%= value %>' instead.";

/**
 *
 * Max exceed
 *
 * @type {String}
 *
 */
Messages.VALIDATION_MAX = "The maximum value allowed is <%= value %>.";

/**
 *
 * Min exceed
 *
 * @type {String}
 *
 */
Messages.VALIDATION_MIN = "The minimum value allowed is <%= value %>.";

/**
 *
 * Min exceed
 *
 * @type {String}
 *
 */
Messages.REGEXP = "Regular expression '<%= value %>' doesn't match.";

/**
 *
 * Invalid List lenght
 *
 * @type {String}
 *
 */
Messages.VALIDATION_INVALID_LIST_LENGTH = "Expected list with <%= expected %> items but found <%= value %>.";

/**
 *
 * Invalid List
 *
 * @type {String}
 *
 */
Messages.VALIDATION_INVALID_LIST_LENGTH_MULTIPLE_OF = "Expected list length to be multiple of <%= expected %> but found length of <%= value %>.";

/**
 *
 * Invalid List
 *
 * @type {String}
 *
 */
Messages.VALIDATION_INSTANCEOF = "Expected instance of '<%= value %>'.";

module.exports = Messages;

},{}],45:[function(require,module,exports){
"use strict";

var _       = require("lodash"),
    Safe    = require("../Safe");


/**
 *
 * Internal methdos
 *
 * @type {Object}
 *
 */
var Internal = {};

/**
 *
 * Apply the template. The scope of the function is the string.
 *
 * @throws {Error} If template data its missing or wrong
 *
 * @param  {String} name
 * @param  {Object} data
 * @param  {Object} messages
 * @param  {Object} customMessages
 *
 * @return {String}
 *
 */
Internal.applyTemplate = function(name, data, messages, customMessages){

    name            = Safe.string(name);
    data            = Safe.object(data);
    messages        = Safe.object(messages);
    customMessages  = Safe.object(customMessages);

    messages = _.extend({}, messages, customMessages);

    var tmplStr = Safe.string(messages[name]) || name;

    return _.template(tmplStr)(data);

};

/**
 *
 * Template String class. Each string is identified by a name. The template string
 * can be changed when calling toString.
 *
 * @param {String} name
 * @param {Object} data
 * @param {Object} messages
 *
 * @example
 * var str = new I18nString("asas", {}, {});
 *
 */
var I18NString = function(name, data, messages){

    name        = Safe.string(name);
    data        = Safe.object(data);
    messages    = Safe.object(messages);

    /**
     *
     * toString()
     *
     * @throws {Error} If template is not correct
     *
     * @param  {String} messages
     * @param  {Object} data
     * @return {String}
     *
     */
    this.toString = function(customMessages){

        try{

            return Internal.applyTemplate.apply(this, [ name, data, messages, customMessages ]);

        } catch(e){

            var error = _.template(
                "Error on template '<%= name %>': <%= error %>")({
                    name: name,
                    error: e.message
                });

            throw new Error(error);

        }

    };

    /// Initialize string by calling .super()
    String.call( this, this.toString() );

};

/// inherit from String
/* jshint -W053 */
I18NString.prototype = new String();
I18NString.prototype.constructor = I18NString;

module.exports = I18NString;

},{"../Safe":47,"lodash":"lodash"}],46:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    Safe        = require("./Safe");


var Obj = {

    /**
     *
     * Get the object keys. If a filter is specified it returns the keys
     * that match the filter regular expression.
     *
     * @param {Object}          obj
     * @param {String|RegExp}   filter
     *
     * @return {Array}
     *
     */
    filter: function(obj, filter){

        obj         = Safe.object(obj);
        filter      = Safe.regexp(filter, "/.*/");

        return _.transform(
            obj,
            function(result, val, key){

                if(filter.exec(key)){
                    result.push(key);
                }

                return result;

            },
            []);

    }

};

module.exports = Obj;
},{"./Safe":47,"lodash":"lodash"}],47:[function(require,module,exports){
'use strict';


var _       = require('lodash'),
    Type    = require('./Type');


var Internal = {};

/**
 *
 * The regular expression format
 *
 * @type {RegExp}
 *
 */
Internal.RegExpFormat = /^\/.*\/(\w*)$/;

/**
 *
 * Converts a strings to a RegExp
 *
 * @param  {String} str
 * @return {RegExp}
 */
Internal.stringToRegExp = function(str){

    str = Safe.string(str);

    var flags = "",
        regexp = Internal.RegExpFormat.exec(str);

    if(regexp){

        /// if the string is on // format remove the references
        str = str.replace(/^\//, "")
                .replace(/\/$/, "")
                .trim();

        flags = regexp[1];

    }
    else {
        /// strict search
        str = "^" + str + "$";
    }

    return new RegExp(str, flags);

};


var Safe = {};

/*
 * Safelly get array from value
 *
 * @param {*} value The value to get
 * @param {*} defaultValue The value to get
 *
 * @return {Array}
 *
 */
Safe.array = function(value, defaultValue){

    /// if value is null and there is a default value, then
    /// fallback
    /* jshint -W041 */
    if(value == null && defaultValue != null){
        return Safe.array(defaultValue);
    }

    var isArray = Type.isArray(value);

    /* jshint -W041 */
    if(!isArray && value != null){
        value = [value];
    }
    else if(!isArray && value == null){
        value = [];
    }

    return value;

};

/*
 * Safelly get Boolean from value
 *
 * @param {*} value The value to get
 *
 * @return {Boolean}
 *
 */
Safe.boolean = function(value, defaultValue){

    if(Type.isBoolean(value)){
        return Boolean(value);
    }

    /// fallback to the default value
    if(defaultValue !== undefined){
        return Safe.boolean(!!defaultValue);
    }

    /// if is Number
    if(Type.isNumber(value)){
        value = Number(value);
        return Boolean(value);
    }

    /// if is String
    if(Type.isString(value)){
        return !!value;
    }

    return !Type.isEmpty(value);

};


/*
 * Safelly get Boolean from value
 *
 * @param {*} value
 * @param {*} defaultValue
 *
 * @return {String}
 *
 */
Safe.string = function(value, defaultValue){

    if(Type.isString(value)){
        return value;
    }

    return defaultValue !== undefined ?
                Safe.string(defaultValue) : "";

};


/*
 * Safelly get Object from value
 *
 * @param {value}           The value to get
 * @param {defaultValue}    The default value
 *
 * @return {Object}
 *
 */
Safe.object = function(value, defaultValue){

    if(Type.isObject(value)){
        return value;
    }

    return defaultValue !== undefined ?
                Safe.object(defaultValue) : {};

};


/*
 * Safelly get Number from value
 *
 * @param {*} value The value to get
 * @param {*} defaultValue The default value
 *
 * @return {Number} The number or 0 if was not success
 *
 */
Safe.number = function(value, defaultValue){

    if(Type.isNumber(value)){
        return Number(value);
    }
    else {
        return  defaultValue !== undefined ?
                Safe.number(defaultValue) : 0;
    }

};


/*
 * Safelly get Function from value
 *
 * @param {*} value         The value to get
 * @param {*} defaultValue  The value to get
 *
 * @return {Function}
 *
 */
Safe.function = function(value, defaultValue){

    if(Type.isFunction(value)){
        return value;
    }

    if( Type.isFunction(defaultValue) ){
        value = defaultValue;
    }

    if(!value){
        value = function(){ };
    }

    return value;

};


/*
 * Safelly get the value. This never return undefined!
 *
 * @param {*} value         The value to get
 * @param {*} defaultValue  The value to get
 *
 * @return {*}
 *
 */
Safe.value = function(value, defaultValue){

    if(Type.isDefined(value)){
        return value;
    }

    if( Type.isDefined(defaultValue) ){
        return Safe.value(defaultValue);
    }

    return null;

};

/**
 *
 * Safelly gets an instance of the Class. If the value is an instance of Class
 * return it, otherwise return a new instance.
 *
 * @param  {Object} value
 * @param  {Function} Class
 * @param  {Array} args
 *
 * @return {Object}
 *
 */
Safe.instanceOf = function(value, Class){

    value   = Safe.object(value);
    Class   = Safe.function(Class);

    if( value instanceof Class )
    {
        return value;
    }
    else
    {
        return new Class();
    }

};


/**
 *
 * Safelly gets the RegExp
 *
 * @param {*} value
 * @param {*} defaultValue
 *
 * @return {}
 *
 */
Safe.regexp = function(value, defaultValue){

    if(Type.isString(value)){
        return Internal.stringToRegExp(value);
    }

    if(Type.isRegExp(value)){
        return value;
    }

    if(Type.isDefined(defaultValue)){
        return Safe.regexp(defaultValue);
    }

    return Internal.stringToRegExp();

};

/**
 *
 * Safelly get the length of the object
 *
 * @param {*} val
 *
 * @return {Number}
 */
Safe.length = function(val){

    if( Type.isString(val) || Type.isArray(val) ){
        return val.length;
    }

    if( Type.isObject(val) ){
        return _.keys(val).length;
    }

    if( Type.isNumber(val) ){
        return val;
    }

    if( Type.isBoolean(val) ){
        return val ? 1 : 0;
    }

    return 0;

};


/**
 *
 * Coerce the given value from the expected type
 *
 * @param  {*} value
 * @param  {*} expected
 * @return {*}
 *
 */
Safe.coerce = function(value, expected){

    var expectedType    = Type.of(expected),
        type            = Type.of(value);

    if(expectedType === type){
        return value;
    }

    // Expecting a number
    if( Type.isNumber(expected) ){

        if(Type.isNumber(value)){
            return Number(value);
        }

    }

    // Expecting a string
    if( Type.isString(expected) ){

        if(Type.isNumber(value)){
            return value.toString();
        }

    }

    // Expecting a boolean
    if(Type.isBoolean(expected)){

        /// try to get it from a number
        if(Type.isNumber(value)){

            value = Safe.number(value);
            if(value === 1){
                return Boolean(true);
            }
            else if(value === 0){
                return Boolean(false);
            }

        }
        /// try to get it from a string
        else if(Type.isString(value)){

            value = value.toLowerCase();

            if(value == "true"){
                return Boolean(true);
            }
            else if(value == "false"){
                return Boolean(false);
            }

        }

    }

    return value;

};

module.exports = Safe;

},{"./Type":58,"lodash":"lodash"}],48:[function(require,module,exports){
"use strict";

var Schema = require("./CustomSchema");

module.exports = new Schema();
},{"./CustomSchema":41}],49:[function(require,module,exports){
"use strict";


var _                 = require("lodash"),
    Assert            = require("../../Assert"),
    Types             = require("../Types");

/**
 *
 * Schema clone methods
 *
 * @type {Object}
 *
 */
var SchemaClone = function(Class){

    /**
     *
     * Clone the current schema. If `options` is defined it will override the
     * current instance data of the new SchemaDefinition.
     * 
     * @param  {Object} options
     * @return {Class}
     * 
     */
    this.clone = function(options){

        Assert.instanceOf(Types.SchemaDefinition)
            .assert(this);

        var instance = new Class(
            _.extend({}, this, options));

        return instance;

    };

};

module.exports = SchemaClone;


},{"../../Assert":27,"../Types":57,"lodash":"lodash"}],50:[function(require,module,exports){
"use strict";

var _                       = require("lodash"),
    Safe                    = require("../../Safe"),
    Type                    = require("../../Type"),
    Assert                  = require("../../Assert"),
    Exception               = require("../../Exception/Exception"),
    Types                   = require("../Types"),
    SchemaResult            = require("../SchemaResult"),
    SchemaExecutionHelper   = require("./SchemaExecutionHelper");

/**
 *
 * Iterate over the complex value
 *
 * @param  {SchemaDefinition} schema
 * @param  {*} value
 *
 * @return {SchemaResult}
 *
 */
var execute = function(schema, value, validationFns){

    /* jshint -W064 */
    var result = SchemaResult(schema, value);

    /// get the value from the schema
    try {
        value = SchemaExecutionHelper.prepareValue(schema, value, validationFns);
        result.setValue(value);
    }
    catch(e){
        result.addError(e);
        return result;
    }

    /// if value is null there's no need to iterate
    /* jshint -W041 */
    if(value == null){
        return result;
    }

    /// if is expecting any value return it straight away
    if(schema.any){
        return result;
    }

    /// if is not a complex value return the value
    if(!schema.isArray() && !schema.isObject()){
        return result;
    }

    /// prepare the schema for execution against the value. This will expand
    /// the schema to match the value
    try {
        schema = SchemaExecutionHelper.prepareSchema(schema, value, validationFns);
    }
    catch(e){
        result.addError(e);
        return result;
    }

    /// reset the result value before iterating
    result = SchemaResult(schema, schema.isObject() ? {} : []);

    /// recursion over the inner values of the schema
    _.each(schema.schema, function(innerSchema, key){

        /// recursive execute the schema
        var innerResult = innerSchema.execute(value[key], validationFns);

        /// add result to errors
        if(!innerResult.isValid()){
            result.addError(innerResult.getErrors());
            return;
        }

        /// get the inner result value
        var innerValue = innerResult.getValue();

        /// if is an object and value is not required ignore!
        if(schema.isObject() && innerValue == null && !innerSchema.required){
            return;
        }

        /// set the value
        result.setValue(innerValue, { index: key });

    });

    return result;

};

/**
 *
 * Schema execution methods.
 *
 * @type {Object}
 *
 */
var Execution = function(){

    /**
     *
     * Execute Schema against the value. This will perform a top-down recursion on
     * the given structure.
     *
     * @param {SchemaDefinition} schema
     * @param {*} value
     * @param {Object} options
     *
     * @return {SchemaResult}
     *
     */
    this.execute = function(value, validationFns){

        /// validate and normalize arguments
        Assert.instanceOf(Types.SchemaDefinition)
            .assert(this);

        /// if it has no errors iterate over the object
        var result = execute(this, value, validationFns);

        /// if there's error try to recover by applying the default value
        if(!result.isValid()){

            /// try to fallback to the default value if it can
            /* jshint -W041 */
            if(this.default != null){

                var dresult = execute(this, this.default, validationFns);

                /// if default value is valid use it, otherwise use the given
                /// value
                if(dresult.isValid()){
                    result = dresult;
                }

            }

        }

        return result;

    };

};

module.exports = Execution;


},{"../../Assert":27,"../../Exception/Exception":42,"../../Safe":47,"../../Type":58,"../SchemaResult":56,"../Types":57,"./SchemaExecutionHelper":51,"lodash":"lodash"}],51:[function(require,module,exports){
"use strict";

var _                   = require("lodash"),
    Safe                = require("../../Safe"),
    Type                = require("../../Type"),
    Assert              = require("../../Assert"),
    ExceptionList       = require("../../Exception/ExceptionList"),
    Exception           = require("../../Exception/Exception"),
    Types               = require("../Types");
    

/**
 *
 * Prepares and validates the SchemaDefinition for the given 
 * value.
 *
 * @throw {ExceptionList}
 *
 * @param  {SchemaDefinition} schema
 * @param  {*}      value
 * @param  {Object} validationFns
 *
 * @return {SchemaDefinition}
 *
 */
var prepareSchema = function(schema, value, validationFns){

    value           = Safe.value(value);
    validationFns   = Safe.object(validationFns);

    /* jshint -W064 */
    var errors = new ExceptionList();

    /// If not defined and its required throw
    /* jshint -W041 */
    if(schema.required && value == null){
        errors.push(
            new Exception("VALIDATION_REQUIRED"));
    }
    /* jshint -W041 */
    else if(!schema.required && value == null){
        /// continue (optional parameter)
    }
    /// check for compatibility of types if any flag is not used
    else if(!schema.any && Type.of(schema.schema) !== Type.of(value)){
        errors.push(
            new Exception("VALIDATION_TYPE", { expected: Type.of(schema.schema), value: Type.of(value) }));
    }

    /// if there's error throw them
    if(errors.length){
        throw errors;
    }

    return schema;

};

/**
 *
 * Prepares and validates the SchemaDefinition for the given 
 * object.
 *
 * @throws {ExceptionList} If a validation function occurs
 * 
 * @param  {SchemaDefinition} schema
 * @param  {Object} value
 *
 * @return {SchemaDefinition}
 *
 */
var prepareObject = function(schema, value){

    value = Safe.object(value);

    /* jshint -W064 */
    var errors      = new ExceptionList(),
        result      = {},
        valueKeys   = _.keys(value);

    _.each(
        schema.schema,
        function(schemaValue, key){

            var isRegExp = Type.isRegExpStr(key),
                keys     = [];

            /// key is not a regexp string
            if(!isRegExp){
                keys = [ key ];
            }
            else {
                /// key is a regexp string
                var regexp  = Safe.regexp(key);
                keys = _.filter(
                    valueKeys,
                    function(key){

                        /// if there's a definition of the schema don't include it
                        if(schema.schema[key] !== undefined){
                            return false;
                        }

                        /// test if the regex match
                        return !!regexp.exec(key);

                    });
            }

            _.each(keys, function(val) {
                result[val] = schemaValue;
            });

        });

    return schema.clone({
        schema: result
    });

};

/**
 *
 * Prepares and validates the SchemaDefinition for the given 
 * array.
 *
 * @throws {ExceptionList} If a validation error occurs
 *
 * @param  {SchemaDefinition} schema
 * @param  {Array} value
 *
 * @return {SchemaDefinition}
 *
 */
var prepareArray = function(schema, value){

    value = Safe.array(value);

    /* jshint -W064 */
    var errors  = new ExceptionList(),
        result  = [],
        index   = 0;

    if( !schema.repeatable && schema.schema.length != value.length ){
        errors.push(
            new Exception("VALIDATION_INVALID_LIST_LENGTH", { value: value.length, expected: schema.schema.length }));
    }

    if(schema.repeatable){

        var isRepeatable = true;

        /// if the value contains elements check if its divisible by 
        /// the repeat count
        if(value.length > 0 && value.length != schema.schema.length){
            isRepeatable = value.length % schema.schema.length === 0;
        }
        /// otherwise is only repeatable if the array contains no 
        /// element
        else {
            isRepeatable = (value.length === schema.schema.length) && (value.length === 0);
        }

        if(!isRepeatable){
            errors.push(
                new Exception("VALIDATION_INVALID_LIST_LENGTH_MULTIPLE_OF", { value: value.length, expected: schema.schema.length }));    
        }
        
    }

    /// if errors exist throw them
    if(errors.length){
        throw errors;
    }

    /// create the result array
    for(var i=0; i<value.length; i++){

        if(schema.repeatable && index >= schema.schema.length){
            index = 0;
        }

        result.push(schema.schema[index++]);

    }

    return schema.clone({
        schema: result
    });

};

/**
 *
 * Schema Conversion conversion methods
 * 
 * @type {Object}
 * 
 */
var SchemaExecutionHelper = {

    /**
     *
     * Get the value according to the given schema, by applying 
     * default values, coercing values, ...
     *
     * @throws {ExceptionList} If the validation fails
     * 
     * @param  {SchemaDefinition} schema
     * @param  {*} value
     *
     * @return {*}
     *
     */
    prepareValue: function(schema, value, validationFns){

        /// validate and normalize arguments
        Assert.instanceOf(Types.SchemaDefinition)
            .assert(schema);

        value = Safe.value(value);

        /// initalize the list of errors
        var errors = new ExceptionList();

        /// if not strict tries to normalize
        /// the value (e.g. a number can be on string representation )
        if(!schema.strict){
            value = Safe.coerce(value, schema.schema);
        }

        /// if the value is required and it has no value, throw error
        /* jshint -W041 */
        if(schema.required && value == null){
            errors.push(
                new Exception("VALIDATION_REQUIRED"));
        }
        else if(!schema.required && value == null){
            /// ignore, and not fallback on the other else's
        }
        /// if a value exists find out if types are compatible
        else if(!schema.any && Type.of(schema.schema) !== Type.of(value)){
            errors.push(
                new Exception("VALIDATION_TYPE", { expected: Type.of(schema.schema), value: Type.of(value) }));
        }

        /// always run if value is required or value is specified.
        if(schema.required || value !=null){

            _.each(
                schema.validations,
                function(v){

                    v = Safe.object(v);

                    var fn      = Safe.function(validationFns[v.name]),
                        args    = Safe.array(v.args);

                    try{
                        fn.apply({}, [value].concat(args));
                    }catch(e){
                        var error = new Exception(e.message);
                        errors.push(error);
                    }

            });

        }

        /// check if any error was detected
        if(errors.length){
            throw errors;
        }

        return value;

    },

    /**
     *
     * Gets the schema for the given value. If the schema is an object it 
     * will expand its keys regular expressions. If the schema is an array 
     * it will apply its properties to the given value.
     *
     * @throws {ExceptionList} If a validation error occurs
     *
     * @param  {SchemaDefinition} schema
     * @param  {*}      value
     * @param  {Object} validationFns
     * 
     * @return {SchemaDefinition}
     * 
     */
    prepareSchema: function(schema, value, validationFns){

        Assert.instanceOf(Types.SchemaDefinition)
            .assert(schema);

        /// prepare the schema
        schema = prepareSchema(schema, value, validationFns);

        /// prepare the object
        if(schema.isObject()){
            return prepareObject(schema, value);
        }
        /// prepare the array
        else if(schema.isArray()){
            return prepareArray(schema, value);
        }

        return schema;

    }

};

module.exports = SchemaExecutionHelper;

},{"../../Assert":27,"../../Exception/Exception":42,"../../Exception/ExceptionList":43,"../../Safe":47,"../../Type":58,"../Types":57,"lodash":"lodash"}],52:[function(require,module,exports){
"use strict";

var _       = require("lodash"),
    Safe    = require("../../Safe");

/**
 *
 * Serialization methods for SchemaDefinition.
 *
 * @scope {SchemaDefinition}
 * 
 * @type {Object}
 *
 */
var Serialization = function(){

    /**
     *
     * Serializes the schema definition.
     *
     * @return {Object}
     *
     */
    this.serialize = function(){
        return _.cloneDeep(this);
    };

    /**
     *
     * Deserializes the object into a SchemaDefinition
     *
     * @return {SchemaDefinition}
     *
     */
    this.deserialize = function(value){
        return new this.constructor(value);
    };

};

module.exports = Serialization;
},{"../../Safe":47,"lodash":"lodash"}],53:[function(require,module,exports){
"use strict";

var Type = require("../../Type");

/**
 *
 * Schema type methods
 *
 * @scope {SchemaDefinition}
 * 
 * @type {Object}
 *
 */
var SchemaType = function(){

    /**
     *
     * Checks if the schema is an array
     * 
     * @return {Boolean}
     * 
     */
    this.isArray = function(){
        return Type.isArray(this.schema);
    };

    /**
     *
     * Checks if the schema is an object
     * 
     * @return {Boolean}
     * 
     */
    this.isObject = function(){
        return Type.isObject(this.schema);
    };

};

module.exports = SchemaType;

},{"../../Type":58}],54:[function(require,module,exports){
"use strict";

var _               = require("lodash"),
    Types           = require("./Types"),
    Type            = require("../Type"),
    Safe            = require("../Safe"),
    Assert          = require("../Assert");

/**
 *
 * Default conversion between the value and a SchemaDefinition.
 * This converts a primitive value to a SchemaDefinition with defaults
 * value.
 *
 * @type {Object}
 *
 */
var Defaults = {

    array: function(value){

        if(!Type.isArray(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: value,
            required: true
        });

        return value;

    },

    object: function(value){

        if(!Type.isObject(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: value,
            required: true
        });

        return value;

    },

    string: function(value){

        if(!Type.isString(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: "",
            required: true
        });

        return value;

    },

    number: function(value){

        if(!Type.isNumber(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: 0,
            required: true
        });

        return value;

    },

    boolean: function(value){

        if(!Type.isBoolean(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: Boolean(value),
            required: true
        });

        return value;

    },

    function: function(value){

        if(!Type.isFunction(value)){
            return;
        }

        // no default value and its required!
        value = new SchemaDefinition({
            schema: function(){},
            required: true
        });

        return value;

    },

};

/**
 *
 * Normalize the schema value in order to avoid storing unnecessary 
 * data and keep the values consistent across usages.
 * 
 * @param  {String} value
 * @return {*}
 * 
 */
var normalizeSchemaValue = function(value){

    value = Safe.value(value);

    if(Type.isString(value)){
        return "";
    }

    if(Type.isNumber(value)){
        return 0;
    }

    if(Type.isBoolean(value)){
        return true;
    }

    return value;

};

/**
 *
 * Compile the given schema definition or compatible 
 * structure.
 *
 * @param {*}       schema
 * @param {Object}  options
 *
 * @return {SchemaDefinition}
 *
 */
var compile = function(schema, options){

    /// extensibility point - prepare the value before the 
    /// compilation
    schema = options.prepare(schema);

    /// apply the defaults and create the SchemaDefinition if an object 
    /// has been provided
    if(!Type.instanceOf(schema, Types.SchemaDefinition)){
        schema = Defaults.object(schema) || Defaults.array(schema) ||
                Defaults.string(schema) || Defaults.number(schema) ||
                Defaults.boolean(schema) || Defaults.function(schema);
    }

    /// convert the schema
    var isArray  = Type.isArray(schema.schema),
        isObject = Type.isObject(schema.schema);

    /// iterate over the structure in order to compile the schema
    if(isArray || isObject){

        _.each(schema.schema, function(val, index){
            var innerSchema = compile(val, options);
            schema.schema[index] = innerSchema;
        });

    }

    return schema;

};

/**
 *
 * A SchemaDefinition class. Contains all the rules that should be applied when
 * evaluating it against a value.
 *
 * @param {Object} options
 *
 */
var SchemaDefinition = function(options){

    options = Safe.object(options);

    /**
     *
     * SchemaDefinition module API
     * 
     * @type {Object}
     * 
     */
    var self = {

        /**
         *
         * The type of schema
         *
         * @type {SchemaDefinition}
         *
         */
        schema: normalizeSchemaValue(options.schema),

        /**
         *
         * Flag that enables strict convertion.
         *
         * @type {Boolean}
         *
         */
        strict: Safe.boolean(options.strict, false),

        /**
         *
         * Any flag. This means that any value is accepted.
         *
         * @type {Boolean}
         *
         */
        any: Safe.boolean(options.any, false),

        /**
         *
         * The default value of the schema
         *
         * @type {*}
         */
        default: options.default,

        /**
         *
         * IsRequired flag
         *
         * @type {Boolean}
         *
         */
        required: Safe.boolean(options.required, true),

        /**
         *
         * Repeatable flag. This means, e.g. if the schema is an array the inner schema can
         * be repeatable by elements.
         *
         * @type {Boolean}
         */
        repeatable: Safe.boolean(options.repeatable),

        /**
         *
         * The validation functions to apply to this Schema node. Each validation function is
         * represented by: { name: 'fn', args: '' }
         *
         * @type {Array}
         *
         */
        validations: Safe.array(options.validations),

    };

    return new Types.SchemaDefinition(self);

};

/**
 *
 * @class
 * A SchemaDefinition compiled class. This represents a fully compiled 
 * instance of all inner structures that represents a Schema.
 *
 * A full iteration over the entire schema structure will be performed.
 * 
 * @param {Object} options  The SchemaDefinition data 
 * @param {Object} cOptions The compilation options
 *
 */
var CompiledSchemaDefinition = function(options, cOptions){

    /// normalize the given compilation options
    cOptions = Safe.object(cOptions);
    cOptions.compile = Safe.boolean(cOptions.compile, true);
    cOptions.prepare = Safe.function(cOptions.prepare, function(v){ return v; });

    /* jshint -W064 */
    var schema = SchemaDefinition(options);

    /// traverse the schema structure compiling its inner elements
    if(cOptions.compile){
        return compile(schema, cOptions);    
    }
    
    return schema;

};

/// include type checking Mixin
require("./Mixins/SchemaType")
    .call(Types.SchemaDefinition.prototype);

/// include clone Mixin functionality
require("./Mixins/SchemaClone")
    .apply(Types.SchemaDefinition.prototype, [ CompiledSchemaDefinition ]);

/// include execution Mixin functionality
require("./Mixins/SchemaExecution")
    .call(Types.SchemaDefinition.prototype);

/// include serialization functionality
require("./Mixins/SchemaSerialization")
    .call(Types.SchemaDefinition.prototype);

module.exports = CompiledSchemaDefinition;

},{"../Assert":27,"../Safe":47,"../Type":58,"./Mixins/SchemaClone":49,"./Mixins/SchemaExecution":50,"./Mixins/SchemaSerialization":52,"./Mixins/SchemaType":53,"./Types":57,"lodash":"lodash"}],55:[function(require,module,exports){
"use strict";


var _                       = require("lodash"),
    Type                    = require("../Type"),
    Safe                    = require("../Safe"),
    ExceptionList           = require("../Exception/ExceptionList"),
    Types                   = require("./Types"),
    SchemaDefinition        = require("./SchemaDefinition");

/**
 *
 * @class
 * The schema evaluator facade. This will serve as interface to the Schema
 * execution.
 *
 * @param {*}       schema
 * @param {Object}  validationFns
 * @param {Object}  cOptions        The SchemaDefinition compilation options
 *
 */
var SchemaEvaluator = function(schema, validationFns, cOptions){

    /* jshint -W064 */
    /**
     *
     * The compiled schema
     *
     * @type {SchemaDefinition}
     * 
     */
    schema = SchemaDefinition(schema, cOptions);

    /**
     *
     * The custom validation functions
     *
     * @type {Object}
     *
     */
    validationFns = Safe.object(validationFns);

    /**
     *
     * SchemaEvaluator external API
     *
     * @type {Object}
     *
     */
    var self = {

        /**
         *
         * Evaluate and get the errors
         *
         * @param  {*}      value
         * @param  {Object} validationFns
         *
         * @return {[Error]}
         *
         */
        errors: function(value){

            var result = schema.execute(value, validationFns);
            return result.getErrors();

        },

        /**
         *
         * Tests if the schema is valid against the given value.
         *
         * @param  {*}  value
         *
         * @return {Boolean}
         *
         */
        isValid: function(value){

            var result = schema.execute(value, validationFns);
            return result.isValid();

        },

        /**
         *
         * Gets the value after applying the schema.
         *
         * @throws {ExceptionList}
         *
         * @param  {*} value
         *
         * @return {*}
         *
         */
        value: function(value){

            var result = schema.execute(value, validationFns);

            if(!result.isValid()){
                throw result.getErrors();
            }

            return result.getValue();

        },

        /**
         *
         * Serialize the current Schema
         *
         * @return {Object}
         *
         */
        serialize: function(){

            return schema.serialize();

        },

        /**
         *
         * Deserialize the value. Returns a new instance of SchemaEvaluator.
         *
         * @return {SchemaEvaluator}
         *
         */
        deserialize: function(value){

            /// use a prepare option that builds the SchemaDefinition to 
            /// avoid fallback on the Default object builder
            var cOptions = {
                prepare: function(val){
                    
                    /// make sure that that the return value is a SchemaDefinition
                    /// NOTE: don't compile the inner structures because the SchemaEvaluator will 
                    /// do it
                    if(!Type.instanceOf(val, Types.SchemaDefinition)){
                        return SchemaDefinition(val, { compile: false });    
                    }

                    return val;
                    
                }
            };

            return new SchemaEvaluator(value, validationFns, cOptions);

        }

    };

    return new Types.SchemaEvaluator(self);

};


module.exports = SchemaEvaluator;

},{"../Exception/ExceptionList":43,"../Safe":47,"../Type":58,"./SchemaDefinition":54,"./Types":57,"lodash":"lodash"}],56:[function(require,module,exports){
"use strict";

var Safe                = require("../Safe"),
    Type                = require("../Type"),
    Assert              = require("../Assert"),
    ExceptionList       = require("../Exception/ExceptionList"),
    Types               = require("./Types");

/**
 *
 * @class
 * Stores the result of a schema evaluation. It will keep reference to
 * the global structure and the evaluation tree as well.
 *
 * @param {*} schema
 * @param {*} value
 *
 *
 */
var SchemaResult = function(schema, value){

    /// validate schema
    Assert.instanceOf(Types.SchemaDefinition)
        .assert(schema);

    /// make sure its a value
    value = Safe.value(value);

    /**
     *
     * Top-down global error tracking
     *
     * @type {ExceptionList}
     *
     */
    var errors = new ExceptionList();

    /**
     *
     * SchemaResult API
     *
     * @type {Object}
     *
     */
    var self = {

        /**
         *
         * Get the errors
         *
         * @return {ExceptionList}
         *
         */
        getErrors: function(){
            return errors;
        },

        /**
         *
         * Add the given errors
         *
         * @param {ExceptionList} error
         *
         */
        addError: function(error){
            errors.push(error);
        },

        /**
         *
         * Checks if the result is valid
         *
         * @return {Boolean}
         *
         */
        isValid: function(){
            return errors.length === 0;
        },

        /**
         *
         * Get the value result.
         *
         * @return {*}
         *
         */
        getValue: function(){
            return value;
        },

        /**
         *
         * Set the value of the given index.
         *
         * @param {*} value
         * @param {Object} options
         *
         */
        setValue: function(val, options) {

            /// normalize val
            val = Safe.value(val);

            /// normalize options
            options = Safe.object(options);
            options.index   = Safe.value(options.index, null);

            if(options.index !== null){
                value[options.index] = val;
            }
            else {
                value = val;
            }

        }

    };

    /// expose module as 'Typed' SchemaResult instance
    return new Types.SchemaResult(self);

};

module.exports = SchemaResult;

},{"../Assert":27,"../Exception/ExceptionList":43,"../Safe":47,"../Type":58,"./Types":57}],57:[function(require,module,exports){
"use strict";

var _ = require("lodash");

/**
 *
 * List of internal Schema package Types.
 *
 * This is useful while using the revealing module pattern and wanting
 * at the same time to use strong type checking.
 *
 */
var Types = {

    /**
     *
     * @class
     * Schema
     *
     */
    Schema: function Schema(options){ _.extend(this, options); },

    /**
     *
     * @class
     * Schema
     *
     */
    SchemaDefinition: function SchemaDefinition(options){ _.extend(this, options); },

    /**
     *
     * @class
     * SchemaEvaluator
     *
     */
    SchemaEvaluator: function SchemaEvaluator(options){ _.extend(this, options); },

    /**
     *
     * @class
     * SchemaResult
     *
     */
    SchemaResult: function SchemaResult(options){ _.extend(this, options); },

    /**
     *
     * @class
     * SchemaResultNode
     *
     */
    SchemaResultNode: function SchemaResultNode(options){ _.extend(this, options); }

};

module.exports = Types;
},{"lodash":"lodash"}],58:[function(require,module,exports){
'use strict';

var Internal = {};

/**
 *
 * The regular expression format
 *
 * @type {RegExp}
 *
 */
Internal.RegExpFormat = /^\/.*\/(\w*)$/;



var Type = {};

/*
 * Get the type of the value
 * Possible values are: undefined, object, array, number, string
 *
 * @param{obj}
 * @return{string}
 *
 */
Type.of = function (obj) {

    var t = typeof obj;

    if(t == "object" && obj instanceof Array){
        return "array";
    }
    else if(t == "object" && typeof(obj) == "boolean"){
        return "boolean";
    }

    return t;
};


/*
 * Checks if the given value is an array
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isArray = function (value) {

    return (value instanceof Array);

};


/*
 * Checks if the given value is an array
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isBoolean = function (value) {

    return typeof(value) === "boolean";

};


/*
 * Checks if the given value is an array
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isFunction = function (value) {

    return typeof(value) === "function";

};


/*
 * Checks if the given value is a string
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isString = function (value) {

    return typeof(value) === "string" ||
           value instanceof String;         /// support to custom String declarations

};


/*
 * Checks if the given value is an object
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isObject = function (value) {

    // null or undefined values are objects, but we don't care
    /* jshint -W041 */
    if(value == null) return false;
    if(Type.isArray(value)) return false;

    return typeof(value) === "object";

};

/**
 * Checks if the given value is a regular expression
 *
 * @param  {*}          value
 * @return {Boolean}
 */
Type.isRegExp = function (value) {

    return (value instanceof RegExp);

};

/**
 * Is value on the regexp string format
 *
 * @param  {*}          value
 * @return {Boolean}
 *
 */
Type.isRegExpStr = function (value) {

    if(!Type.isString(value)){
        return false;
    }

    return !!Internal.RegExpFormat.exec(value);

};

/*
 * Checks if the given value is a number
 *
 * @param{value} value to check
 * @return True|False
 *
 */
Type.isNumber = function (value) {

    var type = typeof(value);
    if(type != "number" && type != "string"){
        return false;
    }

    /// empty strings are equal to 0
    if(type == "string" && !value){
        return false;
    }

    value = Number(value);
    return !isNaN(value);

};


/*
 * Test if the value is defined or not
 *
 * @param {void} value
 *
 * @return {Boolean}
 */
Type.isDefined = function(value){

    /* jshint -W041 */
    if(value != null){
        return true;
    }

    return false;

};

/**
 *
 * Test if value is instanceOf 'fn'
 *
 * @param {*} value
 * @param {*} fn
 * 
 * @return {Boolean}
 * 
 */
Type.instanceOf = function(value, fn){

    /// take care of javascript quirks first!
    
    if(Type.isString(value) && fn == String){
        return true;
    }
    else if(Type.isNumber(value) && fn == Number){
        return true;   
    }
    else if(Type.isBoolean(value) && fn == Boolean){
        return true;
    }

    return (value instanceof fn);
    
};

/**
 *
 * Tests if the value is Empty
 *
 * @param  {*}  value
 *
 * @return {Boolean}
 *
 */
Type.isEmpty = function(value){

    if( !Type.isDefined(value) ){

        return true;
    }

    if( Type.isString(value) ){

        return value === "";
    }

    if( Type.isObject(value) || Type.isArray(value) ){

        for (var key in value) {
            // cancel iteration because it has some data
            return false;
        }

        return true;

    }

    return false;

};


module.exports = Type;

},{}],59:[function(require,module,exports){
'use strict';

var _           = require("lodash"),
    UrlParser   = require("./Url/Parser");


/**
 *
 * @class
 * The Url object
 *
 * @param {[type]} url The Url
 *
 */
var Url = function(url){

    url = UrlParser.normalize(url);

    var _this = {

        /**
         * Tests if the url is absolute
         *
         * @return {Boolean}
         *
         */
        isAbsolute: function(){
            return UrlParser.isAbsolute(url);
        },

        /**
         * Gets the baseUrl
         *
         * @return {String}
         *
         */
        baseUrl: function(){
            return UrlParser.baseUrl(url);
        },

        /**
         * Gets the protocol
         *
         * @return {String}
         *
         */
        protocol: function(){
            return UrlParser.protocol(url);
        },

        /**
         * Gets the path of the url
         *
         * @return {String}
         *
         */
        path: function(){
            return UrlParser.path(url);
        },

        /**
         * Gets the file name
         * @return {String}
         */
        filename: function(){
            return UrlParser.filename(url);
        },

        /**
         * Gets the file path
         * @return {String}
         */
        filepath: function(){
            return UrlParser.filepath(url);
        },

        /**
         * Gets the path of the url
         *
         * @return {String}
         *
         */
        setPath: function(path){

            path = UrlParser.normalize(path);

            var isAbsolute = UrlParser.isAbsolute(path);
            if(isAbsolute){ return false; }

            if(path.indexOf("/") === 0){
                url = UrlParser.normalize( _this.baseUrl() + path );
            }
            else{
                url = UrlParser.normalize( _this.baseUrl() + _this.path() + path );
            }

            return true;

        },

        /**
         *
         * @return {[type]} [description]
         */
        toString: function(){
            return UrlParser.normalize(url);
        }

    };


    return _this;

};


module.exports = Url;

},{"./Url/Parser":60,"lodash":"lodash"}],60:[function(require,module,exports){
'use strict';


var _       = require("lodash"),
    Type    = require("../Type");


/// regular expression to get the baseUrl
var BaseUrlRegExStr = '^[a-z]+://[a-z.-]+(?::[0-9]+)?';
/// regular expression to get the protocol
var ProtocolRegExStr = '^([a-z]+)://';



var UrlParser = {

    /**
     * Normalize url
     *
     * @return{String} the current url
     */
    normalize: function(url) {
    
        if(!url) return "";

        /// replace all //// to a single slash
        url = url.replace(/\/+/g, "/");
        /// because previouly all // were replaced lets fix the protocol syntax (http://)
        url = url.replace(/:\//g, "://");

        return url;

    },

    /**
     * Test if the url is absolute
     * 
     * @return {Boolean}
     * 
     */
    isAbsolute: function(url){

        var regex = new RegExp(BaseUrlRegExStr, "i");
        return !! regex.exec(url);

    },

    /**
     * Gets the protocol of the url 
     * 
     * @param  {String} url
     * @return {String}
     */
    protocol: function(url){

        var regex = new RegExp(ProtocolRegExStr, "gi");
        var result = regex.exec(url);
        if(result) return result[1];
        
        return "";

    },

    /**
     * Returns the baseUrl for the given url
     * 
     * @param  {String} url
     * @return {String}
     */
    baseUrl: function(url){

        var regex = new RegExp(BaseUrlRegExStr, "i");

        var result = "",
            regexResult = regex.exec(url);

        if(regexResult){
            /// always add / at the end of baseUrl
            result = regexResult.shift() + "/";
        }

        return UrlParser.normalize(result);

    },

    /**
     * Get the path of the url
     * 
     * @param  {String} url
     * @return {String}
     */
    path: function(url){

        // sanitize input
        url = url || "";

        var baseUrl = UrlParser.baseUrl(url) || "";

        // remove the base url
        url = url.replace(baseUrl, "");

        // remove the last part of the url. this may be a "/"" or "filehandler"
        var urlParts = url.split("/");
        urlParts.pop();
        urlParts.push("");
        
        // join all
        url = urlParts.join("/");

        return UrlParser.normalize(url);
    },

    /**
     * Get the file name
     * 
     * @return {[type]} [description]
     * 
     */
    filename: function(url){

        // sanitize input
        url = url || "";

        var urlParts = url.split("/");
        
        var filename = urlParts.pop().replace(/\?.*$/, "");
        
        return filename;

    },


    /**
     * Gets the entire File Path
     * 
     * @param  {String} url
     * @return {String}
     */
    filepath: function(url){ 

        return UrlParser.normalize(
            UrlParser.baseUrl(url) + 
            UrlParser.path(url) + 
            UrlParser.filename(url));

    },

    /**
     * get's the query string part of the url
     *
     * @param{href} The full url or null to get the current
     * @param{separator} The url qs separator. Normally is ?
     * @return{String} The query string part of the url
     */
    queryString: function(href, separator) {

        href = href || "";
        separator = separator || '?';

        var hrefSplit = href.split(separator) || [];
        
        if(hrefSplit.length > 1){
            
            // query strin can be malformed like ?a=1&?b=2
            // we can fix this
            var qStringPart = hrefSplit.splice(1, hrefSplit.length-1);
            var qString = "";
            _.forEach(qStringPart, function(qs){
                qString += qs;
            });

            return qString;
        }

        return "";
    },

    /*
     * Parse query string from url
     *
     * @param{separator} The url qs separator. Normally is ?
     * @return An hash with all the query string key/value's
     */
    queryStringObj: function(href, separator) {
    
        href = href || "";

        var qString = UrlParser.queryString(href, separator),
            values = {};

        qString = decodeURI(qString || "");
        _.each(
            qString.split("&"),
            function(keyValue){

                // ignore if 
                if(!keyValue) return;

                var pair = keyValue.split("=");
                
                if(pair.length>1)
                    values[pair[0]] = pair[1];
                else
                    values[pair[0]] = true; // it's more easy to use on conditions
                    

            });

        return values;
    }



};

module.exports = UrlParser;

},{"../Type":58,"lodash":"lodash"}],61:[function(require,module,exports){
'use strict';

var Common = {

    /**
     *
     * Type utility
     *
     * @type {Object}
     *
     */
    Type: require("./Common/Type"),

    /**
     *
     * Safe utility
     *
     * @type {Object}
     *
     */
    Safe: require("./Common/Safe"),

    /**
     *
     * Array utility
     *
     * @type {Object}
     *
     */
    Arr: require("./Common/Arr"),

    /**
     *
     * Object utility
     *
     * @type {Object}
     *
     */
    Obj: require("./Common/Obj"),

    /**
     *
     * I18N utility
     *
     * @type {Object}
     *
     */
    I18N: {

        /**
         *
         * I18NString utility
         *
         * @type {I18NString}
         *
         */
        String: require("./Common/I18N/String"),

    },

    /**
     *
     * Exceptions package
     *
     * @type {Object}
     *
     */
    Exception: {

        /**
         *
         * Exception Class
         *
         * @type {Exception}
         *
         */
        Exception: require("./Common/Exception/Exception"),

        /**
         *
         * ExceptionList
         *
         * @type {ExceptionList}
         *
         */
        ExceptionList: require("./Common/Exception/ExceptionList"),

    },

    /**
     *
     * Url utility
     *
     * @type {Function}
     *
     */
    Url: require("./Common/Url"),

    /**
     *
     * Chain facility
     *
     * @type {Object}
     *
     */
    Chain: require("./Common/Chain"),

    /**
     *
     * Default Assertion instance utility. This provides access to the default
     * Assert functions.
     *
     * @type {Object}
     *
     */
    Assert: require("./Common/Assert"),

    /**
     *
     * Assertion utility
     *
     * @type {Function}
     *
     */
    Assertion: require("./Common/Assertion"),

    /**
     *
     * Schema utility
     *
     * @type {Object}
     *
     */
    Schema: require("./Common/Schema"),

    /**
     *
     * Custom Schema
     *
     * @type {Object}
     *
     */
    CustomSchema: require("./Common/CustomSchema"),


};

module.exports = Common;

},{"./Common/Arr":26,"./Common/Assert":27,"./Common/Assertion":37,"./Common/Chain":38,"./Common/CustomSchema":41,"./Common/Exception/Exception":42,"./Common/Exception/ExceptionList":43,"./Common/I18N/String":45,"./Common/Obj":46,"./Common/Safe":47,"./Common/Schema":48,"./Common/Type":58,"./Common/Url":59}],62:[function(require,module,exports){
"use strict";

var _       = require("lodash"),
    Divhide = require("./Index.js");

/**
 *
 * Specs main module.
 *
 * This exposes the specs that are on .readme folder. Note that the
 * spec files are included on the generated documentation
 *
 */
var SpecIndex = _.extend({}, Divhide, {

    /**
     *
     * Expose sub-modules. These will be used for unit-tests
     *
     * @type {Object}
     *
     */
    SubModules: {

        Url: {
            Parser: require("./Common/Url/Parser")
        },

        Assert: {
            Array: require("./Common/Assert/Array"),
            Max: require("./Common/Assert/Max"),
            Min: require("./Common/Assert/Min"),
            Number: require("./Common/Assert/Number"),
            Regex: require("./Common/Assert/Regex"),
            Required: require("./Common/Assert/Required"),
            String: require("./Common/Assert/String"),
            Object: require("./Common/Assert/Object"),
            InstanceOf: require("./Common/Assert/InstanceOf"),
        },

        Chain: {
            ChainContext: require("./Common/Chain/ChainContext"),
            ChainFunction: require("./Common/Chain/ChainFunction"),
        },

        Schema: {

            SchemaDefinition: require("./Common/Schema/SchemaDefinition"),

            Mixins: {
                SchemaExecution: require("./Common/Schema/Mixins/SchemaExecution"),
                SchemaExecutionHelper: require("./Common/Schema/Mixins/SchemaExecutionHelper")
            }

        }

    },

    Specs: {

        ArrExample                  : function() { require("../.readme/includes/Arr/ArrExample"); },
        AssertionExample            : function() { require("../.readme/includes/Assertion/AssertionExample"); },
        AssertExample               : function() { require("../.readme/includes/Assert/AssertExample"); },
        ChainExample                : function() { require("../.readme/includes/Chain/ChainExample"); },
        ExceptionDocExample         : function() { require("../.readme/includes/Exception/ExceptionDocExample"); },
        ExceptionListDocExample     : function() { require("../.readme/includes/Exception/ExceptionListDocExample"); },
        I18NStringDocExample        : function() { require("../.readme/includes/I18N/I18NStringDocExample"); },
        ObjExample                  : function() { require("../.readme/includes/Obj/ObjExample"); },
        SafeArrayExample            : function() { require("../.readme/includes/Safe/SafeArrayExample"); },
        SafeBooleanExample          : function() { require("../.readme/includes/Safe/SafeBooleanExample"); },
        SafeFunctionExample         : function() { require("../.readme/includes/Safe/SafeFunctionExample"); },
        SafeLengthExample           : function() { require("../.readme/includes/Safe/SafeLengthExample"); },
        SafeNumberExample           : function() { require("../.readme/includes/Safe/SafeNumberExample"); },
        SafeObjectExample           : function() { require("../.readme/includes/Safe/SafeObjectExample"); },
        SafeRegexExample            : function() { require("../.readme/includes/Safe/SafeRegexExample"); },
        SafeStringExample           : function() { require("../.readme/includes/Safe/SafeStringExample"); },
        SafeValueExample            : function() { require("../.readme/includes/Safe/SafeValueExample"); },
        SchemaAnyExample            : function() { require("../.readme/includes/Schema/SchemaAnyExample"); },
        SchemaArrayExample          : function() { require("../.readme/includes/Schema/SchemaArrayExample"); },
        SchemaNumberExample         : function() { require("../.readme/includes/Schema/SchemaNumberExample"); },
        SchemaObjectExample         : function() { require("../.readme/includes/Schema/SchemaObjectExample"); },
        SchemaOverview              : function() { require("../.readme/includes/Schema/SchemaOverview"); },
        SchemaStringExample         : function() { require("../.readme/includes/Schema/SchemaStringExample"); },
        SchemaSerializationExample  : function() { require("../.readme/includes/Schema/SchemaSerializationExample"); },
        TypeExample                 : function() { require("../.readme/includes/Type/TypeExample"); },

    }

});

module.exports = SpecIndex;

},{"../.readme/includes/Arr/ArrExample":1,"../.readme/includes/Assert/AssertExample":2,"../.readme/includes/Assertion/AssertionExample":3,"../.readme/includes/Chain/ChainExample":4,"../.readme/includes/Exception/ExceptionDocExample":5,"../.readme/includes/Exception/ExceptionListDocExample":6,"../.readme/includes/I18N/I18NStringDocExample":7,"../.readme/includes/Obj/ObjExample":8,"../.readme/includes/Safe/SafeArrayExample":9,"../.readme/includes/Safe/SafeBooleanExample":10,"../.readme/includes/Safe/SafeFunctionExample":11,"../.readme/includes/Safe/SafeLengthExample":12,"../.readme/includes/Safe/SafeNumberExample":13,"../.readme/includes/Safe/SafeObjectExample":14,"../.readme/includes/Safe/SafeRegexExample":15,"../.readme/includes/Safe/SafeStringExample":16,"../.readme/includes/Safe/SafeValueExample":17,"../.readme/includes/Schema/SchemaAnyExample":18,"../.readme/includes/Schema/SchemaArrayExample":19,"../.readme/includes/Schema/SchemaNumberExample":20,"../.readme/includes/Schema/SchemaObjectExample":21,"../.readme/includes/Schema/SchemaOverview":22,"../.readme/includes/Schema/SchemaSerializationExample":23,"../.readme/includes/Schema/SchemaStringExample":24,"../.readme/includes/Type/TypeExample":25,"./Common/Assert/Array":28,"./Common/Assert/InstanceOf":29,"./Common/Assert/Max":30,"./Common/Assert/Min":31,"./Common/Assert/Number":32,"./Common/Assert/Object":33,"./Common/Assert/Regex":34,"./Common/Assert/Required":35,"./Common/Assert/String":36,"./Common/Chain/ChainContext":39,"./Common/Chain/ChainFunction":40,"./Common/Schema/Mixins/SchemaExecution":50,"./Common/Schema/Mixins/SchemaExecutionHelper":51,"./Common/Schema/SchemaDefinition":54,"./Common/Url/Parser":60,"./Index.js":61,"lodash":"lodash"}]},{},[62])(62)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL0Fyci9BcnJFeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9Bc3NlcnQvQXNzZXJ0RXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvQXNzZXJ0aW9uL0Fzc2VydGlvbkV4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL0NoYWluL0NoYWluRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvRXhjZXB0aW9uL0V4Y2VwdGlvbkRvY0V4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL0V4Y2VwdGlvbi9FeGNlcHRpb25MaXN0RG9jRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvSTE4Ti9JMThOU3RyaW5nRG9jRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvT2JqL09iakV4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZUFycmF5RXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlQm9vbGVhbkV4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZUZ1bmN0aW9uRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlTGVuZ3RoRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlTnVtYmVyRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlT2JqZWN0RXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlUmVnZXhFeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9TYWZlL1NhZmVTdHJpbmdFeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9TYWZlL1NhZmVWYWx1ZUV4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL1NjaGVtYS9TY2hlbWFBbnlFeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9TY2hlbWEvU2NoZW1hQXJyYXlFeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9TY2hlbWEvU2NoZW1hTnVtYmVyRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2NoZW1hL1NjaGVtYU9iamVjdEV4YW1wbGUuanMiLCIucmVhZG1lL2luY2x1ZGVzL1NjaGVtYS9TY2hlbWFPdmVydmlldy5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvU2NoZW1hL1NjaGVtYVNlcmlhbGl6YXRpb25FeGFtcGxlLmpzIiwiLnJlYWRtZS9pbmNsdWRlcy9TY2hlbWEvU2NoZW1hU3RyaW5nRXhhbXBsZS5qcyIsIi5yZWFkbWUvaW5jbHVkZXMvVHlwZS9UeXBlRXhhbXBsZS5qcyIsInNyYy9Db21tb24vQXJyLmpzIiwic3JjL0NvbW1vbi9Bc3NlcnQuanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9BcnJheS5qcyIsInNyYy9Db21tb24vQXNzZXJ0L0luc3RhbmNlT2YuanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9NYXguanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9NaW4uanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9OdW1iZXIuanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9PYmplY3QuanMiLCJzcmMvQ29tbW9uL0Fzc2VydC9SZWdleC5qcyIsInNyYy9Db21tb24vQXNzZXJ0L1JlcXVpcmVkLmpzIiwic3JjL0NvbW1vbi9Bc3NlcnQvU3RyaW5nLmpzIiwic3JjL0NvbW1vbi9Bc3NlcnRpb24uanMiLCJzcmMvQ29tbW9uL0NoYWluLmpzIiwic3JjL0NvbW1vbi9DaGFpbi9DaGFpbkNvbnRleHQuanMiLCJzcmMvQ29tbW9uL0NoYWluL0NoYWluRnVuY3Rpb24uanMiLCJzcmMvQ29tbW9uL0N1c3RvbVNjaGVtYS5qcyIsInNyYy9Db21tb24vRXhjZXB0aW9uL0V4Y2VwdGlvbi5qcyIsInNyYy9Db21tb24vRXhjZXB0aW9uL0V4Y2VwdGlvbkxpc3QuanMiLCJzcmMvQ29tbW9uL0kxOE4vTWVzc2FnZXMuanMiLCJzcmMvQ29tbW9uL0kxOE4vU3RyaW5nLmpzIiwic3JjL0NvbW1vbi9PYmouanMiLCJzcmMvQ29tbW9uL1NhZmUuanMiLCJzcmMvQ29tbW9uL1NjaGVtYS5qcyIsInNyYy9Db21tb24vU2NoZW1hL01peGlucy9TY2hlbWFDbG9uZS5qcyIsInNyYy9Db21tb24vU2NoZW1hL01peGlucy9TY2hlbWFFeGVjdXRpb24uanMiLCJzcmMvQ29tbW9uL1NjaGVtYS9NaXhpbnMvU2NoZW1hRXhlY3V0aW9uSGVscGVyLmpzIiwic3JjL0NvbW1vbi9TY2hlbWEvTWl4aW5zL1NjaGVtYVNlcmlhbGl6YXRpb24uanMiLCJzcmMvQ29tbW9uL1NjaGVtYS9NaXhpbnMvU2NoZW1hVHlwZS5qcyIsInNyYy9Db21tb24vU2NoZW1hL1NjaGVtYURlZmluaXRpb24uanMiLCJzcmMvQ29tbW9uL1NjaGVtYS9TY2hlbWFFdmFsdWF0b3IuanMiLCJzcmMvQ29tbW9uL1NjaGVtYS9TY2hlbWFSZXN1bHQuanMiLCJzcmMvQ29tbW9uL1NjaGVtYS9UeXBlcy5qcyIsInNyYy9Db21tb24vVHlwZS5qcyIsInNyYy9Db21tb24vVXJsLmpzIiwic3JjL0NvbW1vbi9VcmwvUGFyc2VyLmpzIiwic3JjL0luZGV4LmpzIiwic3JjL1NwZWNJbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbnZhciBBcnIgPSBEaXZoaWRlLkFycjtcblxudmFyIHZhbHVlID0gQXJyLmluZGV4KFsxICwyLCAzXSwgMCk7XG5leHBlY3QodmFsdWUpLnRvQmUoMSk7XG5cbnZhciB2YWx1ZSA9IEFyci5pbmRleChbMSAsMiwgM10sIDEwKTtcbmV4cGVjdCh2YWx1ZSkudG9CZU51bGwoKTtcblxudmFyIGZpcnN0ID0gQXJyLmZpcnN0KFsxICwyLCAzXSk7XG5leHBlY3QoZmlyc3QpLnRvQmUoZmlyc3QpO1xuXG52YXIgbGFzdCA9IEFyci5sYXN0KFsxICwyLCAzXSk7XG5leHBlY3QobGFzdCkudG9CZSgzKTtcblxudmFyIGxlbmd0aCA9IEFyci5sZW5ndGgoWzEgLDIsIDNdKTtcbmV4cGVjdChsYXN0KS50b0JlKDMpO1xuXG52YXIgYXJyYXkgPSBbMSwgMiwgM107XG5BcnIuaW5zZXJ0KGFycmF5LCA0KTtcbmV4cGVjdChhcnJheSkudG9FcXVhbChbMSwgMiwgMywgNF0pO1xuXG52YXIgYXJyYXkgPSBBcnIuaW5zZXJ0KFsxICwyLCAzXSwgWzQsIDVdKTtcbmV4cGVjdChhcnJheSkudG9FcXVhbChbMSwgMiwgMywgNCwgNV0pO1xuXG52YXIgYXJyYXkgPSBBcnIuaW5zZXJ0KFsxICwyLCAzXSwgLTEsIDApO1xuZXhwZWN0KGFycmF5KS50b0VxdWFsKFstMSwgMSwgMiwgM10pO1xuXG52YXIgYXJyYXkgPSBbMSwgMiwgM107XG5BcnIucmVtb3ZlKGFycmF5LCAwKTtcbmV4cGVjdChhcnJheSkudG9FcXVhbChbMiwgM10pO1xuXG52YXIgYXJyYXkgPSBbMSwgMiwgM107XG5BcnIucmVtb3ZlKGFycmF5LCAwLCAyKTtcbmV4cGVjdChhcnJheSkudG9FcXVhbChbM10pO1xuIiwiXG52YXIgQXNzZXJ0ID0gRGl2aGlkZS5Bc3NlcnQ7XG5cbi8vLyBUZXN0IGlmIHRoZSB2YWx1ZSBpcyB2YWxpZFxudmFyIGlzVmFsaWQgPSBBc3NlcnQucmVxdWlyZWQoKVxuICAgIC5zdHJpbmcoKVxuICAgIC5yZWdleChcIl5NXCIpXG4gICAgLm1heCgxMClcbiAgICAubWluKDUpXG4gICAgLmlzVmFsaWQoXCJNYXJ5XCIpO1xuXG5leHBlY3QoaXNWYWxpZClcbiAgICAudG9CZShmYWxzZSk7XG5cblxuLy8vIFZhbGlkIGFzc2VydGlvbjpcbnZhciBvYmogPSBBc3NlcnQucmVxdWlyZWQoKVxuICAgIC5hcnJheSgpXG4gICAgLm1heCg1KVxuICAgIC5hc3NlcnQoWzEsIDIsIDQsIDVdKTtcblxuZXhwZWN0KG9iailcbiAgICAuZXF1YWxzKFsxLCAyLCA0LCA1XSk7XG5cblxuLy8vIEludmFsaWQgYXNzZXJ0aW9uOlxudmFyIGZuID0gZnVuY3Rpb24oKXtcblxuICAgIEFzc2VydC5yZXF1aXJlZCgpXG4gICAgICAgIC5hcnJheSgpXG4gICAgICAgIC5tYXgoMSkgLy8vIHdpbGwgYmUgb24gYXJyYXkgY29udGV4dFxuICAgICAgICAuYXNzZXJ0KFtcImZpcnN0XCIsIFwic2Vjb25kXCJdKTtcblxufTtcblxuZXhwZWN0KGZuKVxuICAgIC50b1Rocm93KCk7XG5cbiIsIlxuLy8vIEFzc2VydGlvbiBidWlsZGVyXG52YXIgQXNzZXJ0aW9uID0gRGl2aGlkZS5Bc3NlcnRpb247XG5cbi8vLyBDcmVhdGUgdGhlIGN1c3RvbSBBc3NlcnQgZmFjaWxpdHlcbnZhciBBc3NlcnQgPSBuZXcgQXNzZXJ0aW9uKHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVzdHMgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhcnRzV2l0aDogZnVuY3Rpb24odmFsLCBzdHIpe1xuXG4gICAgICAgIGlmKHZhbC5pbmRleE9mKHN0cikgIT09IDApe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9lcyBub3Qgc3RhcnRzIHdpdGggXCIgKyBzdHIpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG4vLy8gVGVzdCBpZiB0aGUgdmFsdWUgaXMgdmFsaWRcbnZhciBpc1ZhbGlkID0gQXNzZXJ0XG4gICAgICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgICAgICAgICAuc3RhcnRzV2l0aChcIk1hcnlcIilcbiAgICAgICAgICAgICAgICAuaXNWYWxpZChcIk1hcnkgYW5kIFBldGVyXCIpO1xuXG5leHBlY3QoaXNWYWxpZClcbiAgICAudG9CZSh0cnVlKVxuXG5cbi8vLyBBc3NlcnQgdmFsdWVcbnZhciB2YWx1ZSA9IEFzc2VydFxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgLnN0YXJ0c1dpdGgoXCJNYXJ5XCIpXG4gICAgICAgICAgICAuYXNzZXJ0KFwiTWFyeSBhbmQgUGV0ZXJcIik7XG5cbmV4cGVjdCh2YWx1ZSlcbiAgICAuZXF1YWxzKFwiTWFyeSBhbmQgUGV0ZXJcIik7XG5cbiIsIlxudmFyIENoYWluID0gRGl2aGlkZS5DaGFpbjtcblxuXG52YXIgTWF0aHMgPSBuZXcgQ2hhaW4oXG5cbiAgICAvLy8gdGhlIGNoYWluaW5nIGZuc1xuICAgIHtcbiAgICAgICAgc3VtOiBmdW5jdGlvbihpLGope1xuICAgICAgICAgICAgcmV0dXJuIGkgKyBqO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YjogZnVuY3Rpb24oaSwgail7XG4gICAgICAgICAgICByZXR1cm4gaSAtIGo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8vIHRoZSBldmFsdWF0aW9uIGZuc1xuICAgIHtcbiAgICAgICAgY2FsY3VsYXRlOiBmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vLyB0aGUgb3B0aW9uc1xuICAgIHtcblxuICAgICAgICAvLy8gaWYgdHJ1ZSB0aGUgcmV0dXJuIG9mIGEgZnVuY3Rpb24gaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAvLy8gaWYgZmFsc2UsIHRoZSBldmFsdWF0aW9uIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIGV2ZXJ5IGNoYWluIGZ1bmN0aW9uIChkZWZhdWx0KVxuICAgICAgICBwaXBlOiB0cnVlXG5cbiAgICB9KTtcblxuXG52YXIgdmFsdWUgPSBNYXRocy5zdW0oNSlcbiAgICAuc3ViKDMpXG4gICAgLnN1bSgxMClcbiAgICAuY2FsY3VsYXRlKDApO1xuXG5leHBlY3QodmFsdWUpXG4gICAgLnRvQmUoMTIpO1xuIiwiXG52YXIgRXhjZXB0aW9uID0gRGl2aGlkZS5FeGNlcHRpb24uRXhjZXB0aW9uO1xuXG4vLy8gdGhlIGV4dGVybmFsIHRyYW5zbGF0aW9uIGRhdGFcbnZhciBQb3J0dWd1ZXNlID0ge1xuICAgIFwiVGhlIG1heGltdW0gdmFsdWUgYWxsb3dlZCBpcyA8JT0gdmFsdWUgJT4uXCI6IFwiVmFsb3IgbcOheGltbyDDqSA8JT0gdmFsdWUgJT4uXCJcbn07XG5cbnZhciBlcnJvciA9IG5ldyBFeGNlcHRpb24oXG4gICAgXCJUaGUgbWF4aW11bSB2YWx1ZSBhbGxvd2VkIGlzIDwlPSB2YWx1ZSAlPi5cIixcbiAgICB7IHZhbHVlOiAxMCB9KTtcblxuLy8vIEV4Y2VwdGlvbiBpbnN0YW5jZSBpcyBhbiBlcnJvciFcbmV4cGVjdChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgIC5lcXVhbHModHJ1ZSk7XG5cbi8vLyBFeGNlcHRpb24gbWVzc2FnZVxuZXhwZWN0KGVycm9yLnRvU3RyaW5nKCkpXG4gICAgLmVxdWFscyhcIlRoZSBtYXhpbXVtIHZhbHVlIGFsbG93ZWQgaXMgMTAuXCIpO1xuXG4vLy8gSTE4TiBFeGNlcHRpb24gbWVzc2FnZVxuZXhwZWN0KGVycm9yLnRvU3RyaW5nKFBvcnR1Z3Vlc2UpKVxuICAgIC5lcXVhbHMoXCJWYWxvciBtw6F4aW1vIMOpIDEwLlwiKTtcbiIsIlxudmFyIEV4Y2VwdGlvbiAgICAgICA9IERpdmhpZGUuRXhjZXB0aW9uLkV4Y2VwdGlvbixcbiAgICBFeGNlcHRpb25MaXN0ICAgPSBEaXZoaWRlLkV4Y2VwdGlvbi5FeGNlcHRpb25MaXN0O1xuXG5cbnZhciBlcnJvcnMgPSBuZXcgRXhjZXB0aW9uTGlzdCgpO1xuXG4vLy8gaXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3JcbmV4cGVjdChlcnJvcnMgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAudG9FcXVhbCh0cnVlKTtcblxuLy8vIGFkZGluZyBlcnJvcnMgdG8gRXhjZXB0aW9uTGlzdCAoIHlvdSBjYW4gYWxzbyBtZXJnZSBvdGhlciBFeGNlcHRpb25MaXN0ISApXG5lcnJvcnMucHVzaCggbmV3IEV4Y2VwdGlvbihcIkVycm9yMVwiKSApO1xuZXJyb3JzLnB1c2goIG5ldyBFeGNlcHRpb24oXCJFcnJvcjJcIikgKTtcbmVycm9ycy5wdXNoKCBuZXcgRXhjZXB0aW9uKFwiRXJyb3IzXCIpICk7XG5cbi8vLyBnZXQgbGVuZ3RoIG9mIHRoZSBsaXN0XG5leHBlY3QoZXJyb3JzLmxlbmd0aClcbiAgICAudG9FcXVhbCgzKTtcblxuLy8vIGdldCBhbiBlcnJvciBmcm9tIHRoZSBsaXN0XG5leHBlY3QoZXJyb3JzLml0ZW1zWzBdLnRvU3RyaW5nKCkpXG4gICAgLnRvRXF1YWwoXCJFcnJvcjFcIik7XG5cbi8vLyBnZXQgdGhlIHRyYW5zbGF0ZWQgZXJyb3JcbmV4cGVjdChlcnJvcnMudG9TdHJpbmcoeyBcIkVycm9yMVwiOiBcIkVycm9yIDFcIiwgXCJFcnJvcjJcIjogXCJFcnJvciAyXCIsIFwiRXJyb3IzXCI6IFwiRXJyb3IgM1wiIH0pKVxuICAgIC50b0VxdWFsKFwiRXJyb3IgMSwgRXJyb3IgMiwgRXJyb3IgM1wiKTtcblxuIiwiXG52YXIgSTE4TlN0cmluZyA9IERpdmhpZGUuSTE4Ti5TdHJpbmc7XG5cbi8vLyB0aGUgZXh0ZXJuYWwgdHJhbnNsYXRpb24gZGF0YVxudmFyIFBvcnR1Z3Vlc2UgPSB7XG4gICAgXCJoZWxsbyA8JT0gdXNlcm5hbWUgJT5cIjogXCJvbMOhIDwlPSB1c2VybmFtZSAlPlwiXG59O1xuXG4vLy8gY3JlYXRlIGEgSTE4TlN0cmluZyAobWVzc2FnZSArIGRhdGEpXG52YXIgbWVzc2FnZSA9IG5ldyBJMThOU3RyaW5nKFwiaGVsbG8gPCU9IHVzZXJuYW1lICU+XCIsIHsgdXNlcm5hbWU6IFwib3NjYXJcIiB9KTtcblxuLy8vIEdldHMgdGhlIEVuZ2xpc2ggbWVzc2FnZVxudmFyIGVuID0gbWVzc2FnZS50b1N0cmluZygpO1xuZXhwZWN0KGVuKVxuICAgIC50b0JlKFwiaGVsbG8gb3NjYXJcIik7XG5cbi8vLyBHZXRzIHRoZSBQb3J0dWd1ZXNlIG1lc3NhZ2VcbnZhciBlbiA9IG1lc3NhZ2UudG9TdHJpbmcoUG9ydHVndWVzZSk7XG5leHBlY3QoZW4pXG4gICAgLnRvQmUoXCJvbMOhIG9zY2FyXCIpOyIsIlxudmFyIE9iaiA9IERpdmhpZGUuT2JqO1xuXG52YXIgcmVzdWx0cyA9IE9iai5maWx0ZXIoeyBcIm9uZVwiOiAxLCBcInR3b1wiOiAyIH0pO1xuZXhwZWN0KHJlc3VsdHMpXG4gICAgLnRvRXF1YWwoW1wib25lXCIsIFwidHdvXCJdKTtcblxudmFyIHJlc3VsdHMgPSBPYmouZmlsdGVyKHsgXCJvbmVcIjogMSwgXCJ0d29cIjogMiB9LCBcIm9uZVwiKTtcbmV4cGVjdChyZXN1bHRzKVxuICAgIC50b0VxdWFsKFtcIm9uZVwiXSk7XG5cblxudmFyIHJlc3VsdHMgPSBPYmouZmlsdGVyKHsgXCJvbmVcIjogMSwgXCJ0d29cIjogMiB9LCBcInRocmVlXCIpO1xuZXhwZWN0KHJlc3VsdHMpXG4gICAgLnRvRXF1YWwoW10pOyIsIlxudmFyIFNhZmUgPSBEaXZoaWRlLlNhZmU7XG5cbnZhciB2YWx1ZSA9IFNhZmUuYXJyYXkoMSk7XG5leHBlY3QodmFsdWUpXG4gICAgLmVxdWFscyhbMV0pO1xuXG52YXIgdmFsdWUgPSBTYWZlLmFycmF5KDEpO1xuZXhwZWN0KHZhbHVlKVxuICAgIC5lcXVhbHMoWzFdKTtcblxudmFyIHZhbHVlID0gU2FmZS5hcnJheShbMSwgMl0pO1xuZXhwZWN0KHZhbHVlKVxuICAgIC5lcXVhbHMoWzEsIDJdKTtcblxudmFyIHZhbHVlID0gU2FmZS5hcnJheShudWxsLCBbIDEsIDIgXSk7XG5leHBlY3QodmFsdWUpXG4gICAgLmVxdWFscyhbMSwgMl0pO1xuXG52YXIgdmFsdWUgPSBTYWZlLmFycmF5KFwiMVwiLCBbMSwgMl0pO1xuZXhwZWN0KHZhbHVlKVxuICAgIC5lcXVhbHMoW1wiMVwiXSk7XG4iLCJcbnZhciBTYWZlID0gRGl2aGlkZS5TYWZlO1xuXG52YXIgdmFsdWUgPSBTYWZlLmJvb2xlYW4odHJ1ZSk7XG5leHBlY3QodmFsdWUpLnRvQmUodHJ1ZSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUuYm9vbGVhbihmYWxzZSk7XG5leHBlY3QodmFsdWUpLnRvQmUoZmFsc2UpO1xuXG52YXIgdmFsdWUgPSBTYWZlLmJvb2xlYW4oMSk7XG5leHBlY3QodmFsdWUpLnRvQmUodHJ1ZSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUuYm9vbGVhbihcIjFcIik7XG5leHBlY3QodmFsdWUpLnRvQmUodHJ1ZSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUuYm9vbGVhbihcIjBcIik7XG5leHBlY3QodmFsdWUpLnRvQmUoZmFsc2UpO1xuXG52YXIgdmFsdWUgPSBTYWZlLmJvb2xlYW4oe30pO1xuZXhwZWN0KHZhbHVlKS50b0JlKGZhbHNlKTtcblxudmFyIHZhbHVlID0gU2FmZS5ib29sZWFuKHt9LCB0cnVlKTtcbmV4cGVjdCh2YWx1ZSkudG9CZSh0cnVlKTtcblxudmFyIHZhbHVlID0gU2FmZS5ib29sZWFuKFtdKTtcbmV4cGVjdCh2YWx1ZSkudG9CZShmYWxzZSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUuYm9vbGVhbihudWxsKTtcbmV4cGVjdCh2YWx1ZSkudG9CZShmYWxzZSk7XG4iLCJcbnZhciBTYWZlID0gRGl2aGlkZS5TYWZlO1xuXG52YXIgZm4gPSBTYWZlLmZ1bmN0aW9uKGZ1bmN0aW9uKCl7fSk7XG5leHBlY3QoZm4oKSlcbiAgICAudG9CZSh1bmRlZmluZWQpO1xuXG52YXIgZm4gPSBTYWZlLmZ1bmN0aW9uKFwiXCIpO1xuZXhwZWN0KGZuKCkpXG4gICAgLnRvQmUodW5kZWZpbmVkKTtcblxudmFyIGZuID0gU2FmZS5mdW5jdGlvbihcIlwiLCBmdW5jdGlvbigpeyByZXR1cm4gMTsgfSk7XG5leHBlY3QoZm4oKSlcbiAgICAudG9CZSgxKTtcbiIsIlxudmFyIFNhZmUgPSBEaXZoaWRlLlNhZmU7XG5cbnZhciB2YWx1ZSA9IFNhZmUubGVuZ3RoKFsxLCAyXSk7XG5leHBlY3QodmFsdWUpLnRvQmUoMik7XG5cbnZhciB2YWx1ZSA9IFNhZmUubGVuZ3RoKHsgb25lOiAxLCB0d286IDJ9KTtcbmV4cGVjdCh2YWx1ZSkudG9CZSgyKTtcblxudmFyIHZhbHVlID0gU2FmZS5sZW5ndGgoMik7XG5leHBlY3QodmFsdWUpLnRvQmUoMik7XG5cbnZhciB2YWx1ZSA9IFNhZmUubGVuZ3RoKFwiaGVsbG9cIik7XG5leHBlY3QodmFsdWUpLnRvQmUoNSk7XG4iLCJcbnZhciBTYWZlID0gRGl2aGlkZS5TYWZlO1xuXG52YXIgdmFsdWUgPSBTYWZlLm51bWJlcigxKTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKDEpO1xuXG52YXIgdmFsdWUgPSBTYWZlLm51bWJlcihcIlwiKTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKDApO1xuXG52YXIgdmFsdWUgPSBTYWZlLm51bWJlcihcIjFcIik7XG5leHBlY3QodmFsdWUpLmVxdWFscygxKTtcblxudmFyIHZhbHVlID0gU2FmZS5udW1iZXIoe30pO1xuZXhwZWN0KHZhbHVlKS5lcXVhbHMoMCk7XG5cbnZhciB2YWx1ZSA9IFNhZmUubnVtYmVyKFwiXCIsIDEpO1xuZXhwZWN0KHZhbHVlKS5lcXVhbHMoMSk7XG4iLCJcbnZhciBTYWZlID0gRGl2aGlkZS5TYWZlO1xuXG52YXIgdmFsdWUgPSBTYWZlLm9iamVjdCh7IG9uZTogMSB9KTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKHsgb25lOiAxIH0pO1xuXG52YXIgdmFsdWUgPSBTYWZlLm9iamVjdChbXSk7XG5leHBlY3QodmFsdWUpLmVxdWFscyh7fSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUub2JqZWN0KFtdLCB7IG9uZTogMSB9KTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKHsgb25lOiAxIH0pO1xuXG4iLCJcbnZhciBTYWZlID0gRGl2aGlkZS5TYWZlO1xuXG52YXIgdmFsdWUgPSBTYWZlLnJlZ2V4cCgvcmVnZXhwLyk7XG5leHBlY3QodmFsdWUpXG4gICAgLnRvRXF1YWwoL3JlZ2V4cC8pO1xuXG52YXIgdmFsdWUgPSBTYWZlLnJlZ2V4cChcIi9yZWdleHAvXCIpO1xuZXhwZWN0KHZhbHVlKVxuICAgIC50b0VxdWFsKC9yZWdleHAvKTtcblxudmFyIHZhbHVlID0gU2FmZS5yZWdleHAoXCJcIik7XG5leHBlY3QodmFsdWUpXG4gICAgLnRvRXF1YWwoL14kLyk7XG5cbnZhciB2YWx1ZSA9IFNhZmUucmVnZXhwKFwibmFtZVwiKTtcbmV4cGVjdCh2YWx1ZSlcbiAgICAudG9FcXVhbCgvXm5hbWUkLyk7XG5cbnZhciB2YWx1ZSA9IFNhZmUucmVnZXhwKHt9LCAvcmVnZXhwLyk7XG5leHBlY3QodmFsdWUpXG4gICAgLnRvRXF1YWwoL3JlZ2V4cC8pO1xuIiwiXG52YXIgU2FmZSA9IERpdmhpZGUuU2FmZTtcblxudmFyIHZhbHVlID0gU2FmZS5zdHJpbmcoXCJcIik7XG5leHBlY3QodmFsdWUpLnRvQmUoXCJcIik7XG5cbnZhciB2YWx1ZSA9IFNhZmUuc3RyaW5nKHt9KTtcbmV4cGVjdCh2YWx1ZSkudG9CZShcIlwiKTtcblxudmFyIHZhbHVlID0gU2FmZS5zdHJpbmcoe30sIFwiZGVmYXVsdFwiKTtcbmV4cGVjdCh2YWx1ZSkudG9CZShcImRlZmF1bHRcIik7XG5cbiIsIlxudmFyIFNhZmUgPSBEaXZoaWRlLlNhZmU7XG5cbnZhciB2YWx1ZSA9IFNhZmUudmFsdWUoMSk7XG5leHBlY3QodmFsdWUpLnRvQmUoMSk7XG5cbnZhciB2YWx1ZSA9IFNhZmUudmFsdWUoXCIxXCIpO1xuZXhwZWN0KHZhbHVlKS50b0JlKFwiMVwiKTtcblxudmFyIHZhbHVlID0gU2FmZS52YWx1ZShudWxsKTtcbmV4cGVjdCh2YWx1ZSkudG9CZShudWxsKTtcblxudmFyIHZhbHVlID0gU2FmZS52YWx1ZSh1bmRlZmluZWQpO1xuZXhwZWN0KHZhbHVlKS50b0JlKG51bGwpO1xuXG52YXIgdmFsdWUgPSBTYWZlLnZhbHVlKG51bGwsIDEpO1xuZXhwZWN0KHZhbHVlKS50b0JlKDEpO1xuXG4iLCJcbnZhciBTY2hlbWEgPSBEaXZoaWRlLlNjaGVtYTtcblxudmFyIHNjaGVtYSA9IFNjaGVtYVxuICAgICAgICAgICAgLmFueSgpXG4gICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgLmNvbXBpbGUoKTtcblxuXG4vLy8gdmFsaWQgc3RyaW5nIHZhbHVlIVxudmFyIHZhbHVlID0gc2NoZW1hLnZhbHVlKFwic3RyXCIpO1xuZXhwZWN0KHZhbHVlKS5lcXVhbHModmFsdWUpO1xuXG5cbi8vLyB2YWxpZCBhcnJheSB2YWx1ZSFcbnZhbHVlID0gc2NoZW1hLnZhbHVlKFsxLDJdKTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKFsxLDJdKTtcblxuXG4vLy8gYmVjYXVzZSBpdHMgcmVxdWlyZWQgaXQgZmFpbHNcbmV4cGVjdChcbiAgICBmdW5jdGlvbigpe1xuICAgICAgICBzY2hlbWEudmFsdWUobnVsbCk7XG4gICAgfSlcbiAgICAudG9UaHJvdyhcbiAgICAgICAgbmV3IEVycm9yKFwiVmFsdWUgaXMgcmVxdWlyZWQuXCIpXG4gICAgKTsiLCJcbnZhciBTY2hlbWEgPSBEaXZoaWRlLlNjaGVtYTtcblxuXG4vLy8gQXJyYXkgc2NoZW1hICggbm8gcmVwZWF0YWJsZSlcbnZhciBzY2hlbWEgPSBTY2hlbWFcbiAgICAuYXJyYXkoWyBTY2hlbWEuc3RyaW5nKCkuZGVmYXVsdChcInZhbHVlXCIpLCBTY2hlbWEubnVtYmVyKCksIFNjaGVtYS5zdHJpbmcoKSBdKVxuICAgIC5vcHRpb25hbCgpXG4gICAgLmNvbXBpbGUoKTtcblxuXG4vLy8gYmVjYXVzZSBpdHMgb3B0aW9uYWwgaXQgcmV0dXJucyBudWxsXG52YXIgdmFsdWUgPSBzY2hlbWEudmFsdWUoKTtcbmV4cGVjdCh2YWx1ZSkudG9CZShudWxsKTtcblxuXG4vLy8gVGhlIHZhbHVlIGlzIHJpZ2h0IVxudmFsdWUgPSBzY2hlbWEudmFsdWUoWyAnMScsIDIsICczJyBdKTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKFsgJzEnLCAyLCAnMyddKTtcblxuXG4vLy8gYXJyYXkgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4gaXQgc2hvdWxkXG5leHBlY3QoXG4gICAgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NoZW1hLnZhbHVlKFsgJzEnLCAyLCAnMycsIDQsIDUsIDYgXSlcbiAgICB9KVxuICAgIC50b1Rocm93KFxuICAgICAgICBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsaXN0IHdpdGggMyBpdGVtcyBidXQgZm91bmQgNi5cIilcbiAgICApO1xuXG5cbi8vLyBXcm9uZyB0eXBlIVxuZXhwZWN0KFxuICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNjaGVtYS52YWx1ZSgxMCk7XG4gICAgfSlcbiAgICAudG9UaHJvdyhcbiAgICAgICAgbmV3IEVycm9yKFwiJ2FycmF5JyB3YXMgZXhwZWN0ZWQgYnV0IGZvdW5kICdudW1iZXInIGluc3RlYWQuXCIpXG4gICAgKTtcblxuXG4vLy9cbi8vLyBKdXN0IGFub3RoZXIgd2F5IHRvIHdyaXRlIHRoZSBydWxlIVxuLy8vXG5cblxudmFyIHNjaGVtYSA9IFNjaGVtYVxuICAgIC5hcnJheShbIFNjaGVtYS5zdHJpbmcoKSwgU2NoZW1hLm51bWJlcigpIF0pXG4gICAgLnJlcGVhdGFibGUoKVxuICAgIC5vcHRpb25hbCgpXG4gICAgLmNvbXBpbGUoKTtcblxuXG4vLyBHZXQgdGhlIHZhbHVlXG52YXIgdmFsdWUgPSBzY2hlbWEudmFsdWUoW1wiMVwiLCAyLCBcIjNcIiwgNF0pO1xuZXhwZWN0KHZhbHVlKS5lcXVhbHMoW1wiMVwiLCAyLCBcIjNcIiwgNF0pO1xuXG5cbi8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBpdGVtIG9uIHRoZSBhcnJheSBtdXN0IGJlIG11bHRpcGxlIG9mIDJcbi8vIGFuIGVycm9yIGlzIHRocm93blxuZXhwZWN0KFxuICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNjaGVtYS52YWx1ZShbXCIxXCIsIDIsIFwiM1wiXSlcbiAgICB9KVxuICAgIC50b1Rocm93KFxuICAgICAgICBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsaXN0IGxlbmd0aCB0byBiZSBtdWx0aXBsZSBvZiAyIGJ1dCBmb3VuZCBsZW5ndGggb2YgMy5cIilcbiAgICApO1xuXG4iLCJcbnZhciBTY2hlbWEgPSBEaXZoaWRlLlNjaGVtYTtcblxudmFyIHNjaGVtYSA9IFNjaGVtYS5udW1iZXIoKVxuICAgICAgICAgICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgICAgICAgICAgLm1pbigzKVxuICAgICAgICAgICAgICAgIC5tYXgoNSlcbiAgICAgICAgICAgICAgICAuY29tcGlsZSgpO1xuXG5cbi8vLyB2YWx1ZSBpcyBjb3JyZWN0XG52YXIgdmFsdWUgPSBzY2hlbWEudmFsdWUoMyk7XG5leHBlY3QodmFsdWUpLnRvQmUoMyk7XG5cblxuLy8vIG9wdGlvbmFsIHZhbHVlXG52YXIgdmFsdWUgPSBzY2hlbWEudmFsdWUoKTtcbmV4cGVjdCh2YWx1ZSkuZXF1YWxzKG51bGwpO1xuXG5cbi8vLyB2YWx1ZSBpcyB1bmRlZmluZWRcbmV4cGVjdChcbiAgICBmdW5jdGlvbigpe1xuICAgICAgICBzY2hlbWEudmFsdWUoMCk7XG4gICAgfSlcbiAgICAudG9UaHJvdyhcbiAgICAgICAgbmV3IEVycm9yKFwiVGhlIG1pbmltdW0gdmFsdWUgYWxsb3dlZCBpcyAzLlwiKVxuICAgICk7XG5cblxuLy8vIHZhbHVlcyBleGNlZWQgdGhlIG1heFxuZXhwZWN0KFxuICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNjaGVtYS52YWx1ZSgxMCk7XG4gICAgfSlcbiAgICAudG9UaHJvdyhcbiAgICAgICAgbmV3IEVycm9yKFwiVGhlIG1heGltdW0gdmFsdWUgYWxsb3dlZCBpcyA1LlwiKVxuICAgICk7XG5cblxuLy8vIGJlY2F1c2UgaXMgb3B0aW9uYWwsIGlzIHZhbGlkIVxudmFyIGlzVmFsaWQgPSBzY2hlbWEuaXNWYWxpZCgpO1xuZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG5cblxuaXNWYWxpZCA9IHNjaGVtYS5pc1ZhbGlkKDMpO1xuZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG5cblxuaXNWYWxpZCA9IHNjaGVtYS5pc1ZhbGlkKDEwKTtcbmV4cGVjdChpc1ZhbGlkKS50b0JlKGZhbHNlKTtcblxuIiwiXG52YXIgU2NoZW1hID0gRGl2aGlkZS5TY2hlbWE7XG5cbnZhciBzY2hlbWEgPVxuICAgICAgICBTY2hlbWEub2JqZWN0KHtcbiAgICAgICAgICAgIFwiL15vcHRpb25hbC9cIiAgIDogU2NoZW1hLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBcIm51bWJlclwiICAgICAgICA6IDAsXG4gICAgICAgICAgICBcInN0cmluZ1wiICAgICAgICA6IFwiXCIsXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXF1aXJlZCgpXG4gICAgICAgIC8vLyBUSVA6IFdoZW4gY29tcGlsZWQgdGhlIHNjaGVtYSBpcyBmYXN0ZXJcbiAgICAgICAgLmNvbXBpbGUoKTtcblxuXG4vLy8gbGV0J3MgZ2V0IHRoZSBvYmplY3RcbnZhciB2YWx1ZSA9IHNjaGVtYS52YWx1ZSh7XG4gICAgc3RyaW5nICAgICAgOiBcImF3ZXNvbWUhXCIsXG4gICAgbnVtYmVyICAgICAgOiBcIjBcIixcbiAgICBvcHRpb25hbDEgICA6IFwiMVwiLFxuICAgIG9wdGlvbmFsMiAgIDogXCIyXCIsXG4gICAgb3RoZXIgICAgICAgOiAxXG59KTtcblxuXG4vLy8gUGxlYXNlIG5vdGljZSB0aGF0IHNvbWUgb2YgdGhlIG9iamVjdCBwcm9wZXJ0aWVzIHdlcmVcbi8vLyBub3QgaW5jbHVkZWQhXG5leHBlY3QodmFsdWUpLmVxdWFscyh7XG4gICAgXCJudW1iZXJcIjogMCxcbiAgICBcInN0cmluZ1wiOiBcImF3ZXNvbWUhXCIsXG4gICAgXCJvcHRpb25hbDFcIjogXCIxXCIsXG4gICAgXCJvcHRpb25hbDJcIjogXCIyXCJcbn0pO1xuXG4iLCJcbnZhciBTY2hlbWEgPSBEaXZoaWRlLlNjaGVtYTtcblxuXG4vLy8gZ2V0IHRoZSBzY2hlbWFcbnZhciBzY2hlbWEgPSBTY2hlbWEub2JqZWN0KHtcblxuICAgICAgICAvLy8gYXJyYXkgd2l0aCBtdWx0aXBsZSBzdHJpbmdzXG4gICAgICAgIGRhdGE6IFNjaGVtYS5hcnJheShbIFwiXCIgXSkucmVwZWF0YWJsZSgpLm1heCgxMCksXG5cbiAgICAgICAgLy8vIGV2ZXJ5IG90aGVyIG9iamVjdCBrZXkgaXMgb3B0aW9uYWxcbiAgICAgICAgXCIvLiovXCI6IFNjaGVtYS5udW1iZXIoKS5vcHRpb25hbCgpXG5cbiAgICB9KS5yZXF1aXJlZCgpO1xuXG5cbi8vLyBhcHBseSB0aGUgc2NoZW1hIHRvIHRoZSB2YWx1ZVxudmFyIHZhbHVlID0gc2NoZW1hLnZhbHVlKHtcbiAgICBkYXRhOiBbIDEsIDIsIDMsIDQsIDUsIDZdLFxuICAgIHRpbWVzdGFtcDogXCIxNDA0MzczNTc5NDczXCJcbn0pO1xuXG5cbi8vLyB0ZXN0IHRoZSB2YWx1ZVxuZXhwZWN0KHZhbHVlKS5lcXVhbHMoe1xuICAgIGRhdGE6IFsgJzEnLCAnMicsICczJywgJzQnLCAnNScgLCAnNiddLFxuICAgIHRpbWVzdGFtcDogMTQwNDM3MzU3OTQ3M1xufSk7IiwiXG52YXIgU2NoZW1hID0gRGl2aGlkZS5TY2hlbWE7XG5cblxuLy8vIFN0cmluZyBzY2hlbWFcbnZhciBzY2hlbWEgPSBTY2hlbWEuc3RyaW5nKClcbiAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgICAgIC5taW4oMylcbiAgICAgICAgICAgICAgICAubWF4KDUpO1xuXG5cbi8vLyByZXR1cm5zIHRoZSB2YWx1ZVxudmFyIHZhbHVlID0gc2NoZW1hLnZhbHVlKFwiaGVsbG9cIik7XG5leHBlY3QodmFsdWUpLnRvQmUoXCJoZWxsb1wiKTtcblxuXG4vLy8gdmFsdWUgaXMgcmVxdWlyZWQhXG5leHBlY3QoXG4gICAgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NoZW1hLnZhbHVlKCk7XG4gICAgfSlcbiAgICAudG9UaHJvd0Vycm9yKFwiVmFsdWUgaXMgcmVxdWlyZWQuLCBUaGUgbWluaW11bSB2YWx1ZSBhbGxvd2VkIGlzIDMuXCIpO1xuXG5cbi8vLyB2YWx1ZSBpcyByZXF1aXJlZCFcbmV4cGVjdChcbiAgICBmdW5jdGlvbigpe1xuICAgICAgICBzY2hlbWEudmFsdWUoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICB9KVxuICAgIC50b1Rocm93KG5ldyBFcnJvcihcIlRoZSBtYXhpbXVtIHZhbHVlIGFsbG93ZWQgaXMgNS5cIikpO1xuXG5cbi8vLyBDaGVjayBpZiBpcyB2YWxpZFxudmFyIGlzVmFsaWQgPSBzY2hlbWEuaXNWYWxpZChcIlwiKTtcbmV4cGVjdChpc1ZhbGlkKS50b0JlKGZhbHNlKTtcblxuXG52YXIgaXNWYWxpZCA9IHNjaGVtYS5pc1ZhbGlkKFwiaGVsbG9cIik7XG5leHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcblxuXG52YXIgaXNWYWxpZCA9IHNjaGVtYS5pc1ZhbGlkKFwiaGVsbG8gd29ybGRcIik7XG5leHBlY3QoaXNWYWxpZCkudG9CZShmYWxzZSk7XG5cbiIsIlxudmFyIFNjaGVtYSA9IERpdmhpZGUuU2NoZW1hO1xuXG52YXIgc2VyaWFsaXplZCA9XG4gICAgICAgIFNjaGVtYS5vYmplY3Qoe1xuICAgICAgICAgICAgXCJuYW1lXCIgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBcImZyaWVuZHNcIiAgIDogU2NoZW1hLmFycmF5KFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKS5vcHRpb25hbCgpLFxuICAgICAgICB9KVxuICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAuc2VyaWFsaXplKCk7XG5cbi8vLyBkZXNlcmlhbGl6ZSB0aGUgb2JqZWN0XG52YXIgc2NoZW1hID0gU2NoZW1hLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpO1xuXG4vLy8gbGV0J3MgZ2V0IHRoZSBvYmplY3RcbnZhciB2YWx1ZSA9IHNjaGVtYS52YWx1ZSh7XG4gICAgaWQ6IDEsXG4gICAgbmFtZTogXCJPc2NhclwiLFxuICAgIGZyaWVuZHM6IFt7IG5hbWU6IFwiU29sYW5nZVwiIH1dXG59KTtcblxuZXhwZWN0KHZhbHVlKS5lcXVhbHMoe1xuICAgIG5hbWU6IFwiT3NjYXJcIixcbiAgICBmcmllbmRzOiBbeyBuYW1lOiBcIlNvbGFuZ2VcIiB9XVxufSk7XG5cbiIsIlxudmFyIFR5cGUgPSBEaXZoaWRlLlR5cGU7XG5cbnZhciB0eXBlID0gVHlwZS5vZih7fSk7XG5leHBlY3QodHlwZSkudG9CZShcIm9iamVjdFwiKTtcblxudmFyIHR5cGUgPSBUeXBlLm9mKFtdKTtcbmV4cGVjdCh0eXBlKS50b0JlKFwiYXJyYXlcIik7XG5cbnZhciB0eXBlID0gVHlwZS5vZigxKTtcbmV4cGVjdCh0eXBlKS50b0JlKFwibnVtYmVyXCIpO1xuXG52YXIgdHlwZSA9IFR5cGUub2YoXCJuYW1lXCIpO1xuZXhwZWN0KHR5cGUpLnRvQmUoXCJzdHJpbmdcIik7XG5cbnZhciB0eXBlID0gVHlwZS5vZih0cnVlKTtcbmV4cGVjdCh0eXBlKS50b0JlKFwiYm9vbGVhblwiKTtcblxudmFyIGlzQXJyYXkgPSBUeXBlLmlzQXJyYXkoW10pO1xuZXhwZWN0KGlzQXJyYXkpLnRvQmUodHJ1ZSk7XG5cbnZhciBpc0Jvb2xlYW4gPSBUeXBlLmlzQm9vbGVhbih0cnVlKTtcbmV4cGVjdChpc0Jvb2xlYW4pLnRvQmUodHJ1ZSk7XG5cbnZhciBpc0Z1bmN0aW9uID0gVHlwZS5pc0Z1bmN0aW9uKGZ1bmN0aW9uKCl7fSk7XG5leHBlY3QoaXNGdW5jdGlvbikudG9CZSh0cnVlKTtcblxudmFyIGlzU3RyaW5nID0gVHlwZS5pc1N0cmluZyhcIlwiKTtcbmV4cGVjdChpc1N0cmluZykudG9CZSh0cnVlKTtcblxudmFyIGlzT2JqZWN0ID0gVHlwZS5pc09iamVjdCh7fSk7XG5leHBlY3QoaXNPYmplY3QpLnRvQmUodHJ1ZSk7XG5cbnZhciBpc09iamVjdCA9IFR5cGUuaXNPYmplY3QobnVsbCk7XG5leHBlY3QoaXNPYmplY3QpLnRvQmUoZmFsc2UpO1xuXG52YXIgaXNSZWdFeHAgPSBUeXBlLmlzUmVnRXhwKC9yZWcvKTtcbmV4cGVjdChpc1JlZ0V4cCkudG9CZSh0cnVlKTtcblxudmFyIGlzTnVtYmVyID0gVHlwZS5pc051bWJlcigxKTtcbmV4cGVjdChpc051bWJlcikudG9CZSh0cnVlKTtcblxudmFyIGlzTnVtYmVyID0gVHlwZS5pc051bWJlcihcIjEuMVwiKTtcbmV4cGVjdChpc051bWJlcikudG9CZSh0cnVlKTtcblxudmFyIGlzRGVmaW5lZCA9IFR5cGUuaXNEZWZpbmVkKG51bGwpO1xuZXhwZWN0KGlzRGVmaW5lZCkudG9CZShmYWxzZSk7XG5cbnZhciBpc0RlZmluZWQgPSBUeXBlLmlzRGVmaW5lZCh1bmRlZmluZWQpO1xuZXhwZWN0KGlzRGVmaW5lZCkudG9CZShmYWxzZSk7XG5cbnZhciBpc0VtcHR5ID0gVHlwZS5pc0VtcHR5KFwiXCIpO1xuZXhwZWN0KGlzRW1wdHkpLnRvQmUodHJ1ZSk7XG5cbnZhciBpc0VtcHR5ID0gVHlwZS5pc0VtcHR5KFtdKTtcbmV4cGVjdChpc0VtcHR5KS50b0JlKHRydWUpO1xuXG52YXIgaXNFbXB0eSA9ICBUeXBlLmlzRW1wdHkoe30pO1xuZXhwZWN0KGlzRW1wdHkpLnRvQmUodHJ1ZSk7XG5cbnZhciBpc0VtcHR5ID0gIFR5cGUuaXNFbXB0eShudWxsKTtcbmV4cGVjdChpc0VtcHR5KS50b0JlKHRydWUpO1xuXG52YXIgaXNTdHJpbmcgPSBUeXBlLmluc3RhbmNlT2YoXCJzdHJpbmdcIiwgU3RyaW5nKTtcbmV4cGVjdChpc1N0cmluZykudG9CZSh0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcbiAgICBUeXBlICAgICAgICA9IHJlcXVpcmUoXCIuL1R5cGVcIiksXHJcbiAgICBTYWZlICAgICAgICA9IHJlcXVpcmUoXCIuL1NhZmVcIik7XHJcblxyXG5cclxuXHJcbnZhciBBcnIgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgaW5kZXggdmFsdWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGluZGV4OiBmdW5jdGlvbihhcnJheSwgaW5kZXgpe1xyXG5cclxuICAgICAgICBhcnJheSA9IFNhZmUuYXJyYXkoYXJyYXkpO1xyXG4gICAgICAgIGluZGV4ID0gU2FmZS5udW1iZXIoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZihpbmRleCA8IDAgfHwgaW5kZXggPiBhcnJheS5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEdldCBsYXN0IHZhbHVlIG9mIHRoZSBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBsYXN0OiBmdW5jdGlvbihhcnJheSl7XHJcblxyXG4gICAgICAgIGFycmF5ID0gU2FmZS5hcnJheShhcnJheSk7XHJcblxyXG4gICAgICAgIHJldHVybiBBcnIuaW5kZXgoYXJyYXksIGFycmF5Lmxlbmd0aCAtIDEpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgICAqIEdldCBmaXJzdCB2YWx1ZSBvZiB0aGUgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKGFycmF5KXtcclxuXHJcbiAgICAgICAgcmV0dXJuIEFyci5pbmRleChhcnJheSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGxlbmd0aDogZnVuY3Rpb24oYXJyYXkpe1xyXG5cclxuICAgICAgICBhcnJheSA9IFNhZmUuYXJyYXkoYXJyYXkpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogSW5zZXJ0cyB0aGUgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIGFycmF5XHJcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgaW5kZXgpe1xyXG5cclxuICAgICAgICBhcnJheSA9IFNhZmUuYXJyYXkoYXJyYXkpO1xyXG4gICAgICAgIHZhbHVlID0gU2FmZS5hcnJheSh2YWx1ZSk7XHJcblxyXG4gICAgICAgIC8qIGpzaGludCAtVzA0MSAqL1xyXG4gICAgICAgIGlmKGluZGV4ID09IG51bGwpe1xyXG4gICAgICAgICAgICBpbmRleCA9IEFyci5sZW5ndGgoYXJyYXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gU2FmZS5udW1iZXIoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWVyZ2UgdGhlIHN0cnVjdHVyZXNcclxuICAgICAgICBfLmVhY2goXHJcbiAgICAgICAgICAgIHZhbHVlLnJldmVyc2UoKSxcclxuICAgICAgICAgICAgZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgICAqIFJlbW92ZSBpbmRleCBvZiB0aGUgYXJyYXkuIElmIG5vIGluZGV4IGlzIHNwZWNpZmllZCB0aGUgZmlyc3RcclxuICAgICAqIGVsZW1lbnQgaXMgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgaW5kZXhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgaW5kZXhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihhcnJheSwgaW5kZXgsIG4pe1xyXG5cclxuICAgICAgICBhcnJheSAgID0gU2FmZS5hcnJheShhcnJheSk7XHJcbiAgICAgICAgaW5kZXggICA9IFNhZmUubnVtYmVyKGluZGV4LCAwKTtcclxuICAgICAgICBuICAgICAgID0gU2FmZS5udW1iZXIobiwgMSk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheS5zcGxpY2UoaW5kZXgsIG4pO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcnI7XHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQXNzZXJ0aW9uID0gcmVxdWlyZShcIi4vQXNzZXJ0aW9uXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQXNzZXJ0aW9uKCk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUeXBlICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxyXG4gICAgRXhjZXB0aW9uICAgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uL0V4Y2VwdGlvblwiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUZXN0IGlmIHZhbHVlIGlzIGFuIGFycmF5XHJcbiAqXHJcbiAqIEB0aHJvd3Mge0V4Y2VwdGlvbn1cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWxcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqXHJcbiAqL1xyXG52YXIgQXJyID0gZnVuY3Rpb24odmFsKXtcclxuXHJcbiAgICB2YXIgdiA9IFR5cGUuaXNBcnJheSh2YWwpO1xyXG5cclxuICAgIGlmKCF2KXtcclxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVkFMSURBVElPTl9UWVBFXCIsIHsgdmFsdWU6IFR5cGUub2YodmFsKSwgZXhwZWN0ZWQ6IFR5cGUub2YoW10pIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWw7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcnI7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBUeXBlICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxuICAgIEV4Y2VwdGlvbiAgID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbi9FeGNlcHRpb25cIik7XG5cbi8qKlxuICpcbiAqIEdldCBmdW5jdGlvbiBuYW1lXG4gKiBcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3RyaW5nfVxuICogXG4gKi9cbnZhciBnZXRGbk5hbWUgPSBmdW5jdGlvbihmdW4pIHtcblxuXHR2YXIgcmV0ID0gZnVuLnRvU3RyaW5nKCk7XG5cdHJldCA9IHJldC5zdWJzdHIoJ2Z1bmN0aW9uICcubGVuZ3RoKTtcblx0cmV0ID0gcmV0LnN1YnN0cigwLCByZXQuaW5kZXhPZignKCcpKTtcblx0cmV0dXJuIHJldDtcblxufTtcblxuXG4vKipcbiAqXG4gKiBJbnN0YW5jZU9mIGFzc2VydGlvbi4gXG4gKlxuICogQHRocm93cyB7RXhjZXB0aW9ufVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBcbiAqIEByZXR1cm4geyp9XG4gKlxuICovXG52YXIgSW5zdGFuY2VPZiA9IGZ1bmN0aW9uKHZhbCwgdmFsdWUpe1xuXG5cdC8vLyB0ZXN0IHdpdGggaW5zdGFuY2VvZlxuXHRpZighVHlwZS5pbnN0YW5jZU9mKHZhbCwgdmFsdWUpKXtcblx0XHR0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVkFMSURBVElPTl9JTlNUQU5DRU9GXCIsIHsgdmFsdWU6IGdldEZuTmFtZSh2YWx1ZSkgfSk7XG5cdH1cblxuICAgIHJldHVybiB2YWw7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zdGFuY2VPZjtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcbiAgICBUeXBlICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxyXG4gICAgU2FmZSAgICAgICAgPSByZXF1aXJlKFwiLi4vU2FmZVwiKSxcclxuICAgIEV4Y2VwdGlvbiAgID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbi9FeGNlcHRpb25cIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUZXN0IHRoZSBtYXggbGVuZ3RoIG9mIGFueSBraW5kIG9mIG9iamVjdFxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFeGNlcHRpb259XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAqIEByZXR1cm4geyp9XHJcbiAqXHJcbiAqL1xyXG52YXIgTWF4ID0gZnVuY3Rpb24odmFsLCBtYXgpe1xyXG5cclxuICAgIG1heCA9IFNhZmUubnVtYmVyKG1heCk7XHJcbiAgICB2YXIgbGVuZ3RoID0gU2FmZS5sZW5ndGgodmFsKTtcclxuXHJcbiAgICBpZihsZW5ndGggPiBtYXgpe1xyXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX01BWFwiLCB7IHZhbHVlOiBtYXggfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbDtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1heDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuICAgIFR5cGUgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIiksXHJcbiAgICBTYWZlICAgICAgICA9IHJlcXVpcmUoXCIuLi9TYWZlXCIpLFxyXG4gICAgRXhjZXB0aW9uICAgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uL0V4Y2VwdGlvblwiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUZXN0IHRoZSBtaW4gbGVuZ3RoIG9mIGFueSBraW5kIG9mIG9iamVjdFxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFeGNlcHRpb259XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAqIEByZXR1cm4geyp9XHJcbiAqXHJcbiAqL1xyXG52YXIgTWluID0gZnVuY3Rpb24odmFsLCBtaW4pe1xyXG5cclxuICAgIG1pbiA9IFNhZmUubnVtYmVyKG1pbik7XHJcbiAgICB2YXIgbGVuZ3RoID0gU2FmZS5sZW5ndGgodmFsKTtcclxuXHJcbiAgICBpZihsZW5ndGggPCBtaW4pe1xyXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX01JTlwiLCB7IHZhbHVlOiBtaW4gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbDtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1pbjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFR5cGUgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIiksXHJcbiAgICBFeGNlcHRpb24gICA9IHJlcXVpcmUoXCIuLi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFRlc3QgaWYgdmFsdWUgaXMgYSBudW1iZXJcclxuICpcclxuICogQHRocm93cyB7RXhjZXB0aW9ufVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqXHJcbiAqL1xyXG52YXIgTnVtYiA9IGZ1bmN0aW9uKHZhbCl7XHJcblxyXG4gICAgdmFyIHYgPSBUeXBlLmlzTnVtYmVyKHZhbCk7XHJcblxyXG4gICAgaWYoIXYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX1RZUEVcIiwgeyB2YWx1ZTogVHlwZS5vZih2YWwpLCBleHBlY3RlZDogVHlwZS5vZigwKSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTnVtYjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFR5cGUgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIiksXHJcbiAgICBFeGNlcHRpb24gICA9IHJlcXVpcmUoXCIuLi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFRlc3QgaWYgdmFsdWUgaXMgYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEB0aHJvd3Mge0V4Y2VwdGlvbn1cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWxcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKlxyXG4gKi9cclxudmFyIE9iaiA9IGZ1bmN0aW9uKHZhbCl7XHJcblxyXG4gICAgdmFyIHYgPSBUeXBlLmlzT2JqZWN0KHZhbCk7XHJcblxyXG4gICAgaWYoIXYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX1RZUEVcIiwgeyB2YWx1ZTogVHlwZS5vZih2YWwpLCBleHBlY3RlZDogVHlwZS5vZih7fSkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbDtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iajtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuICAgIFR5cGUgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIiksXHJcbiAgICBTYWZlICAgICAgICA9IHJlcXVpcmUoXCIuLi9TYWZlXCIpLFxyXG4gICAgRXhjZXB0aW9uICAgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uL0V4Y2VwdGlvblwiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUZXN0IHRoZSByZWdleFxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFeGNlcHRpb259XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgICB2YWxcclxuICogQHBhcmFtIHtTdHJpbmd8UmVnZXh9ICAgIHJlZ2V4XHJcbiAqIEByZXR1cm4geyp9XHJcbiAqXHJcbiAqL1xyXG52YXIgUmVnZXggPSBmdW5jdGlvbih2YWwsIHJlZ2V4KXtcclxuXHJcbiAgICByZWdleCA9IFNhZmUucmVnZXhwKHJlZ2V4KTtcclxuXHJcbiAgICB2YXIgaXNWYWxpZCA9ICEhcmVnZXguZXhlYyh2YWwpO1xyXG5cclxuICAgIGlmKCFpc1ZhbGlkKXtcclxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiUkVHRVhQXCIsIHsgdmFsdWU6IHZhbCB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVnZXg7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFR5cGUgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIiksXHJcbiAgICBFeGNlcHRpb24gICA9IHJlcXVpcmUoXCIuLi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIElzUmVxdWlyZWRcclxuICpcclxuICogQHRocm93cyB7RXhjZXB0aW9ufVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbFxyXG4gKiBAcmV0dXJuIHsqfVxyXG4gKlxyXG4gKi9cclxudmFyIFJlcXVpcmVkID0gZnVuY3Rpb24odmFsKXtcclxuXHJcbiAgICB2YXIgdiA9IFR5cGUuaXNEZWZpbmVkKHZhbCk7XHJcblxyXG4gICAgaWYoIXYpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVkFMSURBVElPTl9SRVFVSVJFRFwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZWQ7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUeXBlICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxyXG4gICAgRXhjZXB0aW9uICAgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uL0V4Y2VwdGlvblwiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUZXN0IGlmIHZhbHVlIGlzIGEgc3RyaW5nXHJcbiAqXHJcbiAqIEB0aHJvd3Mge0V4Y2VwdGlvbn1cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWxcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKlxyXG4gKi9cclxudmFyIFN0ciA9IGZ1bmN0aW9uKHZhbCl7XHJcblxyXG4gICAgdmFyIHYgPSBUeXBlLmlzU3RyaW5nKHZhbCk7XHJcblxyXG4gICAgaWYoIXYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX1RZUEVcIiwgeyB2YWx1ZTogVHlwZS5vZih2YWwpLCBleHBlY3RlZDogVHlwZS5vZihcIlwiKSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyAgICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuICAgIFNhZmUgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1NhZmVcIiksXHJcbiAgICBDaGFpbiAgICAgICAgICAgPSByZXF1aXJlKFwiLi9DaGFpblwiKSxcclxuICAgIENoYWluQ29udGV4dCAgICA9IHJlcXVpcmUoXCIuL0NoYWluL0NoYWluQ29udGV4dFwiKTtcclxuXHJcblxyXG4vKipcclxuICpcclxuICogVGhlIENoYWluYWJsZSBmdW5jdGlvbnNcclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICpcclxuICovXHJcbnZhciBDaGFpbmFibGVGbnMgPSB7fTtcclxuXHJcbkNoYWluYWJsZUZucy5yZXF1aXJlZCAgID0gcmVxdWlyZShcIi4vQXNzZXJ0L1JlcXVpcmVkXCIpO1xyXG5DaGFpbmFibGVGbnMuc3RyaW5nICAgICA9IHJlcXVpcmUoXCIuL0Fzc2VydC9TdHJpbmdcIik7XHJcbkNoYWluYWJsZUZucy5vYmplY3QgICAgID0gcmVxdWlyZShcIi4vQXNzZXJ0L09iamVjdFwiKTtcclxuQ2hhaW5hYmxlRm5zLmFycmF5ICAgICAgPSByZXF1aXJlKFwiLi9Bc3NlcnQvQXJyYXlcIik7XHJcbkNoYWluYWJsZUZucy5udW1iZXIgICAgID0gcmVxdWlyZShcIi4vQXNzZXJ0L051bWJlclwiKTtcclxuQ2hhaW5hYmxlRm5zLm1heCAgICAgICAgPSByZXF1aXJlKFwiLi9Bc3NlcnQvTWF4XCIpO1xyXG5DaGFpbmFibGVGbnMubWluICAgICAgICA9IHJlcXVpcmUoXCIuL0Fzc2VydC9NaW5cIik7XHJcbkNoYWluYWJsZUZucy5yZWdleCAgICAgID0gcmVxdWlyZShcIi4vQXNzZXJ0L1JlZ2V4XCIpO1xyXG5DaGFpbmFibGVGbnMuaW5zdGFuY2VPZiA9IHJlcXVpcmUoXCIuL0Fzc2VydC9JbnN0YW5jZU9mXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFRoZSBBc3NlcnRpb24gZnVuY3Rpb25zXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqXHJcbiAqL1xyXG52YXIgQXNzZXJ0aW9uRm5zID0ge307XHJcblxyXG4vKipcclxuICpcclxuICogVGVzdHMgaWYgdGhlIGNvbWJpbmF0aW9uIG9mIHJ1bGVzIGFyZSB2YWxpZFxyXG4gKlxyXG4gKiBAcGFyYW0gIHsqfSAgICAgICAgICByZXN1bHRcclxuICogQHBhcmFtICB7RXJyb3J9ICAgICAgZXJyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5Bc3NlcnRpb25GbnMuaXNWYWxpZCA9IGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcclxuICAgIHJldHVybiAhZXJyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEFzc2VydFxyXG4gKlxyXG4gKiBAcGFyYW0gIHsqfSAgICAgIHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtFcnJvcn0gIGVyclxyXG4gKiBAcmV0dXJuIHt9XHJcbiAqXHJcbiAqL1xyXG5Bc3NlcnRpb25GbnMuYXNzZXJ0ID0gZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xyXG5cclxuICAgIGlmKGVycil7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIENvbnN0cnVjdCBhIG5ldyBBc3NlcnRpb24gcHJvdmlkZXIuIFRoaXMgY2FuIGhhdmUgc29tZSBjdXN0b20gYWN0aW9ucy5cclxuICogQGNsYXNzXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmbnNcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBc3NlcnRpb24oe30pXHJcbiAqICAgICAucmVxdWlyZWQoKVxyXG4gKiAgICAgLnN0cmluZygpXHJcbiAqICAgICAubWF4KDEwKVxyXG4gKiAgICAgLm1pbig1KVxyXG4gKiAgICAgWyAuaXNWYWxpZChcImFhYWFcIikgfCAuYXNzZXJ0KFwiYWFhYVwiKSBdXHJcbiAqXHJcbiAqL1xyXG52YXIgQXNzZXJ0aW9uID0gZnVuY3Rpb24oZm5zKXtcclxuXHJcbiAgICBmbnMgPSBTYWZlLm9iamVjdChmbnMpO1xyXG4gICAgZm5zID0gXy5hc3NpZ24oe30sIGZucywgQ2hhaW5hYmxlRm5zKTtcclxuXHJcbiAgICAvLy8gR2V0IHRoZSBjdXJyZW50IENoYWluQ29udGV4dCBvZiB0aGUgYXNzZXJ0aW9uLCBpbiBvcmRlclxyXG4gICAgLy8vIHRvIGtlZXAgdGhlIGFzc2VydGlvbiBzdGF0ZS5cclxuICAgIHZhciBjb250ZXh0ID0gbnVsbDtcclxuICAgIF8uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZyl7XHJcblxyXG4gICAgICAgIGlmKGFyZyBpbnN0YW5jZW9mIENoYWluQ29udGV4dCl7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8vIEFwcGx5IENhaGluIHRvIHRoZSBzYW1lIGNvbnRleHRcclxuICAgIC8vLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIGNhbiBpbnZva2UgXCJpbnN0YWNlb2YgQXNzZXJ0aW9uXCJcclxuICAgIENoYWluLmFwcGx5KHRoaXMsIFtmbnMsIEFzc2VydGlvbkZucywgeyBwaXBlOiBmYWxzZSwgdHlwZTogQXNzZXJ0aW9uIH0sIGNvbnRleHRdKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbjtcclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gICAgPSByZXF1aXJlKFwibG9kYXNoXCIpLFxuICAgIFR5cGUgPSByZXF1aXJlKFwiLi9UeXBlXCIpLFxuICAgIFNhZmUgPSByZXF1aXJlKFwiLi9TYWZlXCIpLFxuICAgIENoYWluQ29udGV4dCAgICA9IHJlcXVpcmUoXCIuL0NoYWluL0NoYWluQ29udGV4dFwiKTtcblxuXG5cbi8qKlxuICpcbiAqIE1vZHVsZSBpbnRlcm5hbCBjb2RlXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqXG4gKi9cbnZhciBJbnRlcm5hbCA9IHt9O1xuXG4vKipcbiAqXG4gKiBHZXRzIHRoZSBhcmd1bWVudCBsaXN0XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBhcmdzT2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqXG4gKi9cbkludGVybmFsLmdldEFyZ3VtZW50TGlzdCA9IGZ1bmN0aW9uKGFyZ3NPYmope1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIF8uZWFjaChhcmdzT2JqLCBmdW5jdGlvbihvYmosIGluZGV4KXtcbiAgICAgICAgYXJncy5wdXNoKG9iaik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJncztcblxufTtcblxuLyoqXG4gKlxuICogV3JhcHMgdGhlIGNoYWluYWJsZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7SW50ZXJuYWwuQ2hhaW5Db250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBmblxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgY2hhaW5hYmxlRm5zXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBldmFsdWF0aW9uRm5zXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBvcHRpb25zXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKlxuICovXG5JbnRlcm5hbC53cmFwQ2hhaW5hYmxlRnVuY3Rpb24gPSBmdW5jdGlvbihjb250ZXh0LCBmbiwgY2hhaW5hYmxlRm5zLCBldmFsdWF0aW9uRm5zLCBvcHRpb25zKXtcblxuICAgIG9wdGlvbnMgPSBTYWZlLm9iamVjdChvcHRpb25zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY3VyQ29udGV4dCAgPSBjb250ZXh0LFxuICAgICAgICAgICAgYXJncyAgICAgICAgPSBJbnRlcm5hbC5nZXRBcmd1bWVudExpc3QoYXJndW1lbnRzKTtcblxuICAgICAgICAvLy8gaW5pdGlhbGl6ZSBjb250ZXh0IGlmIG5lZWRlZFxuICAgICAgICBpZighY3VyQ29udGV4dCl7XG4gICAgICAgICAgICBjdXJDb250ZXh0ID0gbmV3IENoYWluQ29udGV4dChvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLyBhZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBjdXJDb250ZXh0XG4gICAgICAgIGN1ckNvbnRleHQuYWRkKGZuLCBhcmdzKTtcblxuICAgICAgICAvLy8gdGhpcyBpcyB1c2VmdWxsIHRvIGNyZWF0ZSBcInR5cGVkXCIgaW5zdGFuY2VzIG9mIHRoZSBDaGFpblxuICAgICAgICB2YXIgQ2hhaW5DbGFzcyA9IFNhZmUuZnVuY3Rpb24ob3B0aW9ucy50eXBlLCBDaGFpbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbkNsYXNzKGNoYWluYWJsZUZucywgZXZhbHVhdGlvbkZucywgb3B0aW9ucywgY3VyQ29udGV4dCk7XG5cbiAgICB9O1xuXG59O1xuXG4vKipcbiAqXG4gKiBXcmFwcyBhIHJldHVybmFibGUgZnVuY3Rpb24uIFRoZSBsYXN0IGFyZ3VtZW50IG9mIHRoZSBmdW5jdGlvbiBpcyBhbHdheXMgdGhlIGVycm9yLCBvciBudWxsXG4gKiBpZiBkb2Vzbid0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge0ludGVybmFsLkNoYWluQ29udGV4dH0gY29udGV4dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIGNoYWluYWJsZUZuc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgZXZhbHVhdGlvbkZuc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICpcbiAqL1xuSW50ZXJuYWwud3JhcFJldHVybmFibGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGNvbnRleHQsIGZuLCBjaGFpbmFibGVGbnMsIGV2YWx1YXRpb25GbnMsIG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucyA9IFNhZmUub2JqZWN0KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjdXJDb250ZXh0ICA9IGNvbnRleHQsXG4gICAgICAgICAgICBhcmdzICAgICAgICA9IEludGVybmFsLmdldEFyZ3VtZW50TGlzdChhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vLyBpbml0aWFsaXplIGNvbnRleHQgaWYgbmVlZGVkXG4gICAgICAgIGlmKCFjdXJDb250ZXh0KXtcbiAgICAgICAgICAgIGN1ckNvbnRleHQgPSBuZXcgQ2hhaW5Db250ZXh0KG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCAgPSBudWxsLFxuICAgICAgICAgICAgZXJyICAgICA9IG51bGw7XG5cbiAgICAgICAgLy8vIHdyYXAgdGhlIGFyZ3VtZW50cyB0byAuYXBwbHkgY2FsbC4gVGhlIGxhc3QgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBvbmUgZGVmaW5lZFxuICAgICAgICAvLy8gb24gdGhlIG9wdGlvbnMuXG4gICAgICAgIHZhciBfYXJncyA9IFsgYXJncy5zaGlmdCgpIF07XG5cbiAgICAgICAgLy8vIHNldHMgdGhlIHNjb3BlIG9mIHRoZSBjb250ZXh0XG4gICAgICAgIHZhciBzY29wZSA9IGN1ckNvbnRleHQuc2V0U2NvcGUob3B0aW9ucy5zY29wZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vLyBleGVjdXRlIGFsbCB0aGUgY2hhaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1ckNvbnRleHQuZXhlYyhfYXJncywgb3B0aW9ucy5hcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSl7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8vIGlmIGl0cyBvbiBwaXBlIG1vZGUsIHdyYXAgdGhlIHJlc3VsdCBzbyBpdCBjYW4gYmUgY29ycmVjdGx5IC5hcHBseSgpXG4gICAgICAgIGlmKG9wdGlvbnMucGlwZSl7XG4gICAgICAgICAgICByZXN1bHQgPSBbIHJlc3VsdCBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8vIGNyZWF0ZSB0aGUgZXZhbHVhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgICAgdmFyIGZuQXJncyA9IFNhZmUuYXJyYXkocmVzdWx0LCBbIG51bGwgXSlcbiAgICAgICAgICAgIC8vLyBjb25jYXQgdGhlIGFyZ3VtZW50cyBpZiB0aGV5IGFyZSBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICAuY29uY2F0KFNhZmUuYXJyYXkoYXJncykpXG4gICAgICAgICAgICAvLy8gY29uY2F0IHRoZSBhcmd1bWVudCBpZiBpcyBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICAuY29uY2F0KFNhZmUuYXJyYXkob3B0aW9ucy5hcmd1bWVudCkpXG4gICAgICAgICAgICAvLy8gY29uY2F0IHRoZSBlcnIgYXMgbGFzdCBhcmd1bWVudFxuICAgICAgICAgICAgLmNvbmNhdChbZXJyXSk7XG5cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBmbkFyZ3MpO1xuXG4gICAgfTtcblxufTtcblxuLyoqXG4gKlxuICogR2V0IGNoYWluIGZ1bmN0aW9uc1xuICpcbiAqIEBwYXJhbSAge0ludGVybmFsLkN1cnJlbnRBc3NlcnRpb25Db250ZXh0fSBhc3NlcnRpb25Db250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IGNoYWluYWJsZUZuc1xuICogQHBhcmFtICB7T2JqZWN0fSBldmFsdWF0aW9uRm5zXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKlxuICovXG5JbnRlcm5hbC5nZXRDaGFpbkZ1bmN0aW9ucyA9IGZ1bmN0aW9uKGNvbnRleHQsIGNoYWluYWJsZUZucywgZXZhbHVhdGlvbkZucywgb3B0aW9ucyl7XG5cbiAgICAvLy8gbWVyZ2UgdGhlIGRlZmF1bHQgZm5zIGFuZCB0aGUgY3VzdG9tIGZ1bmN0aW9uc1xuICAgIHZhciBmbnMgPSBfLmFzc2lnbih7fSwgY2hhaW5hYmxlRm5zKTtcblxuICAgIC8vLyB3cmFwIHRoZSBjaGFpbmFibGUgZnVuY3Rpb25zXG4gICAgXy5lYWNoKFxuICAgICAgICBmbnMsXG4gICAgICAgIGZ1bmN0aW9uKGZuLCBuYW1lKXtcblxuICAgICAgICAgICAgaWYoVHlwZS5pc0Z1bmN0aW9uKGZuKSl7XG4gICAgICAgICAgICAgICAgZm5zW25hbWVdID0gSW50ZXJuYWwud3JhcENoYWluYWJsZUZ1bmN0aW9uKGNvbnRleHQsIGZuLCBjaGFpbmFibGVGbnMsIGV2YWx1YXRpb25GbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgLy8vIHdyYXAgdGhlIHJldHVybmluZyBmdW5jdGlvbnNcbiAgICBfLmVhY2goXG4gICAgICAgIGV2YWx1YXRpb25GbnMsXG4gICAgICAgIGZ1bmN0aW9uKGZuLCBuYW1lKXtcblxuICAgICAgICAgICAgaWYoVHlwZS5pc0Z1bmN0aW9uKGZuKSl7XG4gICAgICAgICAgICAgICAgZm5zW25hbWVdID0gSW50ZXJuYWwud3JhcFJldHVybmFibGVGdW5jdGlvbihjb250ZXh0LCBmbiwgY2hhaW5hYmxlRm5zLCBldmFsdWF0aW9uRm5zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgIHJldHVybiBmbnM7XG5cbn07XG5cbi8qKlxuICpcbiAqIENoYWluIGNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgY2hhaW5hYmxlRm5zXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgZXZhbHVhdGlvbkZuc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2hhaW5Db250ZXh0fSAgICBjb250ZXh0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIG5ldyBDaGFpbihcbiAqXG4gKiAgICAgLy8vIGNoYWluYWJsZSBmbnNcbiAqICAgICB7XG4gKiAgICAgICAgIFwiZm5cIjogZnVuY3Rpb24oKXt9XG4gKiAgICAgfSxcbiAqXG4gKiAgICAgLy8vIGV2YWx1YXRpb24gZm5zXG4gKiAgICAge30sXG4gKlxuICogICAgIC8vLyBvcHRpb25zIGZuc1xuICogICAgIHtcbiAqICAgICAgICAgdHlwZSAgICAgICAgIDoge30sXG4gKiAgICAgICAgIHBpcGUgICAgICAgICA6IFt0cnVlfGZhbHNlXSxcbiAqICAgICAgICAgc2NvcGUgICAgICAgIDogRnVuY3Rpb24sXG4gKiAgICAgICAgIGFyZ3VtZW50ICAgICA6IHVuZGVmaW5lZFxuICogICAgIH0sXG4gKlxuICogICAgIC8vLyBjb250ZXh0XG4gKiAgICAge31cbiAqXG4gKiApO1xuICpcbiAqXG4gKi9cbnZhciBDaGFpbiA9IGZ1bmN0aW9uKGNoYWluYWJsZUZucywgZXZhbHVhdGlvbkZucywgb3B0aW9ucywgY29udGV4dCl7XG5cbiAgICB2YXIgc2NvcGUgICA9IHRoaXM7XG5cbiAgICAvLy8gY2hhaW4gdGhlIGZ1bmN0aW9uc1xuICAgIHZhciBmbnMgPSBJbnRlcm5hbC5nZXRDaGFpbkZ1bmN0aW9ucyhjb250ZXh0LCBjaGFpbmFibGVGbnMsIGV2YWx1YXRpb25GbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8vIGluaXRpYWxpemUgdGhpcyBjb250ZXh0XG4gICAgXy5lYWNoKGZucywgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICBzY29wZVtrZXldID0gdmFsO1xuICAgIH0pO1xuXG59O1xuXG5DaGFpbi5wcm90b3R5cGUgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBTYWZlID0gcmVxdWlyZShcIi4uL1NhZmVcIiksXG4gICAgVHlwZSA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxuXG4gICAgQ2hhaW5GdW5jdGlvbiAgID0gcmVxdWlyZShcIi4vQ2hhaW5GdW5jdGlvblwiKTtcblxuXG4vKipcbiAqXG4gKiBBIGNoYWluIGNvbnRleHQga2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY2hhaW5hYmxlIHN0YXRlXG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogbmV3IENoYWluQ29udGV4dCh7XG4gKlxuICogICAgIHBpcGU6XG4gKiB9KVxuICovXG52YXIgQ2hhaW5Db250ZXh0ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cbiAgICBvcHRpb25zID0gU2FmZS5vYmplY3Qob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCByZWdpc3RlcmVkIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogQHR5cGUgeyBbSW50ZXJuYWwuQXNzZXJ0aW9uRnVuY3Rpb25dIH1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuZm5zID0gW107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBzaGFyZWQgZm4gY29udGV4dFxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuc2NvcGUgPSB0aGlzLnNldFNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQaXBlIG1vZGUgY29udGV4dFxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLnBpcGUgPSBTYWZlLmJvb2xlYW4ob3B0aW9ucy5waXBlKTtcblxufTtcblxuLyoqXG4gKlxuICogU2V0cyB0aGUgc2NvcGUgb2YgdGhpcyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxGdW5jdGlvbn0gc2NvcGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuQ2hhaW5Db250ZXh0LnByb3RvdHlwZS5zZXRTY29wZSA9IGZ1bmN0aW9uKHNjb3BlKXtcblxuICAgIGlmKFR5cGUuaXNEZWZpbmVkKHNjb3BlKSl7XG4gICAgICAgIHNjb3BlID0gVHlwZS5pc0Z1bmN0aW9uKHNjb3BlKSA/IHNjb3BlKCkgOiBzY29wZTtcbiAgICB9XG5cbiAgICAvLy8gTWFpbnRhaW4gdGhlIGN1cnJlbnQgY29udGV4dCBpZiBub3QgZGVmaW5lZFxuICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcy5zY29wZTtcblxuICAgIC8vLyBzZXQgdGhlIGNvbnRleHRcbiAgICB0aGlzLnNjb3BlID0gU2FmZS5vYmplY3Qoc2NvcGUsIHt9KTtcblxuICAgIHJldHVybiB0aGlzLnNjb3BlO1xuXG59O1xuXG4vKipcbiAqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbnxPYmplY3R9ICAgZm5cbiAqIEBwYXJhbSAge0FycmF5fSAgYXJnc1xuICpcbiAqIEByZXR1cm4ge0ludGVybmFsLkNoYWlufVxuICpcbiAqL1xuQ2hhaW5Db250ZXh0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmbiwgYXJncyl7XG5cbiAgICBpZihUeXBlLmlzRnVuY3Rpb24oZm4pKSB7XG5cbiAgICAgICAgZm4gPSBuZXcgQ2hhaW5GdW5jdGlvbih7IGZuOiBmbiwgYXJnczogYXJncyB9KTtcblxuICAgICAgICB0aGlzLmZucy5wdXNoKCBmbiApO1xuXG4gICAgfVxuXG59O1xuXG4vKipcbiAqXG4gKiBFeGVjdXRlIHRoZSBjb250ZXh0IHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudCBhcyBwYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0gIHsqfSAgICAgICAgICBhcmdzXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBleHRyYUFyZ3NcbiAqIEBwYXJhbSAge0Z1bmNpb259ICAgIGVyckNhbGxiYWNrXG4gKlxuICogQHJldHVybiB7Kn1cbiAqKlxuICovXG5DaGFpbkNvbnRleHQucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihhcmdzLCBleHRyYUFyZ3MsIGVyckNhbGxiYWNrKXtcblxuICAgIGV4dHJhQXJncyAgID0gU2FmZS52YWx1ZShleHRyYUFyZ3MpO1xuICAgIGVyckNhbGxiYWNrID0gU2FmZS5mdW5jdGlvbihlcnJDYWxsYmFjaywgZnVuY3Rpb24oZXJyKXsgdGhyb3cgZXJyOyB9KTtcblxuICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgcmVzdWx0ICA9IGFyZ3MsXG4gICAgICAgIGVycm9yICAgPSBudWxsO1xuXG4gICAgLy8vIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uc1xuICAgIF8uZWFjaChcbiAgICAgICAgdGhpcy5mbnMsXG4gICAgICAgIGZ1bmN0aW9uKGZuLCBpbmRleCl7XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAvLy8gcmVhbGx5IGV4ZWN1dGUgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZm4uYXBwbHkoc2VsZi5zY29wZSwgcmVzdWx0LCBleHRyYUFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8vIGlmIGNoYWluIHJldHVybiB2YWx1ZXMgYmV0d2VlbiB0aGUgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5waXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vLyBzdG9wIGl0ZXJhdGluZ1xuICAgICAgICAgICAgaWYoZXJyb3IgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgIC8vLyBpZiBhbiBlcnJvciBleGlzdHNcbiAgICBpZihlcnJvcil7XG4gICAgICAgIGVyckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8vIHJldHVybnNcbiAgICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuICAgIFR5cGUgPSByZXF1aXJlKFwiLi4vVHlwZVwiKSxcclxuICAgIFNhZmUgPSByZXF1aXJlKFwiLi4vU2FmZVwiKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogVGhlIENoYWluRnVuY3Rpb24gd3JhcHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYSBmdW5jdGlvbiBleGVjdXRlZFxyXG4gKiBvbiBhIGNoYWluIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBDaGFpbkZ1bmN0aW9uKHtcclxuICogICAgIGZuICAgOiBmdW5jdGlvbigpe30sXHJcbiAqICAgICBhcmdzIDogW11cclxuICogfSk7XHJcbiAqXHJcbiAqL1xyXG52YXIgQ2hhaW5GdW5jdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xyXG5cclxuICAgIG9wdGlvbnMgPSBTYWZlLm9iamVjdChvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgICA9IFNhZmUuc3RyaW5nKG9wdGlvbnMubmFtZSwgXCI/XCIpO1xyXG4gICAgdGhpcy5mbiAgICAgPSBTYWZlLmZ1bmN0aW9uKG9wdGlvbnMuZm4sIGZ1bmN0aW9uKCl7fSk7XHJcbiAgICB0aGlzLmFyZ3MgICA9IFNhZmUuYXJyYXkob3B0aW9ucy5hcmdzKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogRXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBnaXZlbiBzY29wZSBhbmQgYXJncy5cclxuICpcclxuICogVGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgZ2l2ZW5cclxuICogYXJncyBhbmQgdGhlIGluc3RhbmNlIGFyZ3VtZW50cy5cclxuICpcclxuICogQHBhcmFtICB7Kn0gc2NvcGVcclxuICogQHBhcmFtICB7Kn0gYXJnc1xyXG4gKiBAcGFyYW0gIHsqfSBleHRyYUFyZ3NcclxuICpcclxuICogQHJldHVybiB7Kn1cclxuICpcclxuICovXHJcbkNoYWluRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oc2NvcGUsIGFyZ3MsIGV4dHJhQXJncykge1xyXG5cclxuICAgIHNjb3BlICAgICAgID0gU2FmZS5vYmplY3Qoc2NvcGUpO1xyXG4gICAgYXJncyAgICAgICAgPSBTYWZlLmFycmF5KGFyZ3MpO1xyXG4gICAgZXh0cmFBcmdzICAgPSBTYWZlLmFycmF5KGV4dHJhQXJncyk7XHJcblxyXG4gICAgLy8vIHRoZSBnaXZlbiBhcmdzIHNob3VsZCBhbHdheXMgZXhpc3RcclxuICAgIGlmKGFyZ3MubGVuZ3RoID09PSAwKSBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgLy8vIGNvbmNhdGVuYXRlIHRoZSBnaXZlbiBhcmd1bWVudHMgd2l0aCB0aGUgaW5zdGFuY2VcclxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCh0aGlzLmFyZ3MpLmNvbmNhdChleHRyYUFyZ3MpO1xyXG5cclxuICAgIC8vLyBleGVjdXRlIGZ1bmN0aW9uIHdpdGggb2JqIHNjb3BlIGFuZCB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcbiAgICByZXR1cm4gdGhpcy5mbi5hcHBseShzY29wZSwgYXJncyk7XHJcblxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hhaW5GdW5jdGlvbjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyAgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBUeXBlICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9UeXBlXCIpLFxuICAgIFNhZmUgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1NhZmVcIiksXG4gICAgQ2hhaW4gICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vQ2hhaW5cIiksXG4gICAgQ2hhaW5Db250ZXh0ICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vQ2hhaW4vQ2hhaW5Db250ZXh0XCIpLFxuICAgIFR5cGVzICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1NjaGVtYS9UeXBlc1wiKSxcbiAgICBTY2hlbWFEZWZpbml0aW9uICAgICAgICAgPSByZXF1aXJlKFwiLi9TY2hlbWEvU2NoZW1hRGVmaW5pdGlvblwiKSxcbiAgICBTY2hlbWFFdmFsdWF0b3IgICAgICAgICAgPSByZXF1aXJlKFwiLi9TY2hlbWEvU2NoZW1hRXZhbHVhdG9yXCIpO1xuXG4vKipcbiAqXG4gKiBJbnRlcm5hbCBtZXRob2RzIHdyYXBwZXJcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIEludGVybmFsID0ge307XG5cbi8qKlxuICpcbiAqIFdyYXBzIHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9ucyBpbiBvcmRlciB0byBjaGFuZ2UgdGhlIFNjaGVtYURlZmluaXRpb24gY29udGV4dFxuICogd2hlbiBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICpcbiAqIEByZXR1cm4ge1ZhbGlkYXRpb25GdW5jdGlvbn1cbiAqXG4gKi9cbkludGVybmFsLndyYXBWYWxpZGF0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbihuYW1lKXtcblxuICAgIC8vLyBhcmd1bWVudHMgbm9ybWFsaXphdGlvblxuICAgIG5hbWUgPSBTYWZlLnN0cmluZyhuYW1lKTtcblxuICAgIC8vLyByZXR1cm4gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcblxuICAgICAgICAvLy8gZ2V0IHRoZSBhY3R1YWwgYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8vIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBldmFsIG9iamVjdCwgc28gZGlzY2FyZCBpdC5cbiAgICAgICAgYXJncy5zaGlmdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8vIGxhc3QgYXJndW1lbnQgaXMgdGhlIGNoYWluIGFyZ3VtZW50IG9wdGlvbiwgc28gZGlzY2FyZCBpdFxuICAgICAgICBhcmdzLnBvcCgpO1xuXG4gICAgICAgIC8vLyBhZGQgdGhlIHZhbHVlIGRlZmluaXRpb24gdG8gdGhlIFNjaGVtYURlZmluaXRpb24gbGlzdFxuICAgICAgICB0aGlzLnZhbGlkYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG59O1xuXG4vKipcbiAqXG4gKiBTY2hlbWFEZWZpbml0aW9uIGNvbXBpbGUgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogXG4gKi9cbkludGVybmFsLmNvbXBpbGVPcHRpb25zID0ge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQcmVwYXJlIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIFNjaGVtYURlZmluaXRpb24gXG4gICAgICogY29udmVyc2lvbi4gSWYgdGhlIHZhbHVlIGlzIGluc3RhbmNlIG9mIFNjaGVtYSBnZXQgXG4gICAgICogaXRzIFNjaGVtYURlZmluaXRpb24gdmFsdWUgZm9yIHRoZSBjb252ZXJzaW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7Kn0gdmFsXG4gICAgICogXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBcbiAgICAgKi9cbiAgICBwcmVwYXJlOiBmdW5jdGlvbih2YWwpe1xuXG4gICAgICAgIGlmKFR5cGUuaW5zdGFuY2VPZih2YWwsIFR5cGVzLlNjaGVtYSkpe1xuICAgICAgICAgICAgdmFyIHNjaGVtYURhdGEgPSB2YWwuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB2YWwgPSBuZXcgU2NoZW1hRGVmaW5pdGlvbihzY2hlbWFEYXRhLCB7IFxuICAgICAgICAgICAgICAgIHByZXBhcmU6IGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2NoZW1hRGVmaW5pdGlvbih2YWwsIHsgY29tcGlsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuXG4gICAgfVxuXG59O1xuXG4vKipcbiAqXG4gKiBUaGUgU2NoZW1hIENoYWluYWJsZSBmdW5jdGlvbnNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIFNjaGVtYUNoYWluYWJsZUZucyA9IHtcblxuICAgIGFueTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5hbnkgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IG51bGw7XG4gICAgfSxcblxuICAgIHN0cmljdDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBzdHJpbmcgOiBmdW5jdGlvbih2YWwsIG9iail7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gXCJcIjtcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYW55ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG9iamVjdCA6IGZ1bmN0aW9uKHZhbCwgb2JqKXtcbiAgICAgICAgb2JqID0gU2FmZS5vYmplY3Qob2JqLCB7fSk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gb2JqO1xuICAgICAgICB0aGlzLnJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYXJyYXkgOiBmdW5jdGlvbih2YWwsIG9iail7XG4gICAgICAgIG9iaiA9IFNhZmUuYXJyYXkob2JqLCBbXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gb2JqO1xuICAgICAgICB0aGlzLnJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYW55ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG51bWJlciA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gMDtcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYW55ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGJvb2xlYW4gOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNjaGVtYSA9IEJvb2xlYW4odHJ1ZSk7XG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFueSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0IDogZnVuY3Rpb24odmFsLCBkZWZhdWx0VmFsdWUpe1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBkZWZhdWx0VmFsdWU7XG4gICAgfSxcblxuICAgIHJlcXVpcmVkIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIG9wdGlvbmFsIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXBlYXRhYmxlOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnJlcGVhdGFibGUgPSB0cnVlO1xuICAgIH1cblxufTtcblxuLyoqXG4gKlxuICogVGhlIGRlZmF1bHQgQ3VzdG9tIENoYWluYWJsZSBGdW5jdGlvbnNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIEN1c3RvbUNoYWluYWJsZUZucyA9IHtcbiAgICBcIm1pblwiOiByZXF1aXJlKFwiLi9Bc3NlcnQvTWluXCIpLFxuICAgIFwibWF4XCI6IHJlcXVpcmUoXCIuL0Fzc2VydC9NYXhcIiksXG4gICAgXCJyZWdleFwiOiByZXF1aXJlKFwiLi9Bc3NlcnQvUmVnZXhcIiksXG59O1xuXG4vKipcbiAqXG4gKiBUaGUgZXZhbHVhdGlvbiBmdW5jdGlvbnNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIEV2YWx1YXRpb25GbnMgPSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENvbXBpbGUgdGhlIHJ1bGUgYW5kIHJldHVybiB0aGUgZmFjYWRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTY2hlbWFFdmFsdWF0b3J9XG4gICAgICpcbiAgICAgKi9cbiAgICBjb21waWxlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3VtZW50LCBlcnIpe1xuXG4gICAgICAgIC8vLyB0aHJvdyBlcnJvciBpZiB0aGVyZSB3YXMgc29tZSBpbiB0aGUgY2hhaW5cbiAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRXZhbHVhdG9yKHRoaXMsIGFyZ3VtZW50LCBJbnRlcm5hbC5jb21waWxlT3B0aW9ucyk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcHBseSB0aGUgc2NoZW1hIHJ1bGVzIGFuZCByZXR1cm4gdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHsqfSAgICAgIHJlc3VsdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHJlc3VsdCwgYXJndW1lbnQsIGVycil7XG5cbiAgICAgICAgLy8vIHRocm93IGVycm9yIGlmIHRoZXJlIHdhcyBzb21lIGluIHRoZSBjaGFpblxuICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgPSBuZXcgU2NoZW1hRXZhbHVhdG9yKHRoaXMsIGFyZ3VtZW50LCBJbnRlcm5hbC5jb21waWxlT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByLnZhbHVlKHJlc3VsdCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgZXJyb3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHsqfSAgICAgIHJlc3VsdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqXG4gICAgICovXG4gICAgZXJyb3JzOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3VtZW50LCBlcnIpe1xuXG4gICAgICAgIC8vLyB0aHJvdyBlcnJvciBpZiB0aGVyZSB3YXMgc29tZSBpbiB0aGUgY2hhaW5cbiAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByID0gbmV3IFNjaGVtYUV2YWx1YXRvcih0aGlzLCBhcmd1bWVudCwgSW50ZXJuYWwuY29tcGlsZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gci5lcnJvcnMocmVzdWx0KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgdmFsaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgeyp9ICAgICAgcmVzdWx0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhcmd1bWVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKi9cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3VtZW50LCBlcnIpe1xuXG4gICAgICAgIC8vLyB0aHJvdyBlcnJvciBpZiB0aGVyZSB3YXMgc29tZSBpbiB0aGUgY2hhaW5cbiAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IG5ldyBTY2hlbWFFdmFsdWF0b3IodGhpcywgYXJndW1lbnQsIEludGVybmFsLmNvbXBpbGVPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHIuaXNWYWxpZChyZXN1bHQpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VyaWFsaXplIHRoZSBzY2hlbWEgcnVsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqXG4gICAgICovXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3VtZW50LCBlcnIpe1xuXG4gICAgICAgIHZhciBldmFsdWF0b3IgPSBuZXcgU2NoZW1hRXZhbHVhdG9yKHRoaXMsIGFyZ3VtZW50LCBJbnRlcm5hbC5jb21waWxlT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0b3Iuc2VyaWFsaXplKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXNlcmlhbGl6ZSBmcm9tIHRoZSBzY2hlbWEgZnJvbSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTY2hlbWFFdmFsdWF0b3J9XG4gICAgICpcbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24odmFsdWUsIGFyZ3VtZW50LCBlcnIpe1xuXG4gICAgICAgIHZhciBldmFsdWF0b3IgPSBuZXcgU2NoZW1hRXZhbHVhdG9yKHRoaXMsIGFyZ3VtZW50LCBJbnRlcm5hbC5jb21waWxlT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0b3IuZGVzZXJpYWxpemUodmFsdWUpO1xuXG4gICAgfVxuXG59O1xuXG4vKipcbiAqXG4gKiBTY2hlbWEgQ2hhaW4gRmFjaWxpdHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tRm5zXG4gKlxuICpcbiAqL1xudmFyIFNjaGVtYSA9IGZ1bmN0aW9uKGN1c3RvbUZucyl7XG5cbiAgICBjdXN0b21GbnMgPSBTYWZlLm9iamVjdChjdXN0b21GbnMpO1xuXG4gICAgLy8vIGdldCB0aGUgU2NoZW1hIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBUaGlzIGlzIGFuIGV4dGVuc2lvbiBwb2ludFxuICAgIC8vLyBmb3IgdGhlIHNjaGVtYSB2YWxpZGF0aW9uLlxuICAgIHZhciB2YWxpZGF0aW9uRm5zID0gXy5leHRlbmQoe30sIGN1c3RvbUZucywgQ3VzdG9tQ2hhaW5hYmxlRm5zKTtcblxuICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgQ2hhaW5Db250ZXh0IG9mIHRoZSBhc3NlcnRpb24sIGluIG9yZGVyXG4gICAgLy8vIHRvIGtlZXAgdGhlIGFzc2VydGlvbiBzdGF0ZS5cbiAgICB2YXIgY2hhaW5Db250ZXh0ID0gbnVsbDtcbiAgICBfLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpe1xuICAgICAgICBpZihhcmcgaW5zdGFuY2VvZiBDaGFpbkNvbnRleHQpe1xuICAgICAgICAgICAgY2hhaW5Db250ZXh0ID0gYXJnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLy8gaWYgdGhlcmUncyBubyBjaGFpbiBjb250ZXh0IGluaXRpYWxpemUgdGhlIGRlZmF1bHQgZnVuY3Rpb25zIGJ5XG4gICAgLy8vIHdyYXBwaW5nIHRoZW0gaW4gYSBjb21wYXRpYmxlIEFQSVxuICAgIGlmKCFjaGFpbkNvbnRleHQpe1xuXG4gICAgICAgIC8vLyBhc3NpZ24gdGhlIGRlZmF1bHQgdmFsaWRhdGlvbiBmdW5jdGlvbnNcbiAgICAgICAgdmFyIHNjaGVtYUZucyA9IF8uZXh0ZW5kKHt9LCBTY2hlbWFDaGFpbmFibGVGbnMpO1xuXG4gICAgICAgIC8vLyB0cmFuc2Zvcm0gdGhlIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucywgdG8gdXNlIHRoZSBTY2hlbWFcbiAgICAgICAgLy8vIHJ1bm5lclxuICAgICAgICB2YXIgd3JhcHBlZEZucyA9IF8uZXh0ZW5kKHt9LCBDdXN0b21DaGFpbmFibGVGbnMsIGN1c3RvbUZucyk7XG4gICAgICAgIF8uZWFjaCh3cmFwcGVkRm5zLCBmdW5jdGlvbihmbiwgbmFtZSl7XG4gICAgICAgICAgICB3cmFwcGVkRm5zW25hbWVdID0gSW50ZXJuYWwud3JhcFZhbGlkYXRpb25GdW5jdGlvbihuYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8vIGdpdmUgcHJlY2VkZW5jZSB0byBzY2hlbWFGbnNcbiAgICAgICAgY3VzdG9tRm5zID0gXy5leHRlbmQod3JhcHBlZEZucywgc2NoZW1hRm5zKTtcblxuICAgIH1cblxuICAgIC8vLyB0aGUgY2hhaW4gb3B0aW9uc1xuICAgIHZhciBjaGFpbk9wdGlvbnMgPSB7XG5cbiAgICAgICAgLy8vIGRvIG5vdCBwaXBlIHRoZSBjaGFpbmFibGUgZm5zIG9iamVjdHNcbiAgICAgICAgcGlwZTogZmFsc2UsXG5cbiAgICAgICAgLy8vIFVzZSB0aGUgU2NoZW1hIHR5cGUgZm9yIGVhY2ggY2hhbmluYWJsZSByZXR1cm4gc3RhdGVtZW50XG4gICAgICAgIHR5cGU6IFNjaGVtYSxcblxuICAgICAgICAvLy8gc2V0IHRoZSBzY29wZSBmb3IgZWFjaCBjaGFpbmFibGUgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICAgICAgICBzY29wZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjaGVtYURlZmluaXRpb24obnVsbCwgeyBjb21waWxlOiBmYWxzZSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLy8gRXZhbHVhdGlvbiBhcmd1bWVudC4gVGhpcyBhcmd1bWVudCB3aWxsIGJlIHByZXNlbnQgaW4gZXZlcnlcbiAgICAgICAgLy8vIGV2YWxGbiBpbnZvY2F0aW9uIHdpdGhvdXQgaW50ZXJmZXJlIHdpdGggdGhlIGNoYWluIHNjb3BlLlxuICAgICAgICBhcmd1bWVudDogdmFsaWRhdGlvbkZuc1xuXG4gICAgfTtcblxuICAgIC8vLyBJbmhlcml0IGZyb20gQ2hhaW5zXG4gICAgQ2hhaW4uYXBwbHkodGhpcywgWyBjdXN0b21GbnMsIEV2YWx1YXRpb25GbnMsIGNoYWluT3B0aW9ucywgY2hhaW5Db250ZXh0IF0pO1xuXG4gICAgcmV0dXJuIG5ldyBUeXBlcy5TY2hlbWEodGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXG4gICAgVHlwZSAgICAgICAgPSByZXF1aXJlKFwiLi4vVHlwZVwiKSxcbiAgICBTYWZlICAgICAgICA9IHJlcXVpcmUoXCIuLi9TYWZlXCIpLFxuICAgIEkxOE5TdHJpbmcgID0gcmVxdWlyZShcIi4uL0kxOE4vU3RyaW5nXCIpLFxuICAgIE1lc3NhZ2VzICAgID0gcmVxdWlyZShcIi4uL0kxOE4vTWVzc2FnZXNcIik7XG5cblxuLyoqXG4gKlxuICogSW50ZXJuYWwgbWV0aG9kc1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKlxuICovXG52YXIgSW50ZXJuYWwgPSB7fTtcblxuLyoqXG4gKlxuICogR2V0IG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG1lc3NhZ2VzXG4gKlxuICogQHJldHVybiB7STE4Tk1lc3NhZ2V9XG4gKlxuICovXG5JbnRlcm5hbC5nZXRJMThOTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhKXtcblxuICAgIG1lc3NhZ2VEYXRhID0gU2FmZS5vYmplY3QobWVzc2FnZURhdGEpO1xuXG4gICAgaWYoIG1lc3NhZ2UgaW5zdGFuY2VvZiBJMThOU3RyaW5nICl7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8vLyBpZiBtZXNzYWdlIGlzIG51bGwgb3IgZW1wdHlcbiAgICBpZiggVHlwZS5pc1N0cmluZyhtZXNzYWdlKSApe1xuICAgICAgICByZXR1cm4gbmV3IEkxOE5TdHJpbmcobWVzc2FnZSwgbWVzc2FnZURhdGEsIE1lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEkxOE5TdHJpbmcoXCJcIik7XG5cbn07XG5cbi8qKlxuICpcbiAqIEdldCB0aGUgc3RhY2sgdHJhY2VcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICovXG5JbnRlcm5hbC5nZXRTdGFja1RyYWNlID0gZnVuY3Rpb24oKXtcblxuICAgIHZhciBlcnJvciAgICA9IG5ldyBFcnJvcigpLFxuICAgICAgICBzdGFja1N0ciA9IFNhZmUuc3RyaW5nKGVycm9yLnN0YWNrKSxcbiAgICAgICAgc3RhY2sgICAgPSBzdGFja1N0ci5zcGxpdCgnXFxuJyk7XG5cbiAgICAvLy8gUmVtb3ZlIEVycm9yIG1lc3NhZ2UgKyAyIGZpcnN0IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZVxuICAgIHN0YWNrLnNwbGljZSgwLDMpO1xuXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcbicpO1xuXG59O1xuXG4vKipcbiAqXG4gKiBAY2xhc3MgRXJyb3IgQ2xhc3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xJMThOU3RyaW5nfSBtZXNzYWdlXG4gKlxuICovXG52YXIgRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbWVzc2FnZURhdGEpIHtcblxuICAgIG1lc3NhZ2UgICAgID0gSW50ZXJuYWwuZ2V0STE4Tk1lc3NhZ2UobWVzc2FnZSwgbWVzc2FnZURhdGEpO1xuICAgIG1lc3NhZ2VEYXRhID0gU2FmZS5vYmplY3QobWVzc2FnZURhdGEpO1xuXG4gICAgLy8vIGdldCB0aGUgc3RhY2sgdHJhY2VcbiAgICB2YXIgc3RhY2sgPSBJbnRlcm5hbC5nZXRTdGFja1RyYWNlKCk7XG5cbiAgICAvLy8gZGVmaW5lIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vLyBkZWZpbmUgdGhlIHRoaXMuc3RhY2sgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIEVycm9yXG4gICAgLy8vIHN0YWNrXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICAnc3RhY2snLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpICsgXCJcXG5cIiArIHN0YWNrO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRvU3RyaW5nIG1ldGhvZCB3aXRoIGkxOG4gc3VwcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0cmFuc2xhdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbih0cmFuc2xhdGlvbnMpe1xuICAgICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZyh0cmFuc2xhdGlvbnMpO1xuICAgIH07XG5cbn07XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeGNlcHRpb247XG5cbm1vZHVsZS5leHBvcnRzID0gRXhjZXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfICAgICAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoXCIpLFxuICAgIFR5cGUgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxuICAgIFNhZmUgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi9TYWZlXCIpLFxuICAgIEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcblxuLyoqXG4gKlxuICogR2V0IHRoZSBzdGFjayB0cmFjZVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKi9cbnZhciBnZXRTdGFja1RyYWNlID0gZnVuY3Rpb24oKXtcblxuICAgIHZhciBlcnJvciAgICA9IG5ldyBFcnJvcigpLFxuICAgICAgICBzdGFja1N0ciA9IFNhZmUuc3RyaW5nKGVycm9yLnN0YWNrKSxcbiAgICAgICAgc3RhY2sgICAgPSBzdGFja1N0ci5zcGxpdCgnXFxuJyk7XG5cbiAgICAvLy8gUmVtb3ZlIEVycm9yIG1lc3NhZ2UgKyAyIGZpcnN0IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZVxuICAgIHN0YWNrLnNwbGljZSgwLDMpO1xuXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcbicpO1xuXG59O1xuXG4vKipcbiAqXG4gKiBFcnJvciBjbGFzcyB0aGF0IGNhbiBjb250YWluIG11bHRpcGxlIGVycm9yc1xuICogQGNsYXNzXG4gKlxuICovXG52YXIgRXhjZXB0aW9uTGlzdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8vIGluc3RhbmNlIG9mIGVycm9yXG4gICAgdmFyIGl0ZW1zICA9IFtdO1xuXG4gICAgLy8vIGdldCB0aGUgc3RhY2sgdHJhY2VcbiAgICB2YXIgc3RhY2sgPSBnZXRTdGFja1RyYWNlKCk7XG5cbiAgICAvLy8gZGVmaW5lIHRoZSB0aGlzLnN0YWNrIHRvIHJldHVybiB0aGUgY3JlYXRlZCBFcnJvclxuICAgIC8vLyBzdGFja1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgJ3N0YWNrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKSArIFwiXFxuXCIgKyBzdGFjaztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJpdGVtc1wiLFxuICAgICAgICB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uY2xvbmUoaXRlbXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFwibGVuZ3RoXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgZXJyb3IgbGlzdFxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGludmFsaWQgYXJndW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gZXJyb3JzXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbihlcnJvcnMpe1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgLy8vIGlmIGFyZ3VtZW50IGlzIGFuIEV4Y2VwdGlvbkxpc3RcbiAgICAgICAgaWYoZXJyb3JzIGluc3RhbmNlb2YgRXhjZXB0aW9uTGlzdCl7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuaXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLy8gbWFrZSBzdXJlIGVycm9ycyBpcyBhbiBhcnJheVxuICAgICAgICBlcnJvcnMgPSBTYWZlLmFycmF5KGVycm9ycyk7XG5cbiAgICAgICAgLy8vIGFkZHMgdGhlIGVsZW1lbnRzIHRvIHRoZSBsaXN0XG4gICAgICAgIF8uZWFjaChcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKXtcblxuICAgICAgICAgICAgICAgIC8vLyBpZiBlcnJvciBpcyBvbiBzdHJpbmcgZm9ybWF0IGFkZCBpdCBhcyBhbiBFeGNlcHRpb25cbiAgICAgICAgICAgICAgICBpZiggVHlwZS5pc1N0cmluZyhlcnJvcikgKXtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSApe1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnN0YW5jZSBvZiB0eXBlIEVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goZXJyb3IpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENsZWFyIHRoZSBlcnJvciBsaXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgd2hpbGUoaXRlbXMubGVuZ3RoKSBpdGVtcy5wb3AoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUb1N0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zbGF0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKHRyYW5zbGF0aW9ucyl7XG5cbiAgICAgICAgdmFyIHN0ciAgICAgICAgID0gXCJcIixcbiAgICAgICAgICAgIGxlbmd0aCAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgc2VwYXJhdG9yICAgPSBcIiwgXCI7XG5cbiAgICAgICAgXy5lYWNoKFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBmdW5jdGlvbihlcnJvciwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBFeGNlcHRpb24pe1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gZXJyb3IudG9TdHJpbmcodHJhbnNsYXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vLyBhZGQgdGhlIHNlcGFyYXRvciBpZiBpdHMgbm90IHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZihpbmRleCAhPSBsZW5ndGgtMSl7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuXG4gICAgfTtcblxufTtcblxuRXhjZXB0aW9uTGlzdC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkV4Y2VwdGlvbkxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhjZXB0aW9uTGlzdDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2VwdGlvbkxpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE1lc3NhZ2VzID0ge307XG5cbi8qKlxuICpcbiAqIEludmFsaWQgdmFsdWVcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICpcbiAqL1xuTWVzc2FnZXMuVkFMSURBVElPTl9JTlZBTElEX1ZBTFVFID0gXCI8JT0gdmFsdWUgJT4gaXMgaW52YWxpZC5cIjtcblxuLyoqXG4gKlxuICogUmVxdWlyZWQgdmFsdWVcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZXNzYWdlcy5WQUxJREFUSU9OX1JFUVVJUkVEID0gXCJWYWx1ZSBpcyByZXF1aXJlZC5cIjtcblxuLyoqXG4gKlxuICogQXJyYXkgZXhwZWN0ZWRcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICpcbiAqL1xuTWVzc2FnZXMuVkFMSURBVElPTl9UWVBFID0gXCInPCU9IGV4cGVjdGVkICU+JyB3YXMgZXhwZWN0ZWQgYnV0IGZvdW5kICc8JT0gdmFsdWUgJT4nIGluc3RlYWQuXCI7XG5cbi8qKlxuICpcbiAqIE1heCBleGNlZWRcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICpcbiAqL1xuTWVzc2FnZXMuVkFMSURBVElPTl9NQVggPSBcIlRoZSBtYXhpbXVtIHZhbHVlIGFsbG93ZWQgaXMgPCU9IHZhbHVlICU+LlwiO1xuXG4vKipcbiAqXG4gKiBNaW4gZXhjZWVkXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqXG4gKi9cbk1lc3NhZ2VzLlZBTElEQVRJT05fTUlOID0gXCJUaGUgbWluaW11bSB2YWx1ZSBhbGxvd2VkIGlzIDwlPSB2YWx1ZSAlPi5cIjtcblxuLyoqXG4gKlxuICogTWluIGV4Y2VlZFxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKlxuICovXG5NZXNzYWdlcy5SRUdFWFAgPSBcIlJlZ3VsYXIgZXhwcmVzc2lvbiAnPCU9IHZhbHVlICU+JyBkb2Vzbid0IG1hdGNoLlwiO1xuXG4vKipcbiAqXG4gKiBJbnZhbGlkIExpc3QgbGVuZ2h0XG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqXG4gKi9cbk1lc3NhZ2VzLlZBTElEQVRJT05fSU5WQUxJRF9MSVNUX0xFTkdUSCA9IFwiRXhwZWN0ZWQgbGlzdCB3aXRoIDwlPSBleHBlY3RlZCAlPiBpdGVtcyBidXQgZm91bmQgPCU9IHZhbHVlICU+LlwiO1xuXG4vKipcbiAqXG4gKiBJbnZhbGlkIExpc3RcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICpcbiAqL1xuTWVzc2FnZXMuVkFMSURBVElPTl9JTlZBTElEX0xJU1RfTEVOR1RIX01VTFRJUExFX09GID0gXCJFeHBlY3RlZCBsaXN0IGxlbmd0aCB0byBiZSBtdWx0aXBsZSBvZiA8JT0gZXhwZWN0ZWQgJT4gYnV0IGZvdW5kIGxlbmd0aCBvZiA8JT0gdmFsdWUgJT4uXCI7XG5cbi8qKlxuICpcbiAqIEludmFsaWQgTGlzdFxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKlxuICovXG5NZXNzYWdlcy5WQUxJREFUSU9OX0lOU1RBTkNFT0YgPSBcIkV4cGVjdGVkIGluc3RhbmNlIG9mICc8JT0gdmFsdWUgJT4nLlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBTYWZlICAgID0gcmVxdWlyZShcIi4uL1NhZmVcIik7XG5cblxuLyoqXG4gKlxuICogSW50ZXJuYWwgbWV0aGRvc1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKlxuICovXG52YXIgSW50ZXJuYWwgPSB7fTtcblxuLyoqXG4gKlxuICogQXBwbHkgdGhlIHRlbXBsYXRlLiBUaGUgc2NvcGUgb2YgdGhlIGZ1bmN0aW9uIGlzIHRoZSBzdHJpbmcuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIHRlbXBsYXRlIGRhdGEgaXRzIG1pc3Npbmcgb3Igd3JvbmdcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBtZXNzYWdlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjdXN0b21NZXNzYWdlc1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKi9cbkludGVybmFsLmFwcGx5VGVtcGxhdGUgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBtZXNzYWdlcywgY3VzdG9tTWVzc2FnZXMpe1xuXG4gICAgbmFtZSAgICAgICAgICAgID0gU2FmZS5zdHJpbmcobmFtZSk7XG4gICAgZGF0YSAgICAgICAgICAgID0gU2FmZS5vYmplY3QoZGF0YSk7XG4gICAgbWVzc2FnZXMgICAgICAgID0gU2FmZS5vYmplY3QobWVzc2FnZXMpO1xuICAgIGN1c3RvbU1lc3NhZ2VzICA9IFNhZmUub2JqZWN0KGN1c3RvbU1lc3NhZ2VzKTtcblxuICAgIG1lc3NhZ2VzID0gXy5leHRlbmQoe30sIG1lc3NhZ2VzLCBjdXN0b21NZXNzYWdlcyk7XG5cbiAgICB2YXIgdG1wbFN0ciA9IFNhZmUuc3RyaW5nKG1lc3NhZ2VzW25hbWVdKSB8fCBuYW1lO1xuXG4gICAgcmV0dXJuIF8udGVtcGxhdGUodG1wbFN0cikoZGF0YSk7XG5cbn07XG5cbi8qKlxuICpcbiAqIFRlbXBsYXRlIFN0cmluZyBjbGFzcy4gRWFjaCBzdHJpbmcgaXMgaWRlbnRpZmllZCBieSBhIG5hbWUuIFRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIGNhbiBiZSBjaGFuZ2VkIHdoZW4gY2FsbGluZyB0b1N0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgc3RyID0gbmV3IEkxOG5TdHJpbmcoXCJhc2FzXCIsIHt9LCB7fSk7XG4gKlxuICovXG52YXIgSTE4TlN0cmluZyA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG1lc3NhZ2VzKXtcblxuICAgIG5hbWUgICAgICAgID0gU2FmZS5zdHJpbmcobmFtZSk7XG4gICAgZGF0YSAgICAgICAgPSBTYWZlLm9iamVjdChkYXRhKTtcbiAgICBtZXNzYWdlcyAgICA9IFNhZmUub2JqZWN0KG1lc3NhZ2VzKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogdG9TdHJpbmcoKVxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRlbXBsYXRlIGlzIG5vdCBjb3JyZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2VzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKGN1c3RvbU1lc3NhZ2VzKXtcblxuICAgICAgICB0cnl7XG5cbiAgICAgICAgICAgIHJldHVybiBJbnRlcm5hbC5hcHBseVRlbXBsYXRlLmFwcGx5KHRoaXMsIFsgbmFtZSwgZGF0YSwgbWVzc2FnZXMsIGN1c3RvbU1lc3NhZ2VzIF0pO1xuXG4gICAgICAgIH0gY2F0Y2goZSl7XG5cbiAgICAgICAgICAgIHZhciBlcnJvciA9IF8udGVtcGxhdGUoXG4gICAgICAgICAgICAgICAgXCJFcnJvciBvbiB0ZW1wbGF0ZSAnPCU9IG5hbWUgJT4nOiA8JT0gZXJyb3IgJT5cIikoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vLyBJbml0aWFsaXplIHN0cmluZyBieSBjYWxsaW5nIC5zdXBlcigpXG4gICAgU3RyaW5nLmNhbGwoIHRoaXMsIHRoaXMudG9TdHJpbmcoKSApO1xuXG59O1xuXG4vLy8gaW5oZXJpdCBmcm9tIFN0cmluZ1xuLyoganNoaW50IC1XMDUzICovXG5JMThOU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBTdHJpbmcoKTtcbkkxOE5TdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSTE4TlN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBJMThOU3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcclxuICAgIFNhZmUgICAgICAgID0gcmVxdWlyZShcIi4vU2FmZVwiKTtcclxuXHJcblxyXG52YXIgT2JqID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEdldCB0aGUgb2JqZWN0IGtleXMuIElmIGEgZmlsdGVyIGlzIHNwZWNpZmllZCBpdCByZXR1cm5zIHRoZSBrZXlzXHJcbiAgICAgKiB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBvYmpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gICBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZpbHRlcjogZnVuY3Rpb24ob2JqLCBmaWx0ZXIpe1xyXG5cclxuICAgICAgICBvYmogICAgICAgICA9IFNhZmUub2JqZWN0KG9iaik7XHJcbiAgICAgICAgZmlsdGVyICAgICAgPSBTYWZlLnJlZ2V4cChmaWx0ZXIsIFwiLy4qL1wiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF8udHJhbnNmb3JtKFxyXG4gICAgICAgICAgICBvYmosXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCwgdmFsLCBrZXkpe1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGZpbHRlci5leGVjKGtleSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtdKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmo7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBfICAgICAgID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICBUeXBlICAgID0gcmVxdWlyZSgnLi9UeXBlJyk7XHJcblxyXG5cclxudmFyIEludGVybmFsID0ge307XHJcblxyXG4vKipcclxuICpcclxuICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3JtYXRcclxuICpcclxuICogQHR5cGUge1JlZ0V4cH1cclxuICpcclxuICovXHJcbkludGVybmFsLlJlZ0V4cEZvcm1hdCA9IC9eXFwvLipcXC8oXFx3KikkLztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBDb252ZXJ0cyBhIHN0cmluZ3MgdG8gYSBSZWdFeHBcclxuICpcclxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7UmVnRXhwfVxyXG4gKi9cclxuSW50ZXJuYWwuc3RyaW5nVG9SZWdFeHAgPSBmdW5jdGlvbihzdHIpe1xyXG5cclxuICAgIHN0ciA9IFNhZmUuc3RyaW5nKHN0cik7XHJcblxyXG4gICAgdmFyIGZsYWdzID0gXCJcIixcclxuICAgICAgICByZWdleHAgPSBJbnRlcm5hbC5SZWdFeHBGb3JtYXQuZXhlYyhzdHIpO1xyXG5cclxuICAgIGlmKHJlZ2V4cCl7XHJcblxyXG4gICAgICAgIC8vLyBpZiB0aGUgc3RyaW5nIGlzIG9uIC8vIGZvcm1hdCByZW1vdmUgdGhlIHJlZmVyZW5jZXNcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxcLy8sIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwvJC8sIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAudHJpbSgpO1xyXG5cclxuICAgICAgICBmbGFncyA9IHJlZ2V4cFsxXTtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLy8gc3RyaWN0IHNlYXJjaFxyXG4gICAgICAgIHN0ciA9IFwiXlwiICsgc3RyICsgXCIkXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3RyLCBmbGFncyk7XHJcblxyXG59O1xyXG5cclxuXHJcbnZhciBTYWZlID0ge307XHJcblxyXG4vKlxyXG4gKiBTYWZlbGx5IGdldCBhcnJheSBmcm9tIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGdldFxyXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgdmFsdWUgdG8gZ2V0XHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKlxyXG4gKi9cclxuU2FmZS5hcnJheSA9IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpe1xyXG5cclxuICAgIC8vLyBpZiB2YWx1ZSBpcyBudWxsIGFuZCB0aGVyZSBpcyBhIGRlZmF1bHQgdmFsdWUsIHRoZW5cclxuICAgIC8vLyBmYWxsYmFja1xyXG4gICAgLyoganNoaW50IC1XMDQxICovXHJcbiAgICBpZih2YWx1ZSA9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPSBudWxsKXtcclxuICAgICAgICByZXR1cm4gU2FmZS5hcnJheShkZWZhdWx0VmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc0FycmF5ID0gVHlwZS5pc0FycmF5KHZhbHVlKTtcclxuXHJcbiAgICAvKiBqc2hpbnQgLVcwNDEgKi9cclxuICAgIGlmKCFpc0FycmF5ICYmIHZhbHVlICE9IG51bGwpe1xyXG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoIWlzQXJyYXkgJiYgdmFsdWUgPT0gbnVsbCl7XHJcbiAgICAgICAgdmFsdWUgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuLypcclxuICogU2FmZWxseSBnZXQgQm9vbGVhbiBmcm9tIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGdldFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKlxyXG4gKi9cclxuU2FmZS5ib29sZWFuID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSl7XHJcblxyXG4gICAgaWYoVHlwZS5pc0Jvb2xlYW4odmFsdWUpKXtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAgICBpZihkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgcmV0dXJuIFNhZmUuYm9vbGVhbighIWRlZmF1bHRWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIGlmIGlzIE51bWJlclxyXG4gICAgaWYoVHlwZS5pc051bWJlcih2YWx1ZSkpe1xyXG4gICAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIGlmIGlzIFN0cmluZ1xyXG4gICAgaWYoVHlwZS5pc1N0cmluZyh2YWx1ZSkpe1xyXG4gICAgICAgIHJldHVybiAhIXZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAhVHlwZS5pc0VtcHR5KHZhbHVlKTtcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogU2FmZWxseSBnZXQgQm9vbGVhbiBmcm9tIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWVcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKlxyXG4gKi9cclxuU2FmZS5zdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKXtcclxuXHJcbiAgICBpZihUeXBlLmlzU3RyaW5nKHZhbHVlKSl7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICBTYWZlLnN0cmluZyhkZWZhdWx0VmFsdWUpIDogXCJcIjtcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogU2FmZWxseSBnZXQgT2JqZWN0IGZyb20gdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2YWx1ZX0gICAgICAgICAgIFRoZSB2YWx1ZSB0byBnZXRcclxuICogQHBhcmFtIHtkZWZhdWx0VmFsdWV9ICAgIFRoZSBkZWZhdWx0IHZhbHVlXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICpcclxuICovXHJcblNhZmUub2JqZWN0ID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSl7XHJcblxyXG4gICAgaWYoVHlwZS5pc09iamVjdCh2YWx1ZSkpe1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgU2FmZS5vYmplY3QoZGVmYXVsdFZhbHVlKSA6IHt9O1xyXG5cclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBTYWZlbGx5IGdldCBOdW1iZXIgZnJvbSB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBnZXRcclxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWVcclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9yIDAgaWYgd2FzIG5vdCBzdWNjZXNzXHJcbiAqXHJcbiAqL1xyXG5TYWZlLm51bWJlciA9IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpe1xyXG5cclxuICAgIGlmKFR5cGUuaXNOdW1iZXIodmFsdWUpKXtcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgU2FmZS5udW1iZXIoZGVmYXVsdFZhbHVlKSA6IDA7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFNhZmVsbHkgZ2V0IEZ1bmN0aW9uIGZyb20gdmFsdWVcclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byBnZXRcclxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgIFRoZSB2YWx1ZSB0byBnZXRcclxuICpcclxuICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAqXHJcbiAqL1xyXG5TYWZlLmZ1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSl7XHJcblxyXG4gICAgaWYoVHlwZS5pc0Z1bmN0aW9uKHZhbHVlKSl7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCBUeXBlLmlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSApe1xyXG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCF2YWx1ZSl7XHJcbiAgICAgICAgdmFsdWUgPSBmdW5jdGlvbigpeyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogU2FmZWxseSBnZXQgdGhlIHZhbHVlLiBUaGlzIG5ldmVyIHJldHVybiB1bmRlZmluZWQhXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gZ2V0XHJcbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlICBUaGUgdmFsdWUgdG8gZ2V0XHJcbiAqXHJcbiAqIEByZXR1cm4geyp9XHJcbiAqXHJcbiAqL1xyXG5TYWZlLnZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSl7XHJcblxyXG4gICAgaWYoVHlwZS5pc0RlZmluZWQodmFsdWUpKXtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIFR5cGUuaXNEZWZpbmVkKGRlZmF1bHRWYWx1ZSkgKXtcclxuICAgICAgICByZXR1cm4gU2FmZS52YWx1ZShkZWZhdWx0VmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBTYWZlbGx5IGdldHMgYW4gaW5zdGFuY2Ugb2YgdGhlIENsYXNzLiBJZiB0aGUgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgQ2xhc3NcclxuICogcmV0dXJuIGl0LCBvdGhlcndpc2UgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBDbGFzc1xyXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqXHJcbiAqL1xyXG5TYWZlLmluc3RhbmNlT2YgPSBmdW5jdGlvbih2YWx1ZSwgQ2xhc3Mpe1xyXG5cclxuICAgIHZhbHVlICAgPSBTYWZlLm9iamVjdCh2YWx1ZSk7XHJcbiAgICBDbGFzcyAgID0gU2FmZS5mdW5jdGlvbihDbGFzcyk7XHJcblxyXG4gICAgaWYoIHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsYXNzKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBTYWZlbGx5IGdldHMgdGhlIFJlZ0V4cFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlXHJcbiAqXHJcbiAqIEByZXR1cm4ge31cclxuICpcclxuICovXHJcblNhZmUucmVnZXhwID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSl7XHJcblxyXG4gICAgaWYoVHlwZS5pc1N0cmluZyh2YWx1ZSkpe1xyXG4gICAgICAgIHJldHVybiBJbnRlcm5hbC5zdHJpbmdUb1JlZ0V4cCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoVHlwZS5pc1JlZ0V4cCh2YWx1ZSkpe1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZihUeXBlLmlzRGVmaW5lZChkZWZhdWx0VmFsdWUpKXtcclxuICAgICAgICByZXR1cm4gU2FmZS5yZWdleHAoZGVmYXVsdFZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW50ZXJuYWwuc3RyaW5nVG9SZWdFeHAoKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogU2FmZWxseSBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAqXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcblNhZmUubGVuZ3RoID0gZnVuY3Rpb24odmFsKXtcclxuXHJcbiAgICBpZiggVHlwZS5pc1N0cmluZyh2YWwpIHx8IFR5cGUuaXNBcnJheSh2YWwpICl7XHJcbiAgICAgICAgcmV0dXJuIHZhbC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIFR5cGUuaXNPYmplY3QodmFsKSApe1xyXG4gICAgICAgIHJldHVybiBfLmtleXModmFsKS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIFR5cGUuaXNOdW1iZXIodmFsKSApe1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIFR5cGUuaXNCb29sZWFuKHZhbCkgKXtcclxuICAgICAgICByZXR1cm4gdmFsID8gMSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBDb2VyY2UgdGhlIGdpdmVuIHZhbHVlIGZyb20gdGhlIGV4cGVjdGVkIHR5cGVcclxuICpcclxuICogQHBhcmFtICB7Kn0gdmFsdWVcclxuICogQHBhcmFtICB7Kn0gZXhwZWN0ZWRcclxuICogQHJldHVybiB7Kn1cclxuICpcclxuICovXHJcblNhZmUuY29lcmNlID0gZnVuY3Rpb24odmFsdWUsIGV4cGVjdGVkKXtcclxuXHJcbiAgICB2YXIgZXhwZWN0ZWRUeXBlICAgID0gVHlwZS5vZihleHBlY3RlZCksXHJcbiAgICAgICAgdHlwZSAgICAgICAgICAgID0gVHlwZS5vZih2YWx1ZSk7XHJcblxyXG4gICAgaWYoZXhwZWN0ZWRUeXBlID09PSB0eXBlKXtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwZWN0aW5nIGEgbnVtYmVyXHJcbiAgICBpZiggVHlwZS5pc051bWJlcihleHBlY3RlZCkgKXtcclxuXHJcbiAgICAgICAgaWYoVHlwZS5pc051bWJlcih2YWx1ZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4cGVjdGluZyBhIHN0cmluZ1xyXG4gICAgaWYoIFR5cGUuaXNTdHJpbmcoZXhwZWN0ZWQpICl7XHJcblxyXG4gICAgICAgIGlmKFR5cGUuaXNOdW1iZXIodmFsdWUpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHBlY3RpbmcgYSBib29sZWFuXHJcbiAgICBpZihUeXBlLmlzQm9vbGVhbihleHBlY3RlZCkpe1xyXG5cclxuICAgICAgICAvLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGEgbnVtYmVyXHJcbiAgICAgICAgaWYoVHlwZS5pc051bWJlcih2YWx1ZSkpe1xyXG5cclxuICAgICAgICAgICAgdmFsdWUgPSBTYWZlLm51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSAxKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodmFsdWUgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAvLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGEgc3RyaW5nXHJcbiAgICAgICAgZWxzZSBpZihUeXBlLmlzU3RyaW5nKHZhbHVlKSl7XHJcblxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZih2YWx1ZSA9PSBcInRydWVcIil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHZhbHVlID09IFwiZmFsc2VcIil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTYWZlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoXCIuL0N1c3RvbVNjaGVtYVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBBc3NlcnQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9Bc3NlcnRcIiksXG4gICAgVHlwZXMgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vVHlwZXNcIik7XG5cbi8qKlxuICpcbiAqIFNjaGVtYSBjbG9uZSBtZXRob2RzXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqXG4gKi9cbnZhciBTY2hlbWFDbG9uZSA9IGZ1bmN0aW9uKENsYXNzKXtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2xvbmUgdGhlIGN1cnJlbnQgc2NoZW1hLiBJZiBgb3B0aW9uc2AgaXMgZGVmaW5lZCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAqIGN1cnJlbnQgaW5zdGFuY2UgZGF0YSBvZiB0aGUgbmV3IFNjaGVtYURlZmluaXRpb24uXG4gICAgICogXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7Q2xhc3N9XG4gICAgICogXG4gICAgICovXG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG4gICAgICAgIEFzc2VydC5pbnN0YW5jZU9mKFR5cGVzLlNjaGVtYURlZmluaXRpb24pXG4gICAgICAgICAgICAuYXNzZXJ0KHRoaXMpO1xuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDbGFzcyhcbiAgICAgICAgICAgIF8uZXh0ZW5kKHt9LCB0aGlzLCBvcHRpb25zKSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXG4gICAgfTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFDbG9uZTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXG4gICAgU2FmZSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vU2FmZVwiKSxcbiAgICBUeXBlICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9UeXBlXCIpLFxuICAgIEFzc2VydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL0Fzc2VydFwiKSxcbiAgICBFeGNlcHRpb24gICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpLFxuICAgIFR5cGVzICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uL1R5cGVzXCIpLFxuICAgIFNjaGVtYVJlc3VsdCAgICAgICAgICAgID0gcmVxdWlyZShcIi4uL1NjaGVtYVJlc3VsdFwiKSxcbiAgICBTY2hlbWFFeGVjdXRpb25IZWxwZXIgICA9IHJlcXVpcmUoXCIuL1NjaGVtYUV4ZWN1dGlvbkhlbHBlclwiKTtcblxuLyoqXG4gKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBjb21wbGV4IHZhbHVlXG4gKlxuICogQHBhcmFtICB7U2NoZW1hRGVmaW5pdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYVJlc3VsdH1cbiAqXG4gKi9cbnZhciBleGVjdXRlID0gZnVuY3Rpb24oc2NoZW1hLCB2YWx1ZSwgdmFsaWRhdGlvbkZucyl7XG5cbiAgICAvKiBqc2hpbnQgLVcwNjQgKi9cbiAgICB2YXIgcmVzdWx0ID0gU2NoZW1hUmVzdWx0KHNjaGVtYSwgdmFsdWUpO1xuXG4gICAgLy8vIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc2NoZW1hXG4gICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBTY2hlbWFFeGVjdXRpb25IZWxwZXIucHJlcGFyZVZhbHVlKHNjaGVtYSwgdmFsdWUsIHZhbGlkYXRpb25GbnMpO1xuICAgICAgICByZXN1bHQuc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaChlKXtcbiAgICAgICAgcmVzdWx0LmFkZEVycm9yKGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vLyBpZiB2YWx1ZSBpcyBudWxsIHRoZXJlJ3Mgbm8gbmVlZCB0byBpdGVyYXRlXG4gICAgLyoganNoaW50IC1XMDQxICovXG4gICAgaWYodmFsdWUgPT0gbnVsbCl7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8vIGlmIGlzIGV4cGVjdGluZyBhbnkgdmFsdWUgcmV0dXJuIGl0IHN0cmFpZ2h0IGF3YXlcbiAgICBpZihzY2hlbWEuYW55KXtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLy8gaWYgaXMgbm90IGEgY29tcGxleCB2YWx1ZSByZXR1cm4gdGhlIHZhbHVlXG4gICAgaWYoIXNjaGVtYS5pc0FycmF5KCkgJiYgIXNjaGVtYS5pc09iamVjdCgpKXtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLy8gcHJlcGFyZSB0aGUgc2NoZW1hIGZvciBleGVjdXRpb24gYWdhaW5zdCB0aGUgdmFsdWUuIFRoaXMgd2lsbCBleHBhbmRcbiAgICAvLy8gdGhlIHNjaGVtYSB0byBtYXRjaCB0aGUgdmFsdWVcbiAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSBTY2hlbWFFeGVjdXRpb25IZWxwZXIucHJlcGFyZVNjaGVtYShzY2hlbWEsIHZhbHVlLCB2YWxpZGF0aW9uRm5zKTtcbiAgICB9XG4gICAgY2F0Y2goZSl7XG4gICAgICAgIHJlc3VsdC5hZGRFcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLy8gcmVzZXQgdGhlIHJlc3VsdCB2YWx1ZSBiZWZvcmUgaXRlcmF0aW5nXG4gICAgcmVzdWx0ID0gU2NoZW1hUmVzdWx0KHNjaGVtYSwgc2NoZW1hLmlzT2JqZWN0KCkgPyB7fSA6IFtdKTtcblxuICAgIC8vLyByZWN1cnNpb24gb3ZlciB0aGUgaW5uZXIgdmFsdWVzIG9mIHRoZSBzY2hlbWFcbiAgICBfLmVhY2goc2NoZW1hLnNjaGVtYSwgZnVuY3Rpb24oaW5uZXJTY2hlbWEsIGtleSl7XG5cbiAgICAgICAgLy8vIHJlY3Vyc2l2ZSBleGVjdXRlIHRoZSBzY2hlbWFcbiAgICAgICAgdmFyIGlubmVyUmVzdWx0ID0gaW5uZXJTY2hlbWEuZXhlY3V0ZSh2YWx1ZVtrZXldLCB2YWxpZGF0aW9uRm5zKTtcblxuICAgICAgICAvLy8gYWRkIHJlc3VsdCB0byBlcnJvcnNcbiAgICAgICAgaWYoIWlubmVyUmVzdWx0LmlzVmFsaWQoKSl7XG4gICAgICAgICAgICByZXN1bHQuYWRkRXJyb3IoaW5uZXJSZXN1bHQuZ2V0RXJyb3JzKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8vIGdldCB0aGUgaW5uZXIgcmVzdWx0IHZhbHVlXG4gICAgICAgIHZhciBpbm5lclZhbHVlID0gaW5uZXJSZXN1bHQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLy8gaWYgaXMgYW4gb2JqZWN0IGFuZCB2YWx1ZSBpcyBub3QgcmVxdWlyZWQgaWdub3JlIVxuICAgICAgICBpZihzY2hlbWEuaXNPYmplY3QoKSAmJiBpbm5lclZhbHVlID09IG51bGwgJiYgIWlubmVyU2NoZW1hLnJlcXVpcmVkKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgIHJlc3VsdC5zZXRWYWx1ZShpbm5lclZhbHVlLCB7IGluZGV4OiBrZXkgfSk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICpcbiAqIFNjaGVtYSBleGVjdXRpb24gbWV0aG9kcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIEV4ZWN1dGlvbiA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV4ZWN1dGUgU2NoZW1hIGFnYWluc3QgdGhlIHZhbHVlLiBUaGlzIHdpbGwgcGVyZm9ybSBhIHRvcC1kb3duIHJlY3Vyc2lvbiBvblxuICAgICAqIHRoZSBnaXZlbiBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NjaGVtYURlZmluaXRpb259IHNjaGVtYVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U2NoZW1hUmVzdWx0fVxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24odmFsdWUsIHZhbGlkYXRpb25GbnMpe1xuXG4gICAgICAgIC8vLyB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIGFyZ3VtZW50c1xuICAgICAgICBBc3NlcnQuaW5zdGFuY2VPZihUeXBlcy5TY2hlbWFEZWZpbml0aW9uKVxuICAgICAgICAgICAgLmFzc2VydCh0aGlzKTtcblxuICAgICAgICAvLy8gaWYgaXQgaGFzIG5vIGVycm9ycyBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdFxuICAgICAgICB2YXIgcmVzdWx0ID0gZXhlY3V0ZSh0aGlzLCB2YWx1ZSwgdmFsaWRhdGlvbkZucyk7XG5cbiAgICAgICAgLy8vIGlmIHRoZXJlJ3MgZXJyb3IgdHJ5IHRvIHJlY292ZXIgYnkgYXBwbHlpbmcgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgaWYoIXJlc3VsdC5pc1ZhbGlkKCkpe1xuXG4gICAgICAgICAgICAvLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlIGlmIGl0IGNhblxuICAgICAgICAgICAgLyoganNoaW50IC1XMDQxICovXG4gICAgICAgICAgICBpZih0aGlzLmRlZmF1bHQgIT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJlc3VsdCA9IGV4ZWN1dGUodGhpcywgdGhpcy5kZWZhdWx0LCB2YWxpZGF0aW9uRm5zKTtcblxuICAgICAgICAgICAgICAgIC8vLyBpZiBkZWZhdWx0IHZhbHVlIGlzIHZhbGlkIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLy8gdmFsdWVcbiAgICAgICAgICAgICAgICBpZihkcmVzdWx0LmlzVmFsaWQoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRyZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbjtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBTYWZlICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL1NhZmVcIiksXG4gICAgVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9UeXBlXCIpLFxuICAgIEFzc2VydCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vQXNzZXJ0XCIpLFxuICAgIEV4Y2VwdGlvbkxpc3QgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vRXhjZXB0aW9uL0V4Y2VwdGlvbkxpc3RcIiksXG4gICAgRXhjZXB0aW9uICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpLFxuICAgIFR5cGVzICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vVHlwZXNcIik7XG4gICAgXG5cbi8qKlxuICpcbiAqIFByZXBhcmVzIGFuZCB2YWxpZGF0ZXMgdGhlIFNjaGVtYURlZmluaXRpb24gZm9yIHRoZSBnaXZlbiBcbiAqIHZhbHVlLlxuICpcbiAqIEB0aHJvdyB7RXhjZXB0aW9uTGlzdH1cbiAqXG4gKiBAcGFyYW0gIHtTY2hlbWFEZWZpbml0aW9ufSBzY2hlbWFcbiAqIEBwYXJhbSAgeyp9ICAgICAgdmFsdWVcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsaWRhdGlvbkZuc1xuICpcbiAqIEByZXR1cm4ge1NjaGVtYURlZmluaXRpb259XG4gKlxuICovXG52YXIgcHJlcGFyZVNjaGVtYSA9IGZ1bmN0aW9uKHNjaGVtYSwgdmFsdWUsIHZhbGlkYXRpb25GbnMpe1xuXG4gICAgdmFsdWUgICAgICAgICAgID0gU2FmZS52YWx1ZSh2YWx1ZSk7XG4gICAgdmFsaWRhdGlvbkZucyAgID0gU2FmZS5vYmplY3QodmFsaWRhdGlvbkZucyk7XG5cbiAgICAvKiBqc2hpbnQgLVcwNjQgKi9cbiAgICB2YXIgZXJyb3JzID0gbmV3IEV4Y2VwdGlvbkxpc3QoKTtcblxuICAgIC8vLyBJZiBub3QgZGVmaW5lZCBhbmQgaXRzIHJlcXVpcmVkIHRocm93XG4gICAgLyoganNoaW50IC1XMDQxICovXG4gICAgaWYoc2NoZW1hLnJlcXVpcmVkICYmIHZhbHVlID09IG51bGwpe1xuICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgIG5ldyBFeGNlcHRpb24oXCJWQUxJREFUSU9OX1JFUVVJUkVEXCIpKTtcbiAgICB9XG4gICAgLyoganNoaW50IC1XMDQxICovXG4gICAgZWxzZSBpZighc2NoZW1hLnJlcXVpcmVkICYmIHZhbHVlID09IG51bGwpe1xuICAgICAgICAvLy8gY29udGludWUgKG9wdGlvbmFsIHBhcmFtZXRlcilcbiAgICB9XG4gICAgLy8vIGNoZWNrIGZvciBjb21wYXRpYmlsaXR5IG9mIHR5cGVzIGlmIGFueSBmbGFnIGlzIG5vdCB1c2VkXG4gICAgZWxzZSBpZighc2NoZW1hLmFueSAmJiBUeXBlLm9mKHNjaGVtYS5zY2hlbWEpICE9PSBUeXBlLm9mKHZhbHVlKSl7XG4gICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgbmV3IEV4Y2VwdGlvbihcIlZBTElEQVRJT05fVFlQRVwiLCB7IGV4cGVjdGVkOiBUeXBlLm9mKHNjaGVtYS5zY2hlbWEpLCB2YWx1ZTogVHlwZS5vZih2YWx1ZSkgfSkpO1xuICAgIH1cblxuICAgIC8vLyBpZiB0aGVyZSdzIGVycm9yIHRocm93IHRoZW1cbiAgICBpZihlcnJvcnMubGVuZ3RoKXtcbiAgICAgICAgdGhyb3cgZXJyb3JzO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG5cbn07XG5cbi8qKlxuICpcbiAqIFByZXBhcmVzIGFuZCB2YWxpZGF0ZXMgdGhlIFNjaGVtYURlZmluaXRpb24gZm9yIHRoZSBnaXZlbiBcbiAqIG9iamVjdC5cbiAqXG4gKiBAdGhyb3dzIHtFeGNlcHRpb25MaXN0fSBJZiBhIHZhbGlkYXRpb24gZnVuY3Rpb24gb2NjdXJzXG4gKiBcbiAqIEBwYXJhbSAge1NjaGVtYURlZmluaXRpb259IHNjaGVtYVxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYURlZmluaXRpb259XG4gKlxuICovXG52YXIgcHJlcGFyZU9iamVjdCA9IGZ1bmN0aW9uKHNjaGVtYSwgdmFsdWUpe1xuXG4gICAgdmFsdWUgPSBTYWZlLm9iamVjdCh2YWx1ZSk7XG5cbiAgICAvKiBqc2hpbnQgLVcwNjQgKi9cbiAgICB2YXIgZXJyb3JzICAgICAgPSBuZXcgRXhjZXB0aW9uTGlzdCgpLFxuICAgICAgICByZXN1bHQgICAgICA9IHt9LFxuICAgICAgICB2YWx1ZUtleXMgICA9IF8ua2V5cyh2YWx1ZSk7XG5cbiAgICBfLmVhY2goXG4gICAgICAgIHNjaGVtYS5zY2hlbWEsXG4gICAgICAgIGZ1bmN0aW9uKHNjaGVtYVZhbHVlLCBrZXkpe1xuXG4gICAgICAgICAgICB2YXIgaXNSZWdFeHAgPSBUeXBlLmlzUmVnRXhwU3RyKGtleSksXG4gICAgICAgICAgICAgICAga2V5cyAgICAgPSBbXTtcblxuICAgICAgICAgICAgLy8vIGtleSBpcyBub3QgYSByZWdleHAgc3RyaW5nXG4gICAgICAgICAgICBpZighaXNSZWdFeHApe1xuICAgICAgICAgICAgICAgIGtleXMgPSBbIGtleSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8vIGtleSBpcyBhIHJlZ2V4cCBzdHJpbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwICA9IFNhZmUucmVnZXhwKGtleSk7XG4gICAgICAgICAgICAgICAga2V5cyA9IF8uZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBpZiB0aGVyZSdzIGEgZGVmaW5pdGlvbiBvZiB0aGUgc2NoZW1hIGRvbid0IGluY2x1ZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNjaGVtYS5zY2hlbWFba2V5XSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLyB0ZXN0IGlmIHRoZSByZWdleCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhcmVnZXhwLmV4ZWMoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5lYWNoKGtleXMsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFt2YWxdID0gc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIHJldHVybiBzY2hlbWEuY2xvbmUoe1xuICAgICAgICBzY2hlbWE6IHJlc3VsdFxuICAgIH0pO1xuXG59O1xuXG4vKipcbiAqXG4gKiBQcmVwYXJlcyBhbmQgdmFsaWRhdGVzIHRoZSBTY2hlbWFEZWZpbml0aW9uIGZvciB0aGUgZ2l2ZW4gXG4gKiBhcnJheS5cbiAqXG4gKiBAdGhyb3dzIHtFeGNlcHRpb25MaXN0fSBJZiBhIHZhbGlkYXRpb24gZXJyb3Igb2NjdXJzXG4gKlxuICogQHBhcmFtICB7U2NoZW1hRGVmaW5pdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0gIHtBcnJheX0gdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWFEZWZpbml0aW9ufVxuICpcbiAqL1xudmFyIHByZXBhcmVBcnJheSA9IGZ1bmN0aW9uKHNjaGVtYSwgdmFsdWUpe1xuXG4gICAgdmFsdWUgPSBTYWZlLmFycmF5KHZhbHVlKTtcblxuICAgIC8qIGpzaGludCAtVzA2NCAqL1xuICAgIHZhciBlcnJvcnMgID0gbmV3IEV4Y2VwdGlvbkxpc3QoKSxcbiAgICAgICAgcmVzdWx0ICA9IFtdLFxuICAgICAgICBpbmRleCAgID0gMDtcblxuICAgIGlmKCAhc2NoZW1hLnJlcGVhdGFibGUgJiYgc2NoZW1hLnNjaGVtYS5sZW5ndGggIT0gdmFsdWUubGVuZ3RoICl7XG4gICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgbmV3IEV4Y2VwdGlvbihcIlZBTElEQVRJT05fSU5WQUxJRF9MSVNUX0xFTkdUSFwiLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIGV4cGVjdGVkOiBzY2hlbWEuc2NoZW1hLmxlbmd0aCB9KSk7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1hLnJlcGVhdGFibGUpe1xuXG4gICAgICAgIHZhciBpc1JlcGVhdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8vLyBpZiB0aGUgdmFsdWUgY29udGFpbnMgZWxlbWVudHMgY2hlY2sgaWYgaXRzIGRpdmlzaWJsZSBieSBcbiAgICAgICAgLy8vIHRoZSByZXBlYXQgY291bnRcbiAgICAgICAgaWYodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5sZW5ndGggIT0gc2NoZW1hLnNjaGVtYS5sZW5ndGgpe1xuICAgICAgICAgICAgaXNSZXBlYXRhYmxlID0gdmFsdWUubGVuZ3RoICUgc2NoZW1hLnNjaGVtYS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8vIG90aGVyd2lzZSBpcyBvbmx5IHJlcGVhdGFibGUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vIFxuICAgICAgICAvLy8gZWxlbWVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVwZWF0YWJsZSA9ICh2YWx1ZS5sZW5ndGggPT09IHNjaGVtYS5zY2hlbWEubGVuZ3RoKSAmJiAodmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc1JlcGVhdGFibGUpe1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEV4Y2VwdGlvbihcIlZBTElEQVRJT05fSU5WQUxJRF9MSVNUX0xFTkdUSF9NVUxUSVBMRV9PRlwiLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIGV4cGVjdGVkOiBzY2hlbWEuc2NoZW1hLmxlbmd0aCB9KSk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vLyBpZiBlcnJvcnMgZXhpc3QgdGhyb3cgdGhlbVxuICAgIGlmKGVycm9ycy5sZW5ndGgpe1xuICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgfVxuXG4gICAgLy8vIGNyZWF0ZSB0aGUgcmVzdWx0IGFycmF5XG4gICAgZm9yKHZhciBpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIGlmKHNjaGVtYS5yZXBlYXRhYmxlICYmIGluZGV4ID49IHNjaGVtYS5zY2hlbWEubGVuZ3RoKXtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHNjaGVtYS5zY2hlbWFbaW5kZXgrK10pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5jbG9uZSh7XG4gICAgICAgIHNjaGVtYTogcmVzdWx0XG4gICAgfSk7XG5cbn07XG5cbi8qKlxuICpcbiAqIFNjaGVtYSBDb252ZXJzaW9uIGNvbnZlcnNpb24gbWV0aG9kc1xuICogXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogXG4gKi9cbnZhciBTY2hlbWFFeGVjdXRpb25IZWxwZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzY2hlbWEsIGJ5IGFwcGx5aW5nIFxuICAgICAqIGRlZmF1bHQgdmFsdWVzLCBjb2VyY2luZyB2YWx1ZXMsIC4uLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXhjZXB0aW9uTGlzdH0gSWYgdGhlIHZhbGlkYXRpb24gZmFpbHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHtTY2hlbWFEZWZpbml0aW9ufSBzY2hlbWFcbiAgICAgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKlxuICAgICAqL1xuICAgIHByZXBhcmVWYWx1ZTogZnVuY3Rpb24oc2NoZW1hLCB2YWx1ZSwgdmFsaWRhdGlvbkZucyl7XG5cbiAgICAgICAgLy8vIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgYXJndW1lbnRzXG4gICAgICAgIEFzc2VydC5pbnN0YW5jZU9mKFR5cGVzLlNjaGVtYURlZmluaXRpb24pXG4gICAgICAgICAgICAuYXNzZXJ0KHNjaGVtYSk7XG5cbiAgICAgICAgdmFsdWUgPSBTYWZlLnZhbHVlKHZhbHVlKTtcblxuICAgICAgICAvLy8gaW5pdGFsaXplIHRoZSBsaXN0IG9mIGVycm9yc1xuICAgICAgICB2YXIgZXJyb3JzID0gbmV3IEV4Y2VwdGlvbkxpc3QoKTtcblxuICAgICAgICAvLy8gaWYgbm90IHN0cmljdCB0cmllcyB0byBub3JtYWxpemVcbiAgICAgICAgLy8vIHRoZSB2YWx1ZSAoZS5nLiBhIG51bWJlciBjYW4gYmUgb24gc3RyaW5nIHJlcHJlc2VudGF0aW9uIClcbiAgICAgICAgaWYoIXNjaGVtYS5zdHJpY3Qpe1xuICAgICAgICAgICAgdmFsdWUgPSBTYWZlLmNvZXJjZSh2YWx1ZSwgc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLy8gaWYgdGhlIHZhbHVlIGlzIHJlcXVpcmVkIGFuZCBpdCBoYXMgbm8gdmFsdWUsIHRocm93IGVycm9yXG4gICAgICAgIC8qIGpzaGludCAtVzA0MSAqL1xuICAgICAgICBpZihzY2hlbWEucmVxdWlyZWQgJiYgdmFsdWUgPT0gbnVsbCl7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgRXhjZXB0aW9uKFwiVkFMSURBVElPTl9SRVFVSVJFRFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZighc2NoZW1hLnJlcXVpcmVkICYmIHZhbHVlID09IG51bGwpe1xuICAgICAgICAgICAgLy8vIGlnbm9yZSwgYW5kIG5vdCBmYWxsYmFjayBvbiB0aGUgb3RoZXIgZWxzZSdzXG4gICAgICAgIH1cbiAgICAgICAgLy8vIGlmIGEgdmFsdWUgZXhpc3RzIGZpbmQgb3V0IGlmIHR5cGVzIGFyZSBjb21wYXRpYmxlXG4gICAgICAgIGVsc2UgaWYoIXNjaGVtYS5hbnkgJiYgVHlwZS5vZihzY2hlbWEuc2NoZW1hKSAhPT0gVHlwZS5vZih2YWx1ZSkpe1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEV4Y2VwdGlvbihcIlZBTElEQVRJT05fVFlQRVwiLCB7IGV4cGVjdGVkOiBUeXBlLm9mKHNjaGVtYS5zY2hlbWEpLCB2YWx1ZTogVHlwZS5vZih2YWx1ZSkgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8vIGFsd2F5cyBydW4gaWYgdmFsdWUgaXMgcmVxdWlyZWQgb3IgdmFsdWUgaXMgc3BlY2lmaWVkLlxuICAgICAgICBpZihzY2hlbWEucmVxdWlyZWQgfHwgdmFsdWUgIT1udWxsKXtcblxuICAgICAgICAgICAgXy5lYWNoKFxuICAgICAgICAgICAgICAgIHNjaGVtYS52YWxpZGF0aW9ucyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih2KXtcblxuICAgICAgICAgICAgICAgICAgICB2ID0gU2FmZS5vYmplY3Qodik7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuICAgICAgPSBTYWZlLmZ1bmN0aW9uKHZhbGlkYXRpb25GbnNbdi5uYW1lXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzICAgID0gU2FmZS5hcnJheSh2LmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHt9LCBbdmFsdWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb24oZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8vIGNoZWNrIGlmIGFueSBlcnJvciB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgaWYoZXJyb3JzLmxlbmd0aCl7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSBzY2hlbWEgZm9yIHRoZSBnaXZlbiB2YWx1ZS4gSWYgdGhlIHNjaGVtYSBpcyBhbiBvYmplY3QgaXQgXG4gICAgICogd2lsbCBleHBhbmQgaXRzIGtleXMgcmVndWxhciBleHByZXNzaW9ucy4gSWYgdGhlIHNjaGVtYSBpcyBhbiBhcnJheSBcbiAgICAgKiBpdCB3aWxsIGFwcGx5IGl0cyBwcm9wZXJ0aWVzIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0V4Y2VwdGlvbkxpc3R9IElmIGEgdmFsaWRhdGlvbiBlcnJvciBvY2N1cnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1NjaGVtYURlZmluaXRpb259IHNjaGVtYVxuICAgICAqIEBwYXJhbSAgeyp9ICAgICAgdmFsdWVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHZhbGlkYXRpb25GbnNcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJuIHtTY2hlbWFEZWZpbml0aW9ufVxuICAgICAqIFxuICAgICAqL1xuICAgIHByZXBhcmVTY2hlbWE6IGZ1bmN0aW9uKHNjaGVtYSwgdmFsdWUsIHZhbGlkYXRpb25GbnMpe1xuXG4gICAgICAgIEFzc2VydC5pbnN0YW5jZU9mKFR5cGVzLlNjaGVtYURlZmluaXRpb24pXG4gICAgICAgICAgICAuYXNzZXJ0KHNjaGVtYSk7XG5cbiAgICAgICAgLy8vIHByZXBhcmUgdGhlIHNjaGVtYVxuICAgICAgICBzY2hlbWEgPSBwcmVwYXJlU2NoZW1hKHNjaGVtYSwgdmFsdWUsIHZhbGlkYXRpb25GbnMpO1xuXG4gICAgICAgIC8vLyBwcmVwYXJlIHRoZSBvYmplY3RcbiAgICAgICAgaWYoc2NoZW1hLmlzT2JqZWN0KCkpe1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVPYmplY3Qoc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8vIHByZXBhcmUgdGhlIGFycmF5XG4gICAgICAgIGVsc2UgaWYoc2NoZW1hLmlzQXJyYXkoKSl7XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZUFycmF5KHNjaGVtYSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcblxuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFFeGVjdXRpb25IZWxwZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gICAgICAgPSByZXF1aXJlKFwibG9kYXNoXCIpLFxuICAgIFNhZmUgICAgPSByZXF1aXJlKFwiLi4vLi4vU2FmZVwiKTtcblxuLyoqXG4gKlxuICogU2VyaWFsaXphdGlvbiBtZXRob2RzIGZvciBTY2hlbWFEZWZpbml0aW9uLlxuICpcbiAqIEBzY29wZSB7U2NoZW1hRGVmaW5pdGlvbn1cbiAqIFxuICogQHR5cGUge09iamVjdH1cbiAqXG4gKi9cbnZhciBTZXJpYWxpemF0aW9uID0gZnVuY3Rpb24oKXtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VyaWFsaXplcyB0aGUgc2NoZW1hIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBfLmNsb25lRGVlcCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXNlcmlhbGl6ZXMgdGhlIG9iamVjdCBpbnRvIGEgU2NoZW1hRGVmaW5pdGlvblxuICAgICAqXG4gICAgICogQHJldHVybiB7U2NoZW1hRGVmaW5pdGlvbn1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuZGVzZXJpYWxpemUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih2YWx1ZSk7XG4gICAgfTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJpYWxpemF0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9UeXBlXCIpO1xuXG4vKipcbiAqXG4gKiBTY2hlbWEgdHlwZSBtZXRob2RzXG4gKlxuICogQHNjb3BlIHtTY2hlbWFEZWZpbml0aW9ufVxuICogXG4gKiBAdHlwZSB7T2JqZWN0fVxuICpcbiAqL1xudmFyIFNjaGVtYVR5cGUgPSBmdW5jdGlvbigpe1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNjaGVtYSBpcyBhbiBhcnJheVxuICAgICAqIFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogXG4gICAgICovXG4gICAgdGhpcy5pc0FycmF5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFR5cGUuaXNBcnJheSh0aGlzLnNjaGVtYSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzY2hlbWEgaXMgYW4gb2JqZWN0XG4gICAgICogXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBcbiAgICAgKi9cbiAgICB0aGlzLmlzT2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFR5cGUuaXNPYmplY3QodGhpcy5zY2hlbWEpO1xuICAgIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyAgICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaFwiKSxcbiAgICBUeXBlcyAgICAgICAgICAgPSByZXF1aXJlKFwiLi9UeXBlc1wiKSxcbiAgICBUeXBlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vVHlwZVwiKSxcbiAgICBTYWZlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vU2FmZVwiKSxcbiAgICBBc3NlcnQgICAgICAgICAgPSByZXF1aXJlKFwiLi4vQXNzZXJ0XCIpO1xuXG4vKipcbiAqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gYmV0d2VlbiB0aGUgdmFsdWUgYW5kIGEgU2NoZW1hRGVmaW5pdGlvbi5cbiAqIFRoaXMgY29udmVydHMgYSBwcmltaXRpdmUgdmFsdWUgdG8gYSBTY2hlbWFEZWZpbml0aW9uIHdpdGggZGVmYXVsdHNcbiAqIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKlxuICovXG52YXIgRGVmYXVsdHMgPSB7XG5cbiAgICBhcnJheTogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmKCFUeXBlLmlzQXJyYXkodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGRlZmF1bHQgdmFsdWUgYW5kIGl0cyByZXF1aXJlZCFcbiAgICAgICAgdmFsdWUgPSBuZXcgU2NoZW1hRGVmaW5pdGlvbih7XG4gICAgICAgICAgICBzY2hlbWE6IHZhbHVlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfSxcblxuICAgIG9iamVjdDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmKCFUeXBlLmlzT2JqZWN0KHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBkZWZhdWx0IHZhbHVlIGFuZCBpdHMgcmVxdWlyZWQhXG4gICAgICAgIHZhbHVlID0gbmV3IFNjaGVtYURlZmluaXRpb24oe1xuICAgICAgICAgICAgc2NoZW1hOiB2YWx1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBzdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICBpZighVHlwZS5pc1N0cmluZyh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gZGVmYXVsdCB2YWx1ZSBhbmQgaXRzIHJlcXVpcmVkIVxuICAgICAgICB2YWx1ZSA9IG5ldyBTY2hlbWFEZWZpbml0aW9uKHtcbiAgICAgICAgICAgIHNjaGVtYTogXCJcIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBudW1iZXI6IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICBpZighVHlwZS5pc051bWJlcih2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gZGVmYXVsdCB2YWx1ZSBhbmQgaXRzIHJlcXVpcmVkIVxuICAgICAgICB2YWx1ZSA9IG5ldyBTY2hlbWFEZWZpbml0aW9uKHtcbiAgICAgICAgICAgIHNjaGVtYTogMCxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBib29sZWFuOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgaWYoIVR5cGUuaXNCb29sZWFuKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBkZWZhdWx0IHZhbHVlIGFuZCBpdHMgcmVxdWlyZWQhXG4gICAgICAgIHZhbHVlID0gbmV3IFNjaGVtYURlZmluaXRpb24oe1xuICAgICAgICAgICAgc2NoZW1hOiBCb29sZWFuKHZhbHVlKSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbjogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmKCFUeXBlLmlzRnVuY3Rpb24odmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGRlZmF1bHQgdmFsdWUgYW5kIGl0cyByZXF1aXJlZCFcbiAgICAgICAgdmFsdWUgPSBuZXcgU2NoZW1hRGVmaW5pdGlvbih7XG4gICAgICAgICAgICBzY2hlbWE6IGZ1bmN0aW9uKCl7fSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbn07XG5cbi8qKlxuICpcbiAqIE5vcm1hbGl6ZSB0aGUgc2NoZW1hIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIHN0b3JpbmcgdW5uZWNlc3NhcnkgXG4gKiBkYXRhIGFuZCBrZWVwIHRoZSB2YWx1ZXMgY29uc2lzdGVudCBhY3Jvc3MgdXNhZ2VzLlxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfVxuICogXG4gKi9cbnZhciBub3JtYWxpemVTY2hlbWFWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgIHZhbHVlID0gU2FmZS52YWx1ZSh2YWx1ZSk7XG5cbiAgICBpZihUeXBlLmlzU3RyaW5nKHZhbHVlKSl7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGlmKFR5cGUuaXNOdW1iZXIodmFsdWUpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoVHlwZS5pc0Jvb2xlYW4odmFsdWUpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuXG59O1xuXG4vKipcbiAqXG4gKiBDb21waWxlIHRoZSBnaXZlbiBzY2hlbWEgZGVmaW5pdGlvbiBvciBjb21wYXRpYmxlIFxuICogc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSB7Kn0gICAgICAgc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWFEZWZpbml0aW9ufVxuICpcbiAqL1xudmFyIGNvbXBpbGUgPSBmdW5jdGlvbihzY2hlbWEsIG9wdGlvbnMpe1xuXG4gICAgLy8vIGV4dGVuc2liaWxpdHkgcG9pbnQgLSBwcmVwYXJlIHRoZSB2YWx1ZSBiZWZvcmUgdGhlIFxuICAgIC8vLyBjb21waWxhdGlvblxuICAgIHNjaGVtYSA9IG9wdGlvbnMucHJlcGFyZShzY2hlbWEpO1xuXG4gICAgLy8vIGFwcGx5IHRoZSBkZWZhdWx0cyBhbmQgY3JlYXRlIHRoZSBTY2hlbWFEZWZpbml0aW9uIGlmIGFuIG9iamVjdCBcbiAgICAvLy8gaGFzIGJlZW4gcHJvdmlkZWRcbiAgICBpZighVHlwZS5pbnN0YW5jZU9mKHNjaGVtYSwgVHlwZXMuU2NoZW1hRGVmaW5pdGlvbikpe1xuICAgICAgICBzY2hlbWEgPSBEZWZhdWx0cy5vYmplY3Qoc2NoZW1hKSB8fCBEZWZhdWx0cy5hcnJheShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgRGVmYXVsdHMuc3RyaW5nKHNjaGVtYSkgfHwgRGVmYXVsdHMubnVtYmVyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBEZWZhdWx0cy5ib29sZWFuKHNjaGVtYSkgfHwgRGVmYXVsdHMuZnVuY3Rpb24oc2NoZW1hKTtcbiAgICB9XG5cbiAgICAvLy8gY29udmVydCB0aGUgc2NoZW1hXG4gICAgdmFyIGlzQXJyYXkgID0gVHlwZS5pc0FycmF5KHNjaGVtYS5zY2hlbWEpLFxuICAgICAgICBpc09iamVjdCA9IFR5cGUuaXNPYmplY3Qoc2NoZW1hLnNjaGVtYSk7XG5cbiAgICAvLy8gaXRlcmF0ZSBvdmVyIHRoZSBzdHJ1Y3R1cmUgaW4gb3JkZXIgdG8gY29tcGlsZSB0aGUgc2NoZW1hXG4gICAgaWYoaXNBcnJheSB8fCBpc09iamVjdCl7XG5cbiAgICAgICAgXy5lYWNoKHNjaGVtYS5zY2hlbWEsIGZ1bmN0aW9uKHZhbCwgaW5kZXgpe1xuICAgICAgICAgICAgdmFyIGlubmVyU2NoZW1hID0gY29tcGlsZSh2YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgc2NoZW1hLnNjaGVtYVtpbmRleF0gPSBpbm5lclNjaGVtYTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hO1xuXG59O1xuXG4vKipcbiAqXG4gKiBBIFNjaGVtYURlZmluaXRpb24gY2xhc3MuIENvbnRhaW5zIGFsbCB0aGUgcnVsZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB3aGVuXG4gKiBldmFsdWF0aW5nIGl0IGFnYWluc3QgYSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqL1xudmFyIFNjaGVtYURlZmluaXRpb24gPSBmdW5jdGlvbihvcHRpb25zKXtcblxuICAgIG9wdGlvbnMgPSBTYWZlLm9iamVjdChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2NoZW1hRGVmaW5pdGlvbiBtb2R1bGUgQVBJXG4gICAgICogXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBcbiAgICAgKi9cbiAgICB2YXIgc2VsZiA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHR5cGUgb2Ygc2NoZW1hXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTY2hlbWFEZWZpbml0aW9ufVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2NoZW1hOiBub3JtYWxpemVTY2hlbWFWYWx1ZShvcHRpb25zLnNjaGVtYSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEZsYWcgdGhhdCBlbmFibGVzIHN0cmljdCBjb252ZXJ0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHN0cmljdDogU2FmZS5ib29sZWFuKG9wdGlvbnMuc3RyaWN0LCBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBmbGFnLiBUaGlzIG1lYW5zIHRoYXQgYW55IHZhbHVlIGlzIGFjY2VwdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFueTogU2FmZS5ib29sZWFuKG9wdGlvbnMuYW55LCBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBzY2hlbWFcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0OiBvcHRpb25zLmRlZmF1bHQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIElzUmVxdWlyZWQgZmxhZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkOiBTYWZlLmJvb2xlYW4ob3B0aW9ucy5yZXF1aXJlZCwgdHJ1ZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlcGVhdGFibGUgZmxhZy4gVGhpcyBtZWFucywgZS5nLiBpZiB0aGUgc2NoZW1hIGlzIGFuIGFycmF5IHRoZSBpbm5lciBzY2hlbWEgY2FuXG4gICAgICAgICAqIGJlIHJlcGVhdGFibGUgYnkgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVwZWF0YWJsZTogU2FmZS5ib29sZWFuKG9wdGlvbnMucmVwZWF0YWJsZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9ucyB0byBhcHBseSB0byB0aGlzIFNjaGVtYSBub2RlLiBFYWNoIHZhbGlkYXRpb24gZnVuY3Rpb24gaXNcbiAgICAgICAgICogcmVwcmVzZW50ZWQgYnk6IHsgbmFtZTogJ2ZuJywgYXJnczogJycgfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZGF0aW9uczogU2FmZS5hcnJheShvcHRpb25zLnZhbGlkYXRpb25zKSxcblxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFR5cGVzLlNjaGVtYURlZmluaXRpb24oc2VsZik7XG5cbn07XG5cbi8qKlxuICpcbiAqIEBjbGFzc1xuICogQSBTY2hlbWFEZWZpbml0aW9uIGNvbXBpbGVkIGNsYXNzLiBUaGlzIHJlcHJlc2VudHMgYSBmdWxseSBjb21waWxlZCBcbiAqIGluc3RhbmNlIG9mIGFsbCBpbm5lciBzdHJ1Y3R1cmVzIHRoYXQgcmVwcmVzZW50cyBhIFNjaGVtYS5cbiAqXG4gKiBBIGZ1bGwgaXRlcmF0aW9uIG92ZXIgdGhlIGVudGlyZSBzY2hlbWEgc3RydWN0dXJlIHdpbGwgYmUgcGVyZm9ybWVkLlxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgVGhlIFNjaGVtYURlZmluaXRpb24gZGF0YSBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjT3B0aW9ucyBUaGUgY29tcGlsYXRpb24gb3B0aW9uc1xuICpcbiAqL1xudmFyIENvbXBpbGVkU2NoZW1hRGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNPcHRpb25zKXtcblxuICAgIC8vLyBub3JtYWxpemUgdGhlIGdpdmVuIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAgICBjT3B0aW9ucyA9IFNhZmUub2JqZWN0KGNPcHRpb25zKTtcbiAgICBjT3B0aW9ucy5jb21waWxlID0gU2FmZS5ib29sZWFuKGNPcHRpb25zLmNvbXBpbGUsIHRydWUpO1xuICAgIGNPcHRpb25zLnByZXBhcmUgPSBTYWZlLmZ1bmN0aW9uKGNPcHRpb25zLnByZXBhcmUsIGZ1bmN0aW9uKHYpeyByZXR1cm4gdjsgfSk7XG5cbiAgICAvKiBqc2hpbnQgLVcwNjQgKi9cbiAgICB2YXIgc2NoZW1hID0gU2NoZW1hRGVmaW5pdGlvbihvcHRpb25zKTtcblxuICAgIC8vLyB0cmF2ZXJzZSB0aGUgc2NoZW1hIHN0cnVjdHVyZSBjb21waWxpbmcgaXRzIGlubmVyIGVsZW1lbnRzXG4gICAgaWYoY09wdGlvbnMuY29tcGlsZSl7XG4gICAgICAgIHJldHVybiBjb21waWxlKHNjaGVtYSwgY09wdGlvbnMpOyAgICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNjaGVtYTtcblxufTtcblxuLy8vIGluY2x1ZGUgdHlwZSBjaGVja2luZyBNaXhpblxucmVxdWlyZShcIi4vTWl4aW5zL1NjaGVtYVR5cGVcIilcbiAgICAuY2FsbChUeXBlcy5TY2hlbWFEZWZpbml0aW9uLnByb3RvdHlwZSk7XG5cbi8vLyBpbmNsdWRlIGNsb25lIE1peGluIGZ1bmN0aW9uYWxpdHlcbnJlcXVpcmUoXCIuL01peGlucy9TY2hlbWFDbG9uZVwiKVxuICAgIC5hcHBseShUeXBlcy5TY2hlbWFEZWZpbml0aW9uLnByb3RvdHlwZSwgWyBDb21waWxlZFNjaGVtYURlZmluaXRpb24gXSk7XG5cbi8vLyBpbmNsdWRlIGV4ZWN1dGlvbiBNaXhpbiBmdW5jdGlvbmFsaXR5XG5yZXF1aXJlKFwiLi9NaXhpbnMvU2NoZW1hRXhlY3V0aW9uXCIpXG4gICAgLmNhbGwoVHlwZXMuU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuXG4vLy8gaW5jbHVkZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uYWxpdHlcbnJlcXVpcmUoXCIuL01peGlucy9TY2hlbWFTZXJpYWxpemF0aW9uXCIpXG4gICAgLmNhbGwoVHlwZXMuU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVkU2NoZW1hRGVmaW5pdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXG4gICAgVHlwZSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vVHlwZVwiKSxcbiAgICBTYWZlICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi9TYWZlXCIpLFxuICAgIEV4Y2VwdGlvbkxpc3QgICAgICAgICAgID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbi9FeGNlcHRpb25MaXN0XCIpLFxuICAgIFR5cGVzICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vVHlwZXNcIiksXG4gICAgU2NoZW1hRGVmaW5pdGlvbiAgICAgICAgPSByZXF1aXJlKFwiLi9TY2hlbWFEZWZpbml0aW9uXCIpO1xuXG4vKipcbiAqXG4gKiBAY2xhc3NcbiAqIFRoZSBzY2hlbWEgZXZhbHVhdG9yIGZhY2FkZS4gVGhpcyB3aWxsIHNlcnZlIGFzIGludGVyZmFjZSB0byB0aGUgU2NoZW1hXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHsqfSAgICAgICBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSAgdmFsaWRhdGlvbkZuc1xuICogQHBhcmFtIHtPYmplY3R9ICBjT3B0aW9ucyAgICAgICAgVGhlIFNjaGVtYURlZmluaXRpb24gY29tcGlsYXRpb24gb3B0aW9uc1xuICpcbiAqL1xudmFyIFNjaGVtYUV2YWx1YXRvciA9IGZ1bmN0aW9uKHNjaGVtYSwgdmFsaWRhdGlvbkZucywgY09wdGlvbnMpe1xuXG4gICAgLyoganNoaW50IC1XMDY0ICovXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgY29tcGlsZWQgc2NoZW1hXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U2NoZW1hRGVmaW5pdGlvbn1cbiAgICAgKiBcbiAgICAgKi9cbiAgICBzY2hlbWEgPSBTY2hlbWFEZWZpbml0aW9uKHNjaGVtYSwgY09wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqXG4gICAgICovXG4gICAgdmFsaWRhdGlvbkZucyA9IFNhZmUub2JqZWN0KHZhbGlkYXRpb25GbnMpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTY2hlbWFFdmFsdWF0b3IgZXh0ZXJuYWwgQVBJXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqXG4gICAgICovXG4gICAgdmFyIHNlbGYgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEV2YWx1YXRlIGFuZCBnZXQgdGhlIGVycm9yc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHsqfSAgICAgIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdmFsaWRhdGlvbkZuc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtbRXJyb3JdfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JzOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzY2hlbWEuZXhlY3V0ZSh2YWx1ZSwgdmFsaWRhdGlvbkZucyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmdldEVycm9ycygpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRlc3RzIGlmIHRoZSBzY2hlbWEgaXMgdmFsaWQgYWdhaW5zdCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgeyp9ICB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NoZW1hLmV4ZWN1dGUodmFsdWUsIHZhbGlkYXRpb25GbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pc1ZhbGlkKCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgYWZ0ZXIgYXBwbHlpbmcgdGhlIHNjaGVtYS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyB7RXhjZXB0aW9uTGlzdH1cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Kn0gdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzY2hlbWEuZXhlY3V0ZSh2YWx1ZSwgdmFsaWRhdGlvbkZucyk7XG5cbiAgICAgICAgICAgIGlmKCFyZXN1bHQuaXNWYWxpZCgpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQuZ2V0RXJyb3JzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZ2V0VmFsdWUoKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXJpYWxpemUgdGhlIGN1cnJlbnQgU2NoZW1hXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5zZXJpYWxpemUoKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXNlcmlhbGl6ZSB0aGUgdmFsdWUuIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgU2NoZW1hRXZhbHVhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTY2hlbWFFdmFsdWF0b3J9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgICAgICAvLy8gdXNlIGEgcHJlcGFyZSBvcHRpb24gdGhhdCBidWlsZHMgdGhlIFNjaGVtYURlZmluaXRpb24gdG8gXG4gICAgICAgICAgICAvLy8gYXZvaWQgZmFsbGJhY2sgb24gdGhlIERlZmF1bHQgb2JqZWN0IGJ1aWxkZXJcbiAgICAgICAgICAgIHZhciBjT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcmVwYXJlOiBmdW5jdGlvbih2YWwpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8vIG1ha2Ugc3VyZSB0aGF0IHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyBhIFNjaGVtYURlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8vIE5PVEU6IGRvbid0IGNvbXBpbGUgdGhlIGlubmVyIHN0cnVjdHVyZXMgYmVjYXVzZSB0aGUgU2NoZW1hRXZhbHVhdG9yIHdpbGwgXG4gICAgICAgICAgICAgICAgICAgIC8vLyBkbyBpdFxuICAgICAgICAgICAgICAgICAgICBpZighVHlwZS5pbnN0YW5jZU9mKHZhbCwgVHlwZXMuU2NoZW1hRGVmaW5pdGlvbikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNjaGVtYURlZmluaXRpb24odmFsLCB7IGNvbXBpbGU6IGZhbHNlIH0pOyAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NoZW1hRXZhbHVhdG9yKHZhbHVlLCB2YWxpZGF0aW9uRm5zLCBjT3B0aW9ucyk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgVHlwZXMuU2NoZW1hRXZhbHVhdG9yKHNlbGYpO1xuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hRXZhbHVhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTYWZlICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uL1NhZmVcIiksXG4gICAgVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi9UeXBlXCIpLFxuICAgIEFzc2VydCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vQXNzZXJ0XCIpLFxuICAgIEV4Y2VwdGlvbkxpc3QgICAgICAgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uL0V4Y2VwdGlvbkxpc3RcIiksXG4gICAgVHlwZXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL1R5cGVzXCIpO1xuXG4vKipcbiAqXG4gKiBAY2xhc3NcbiAqIFN0b3JlcyB0aGUgcmVzdWx0IG9mIGEgc2NoZW1hIGV2YWx1YXRpb24uIEl0IHdpbGwga2VlcCByZWZlcmVuY2UgdG9cbiAqIHRoZSBnbG9iYWwgc3RydWN0dXJlIGFuZCB0aGUgZXZhbHVhdGlvbiB0cmVlIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHsqfSBzY2hlbWFcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqXG4gKlxuICovXG52YXIgU2NoZW1hUmVzdWx0ID0gZnVuY3Rpb24oc2NoZW1hLCB2YWx1ZSl7XG5cbiAgICAvLy8gdmFsaWRhdGUgc2NoZW1hXG4gICAgQXNzZXJ0Lmluc3RhbmNlT2YoVHlwZXMuU2NoZW1hRGVmaW5pdGlvbilcbiAgICAgICAgLmFzc2VydChzY2hlbWEpO1xuXG4gICAgLy8vIG1ha2Ugc3VyZSBpdHMgYSB2YWx1ZVxuICAgIHZhbHVlID0gU2FmZS52YWx1ZSh2YWx1ZSk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRvcC1kb3duIGdsb2JhbCBlcnJvciB0cmFja2luZ1xuICAgICAqXG4gICAgICogQHR5cGUge0V4Y2VwdGlvbkxpc3R9XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZXJyb3JzID0gbmV3IEV4Y2VwdGlvbkxpc3QoKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2NoZW1hUmVzdWx0IEFQSVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBzZWxmID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXQgdGhlIGVycm9yc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtFeGNlcHRpb25MaXN0fVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXJyb3JzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWRkIHRoZSBnaXZlbiBlcnJvcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFeGNlcHRpb25MaXN0fSBlcnJvclxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRXJyb3I6IGZ1bmN0aW9uKGVycm9yKXtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgdmFsaWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0IHRoZSB2YWx1ZSByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgLy8vIG5vcm1hbGl6ZSB2YWxcbiAgICAgICAgICAgIHZhbCA9IFNhZmUudmFsdWUodmFsKTtcblxuICAgICAgICAgICAgLy8vIG5vcm1hbGl6ZSBvcHRpb25zXG4gICAgICAgICAgICBvcHRpb25zID0gU2FmZS5vYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zLmluZGV4ICAgPSBTYWZlLnZhbHVlKG9wdGlvbnMuaW5kZXgsIG51bGwpO1xuXG4gICAgICAgICAgICBpZihvcHRpb25zLmluZGV4ICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICB2YWx1ZVtvcHRpb25zLmluZGV4XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLy8gZXhwb3NlIG1vZHVsZSBhcyAnVHlwZWQnIFNjaGVtYVJlc3VsdCBpbnN0YW5jZVxuICAgIHJldHVybiBuZXcgVHlwZXMuU2NoZW1hUmVzdWx0KHNlbGYpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVJlc3VsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5cbi8qKlxuICpcbiAqIExpc3Qgb2YgaW50ZXJuYWwgU2NoZW1hIHBhY2thZ2UgVHlwZXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hpbGUgdXNpbmcgdGhlIHJldmVhbGluZyBtb2R1bGUgcGF0dGVybiBhbmQgd2FudGluZ1xuICogYXQgdGhlIHNhbWUgdGltZSB0byB1c2Ugc3Ryb25nIHR5cGUgY2hlY2tpbmcuXG4gKlxuICovXG52YXIgVHlwZXMgPSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIFNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgU2NoZW1hOiBmdW5jdGlvbiBTY2hlbWEob3B0aW9ucyl7IF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIFNjaGVtYURlZmluaXRpb246IGZ1bmN0aW9uIFNjaGVtYURlZmluaXRpb24ob3B0aW9ucyl7IF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBTY2hlbWFFdmFsdWF0b3JcbiAgICAgKlxuICAgICAqL1xuICAgIFNjaGVtYUV2YWx1YXRvcjogZnVuY3Rpb24gU2NoZW1hRXZhbHVhdG9yKG9wdGlvbnMpeyBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogU2NoZW1hUmVzdWx0XG4gICAgICpcbiAgICAgKi9cbiAgICBTY2hlbWFSZXN1bHQ6IGZ1bmN0aW9uIFNjaGVtYVJlc3VsdChvcHRpb25zKXsgXy5leHRlbmQodGhpcywgb3B0aW9ucyk7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIFNjaGVtYVJlc3VsdE5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIFNjaGVtYVJlc3VsdE5vZGU6IGZ1bmN0aW9uIFNjaGVtYVJlc3VsdE5vZGUob3B0aW9ucyl7IF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpOyB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZXM7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEludGVybmFsID0ge307XHJcblxyXG4vKipcclxuICpcclxuICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3JtYXRcclxuICpcclxuICogQHR5cGUge1JlZ0V4cH1cclxuICpcclxuICovXHJcbkludGVybmFsLlJlZ0V4cEZvcm1hdCA9IC9eXFwvLipcXC8oXFx3KikkLztcclxuXHJcblxyXG5cclxudmFyIFR5cGUgPSB7fTtcclxuXHJcbi8qXHJcbiAqIEdldCB0aGUgdHlwZSBvZiB0aGUgdmFsdWVcclxuICogUG9zc2libGUgdmFsdWVzIGFyZTogdW5kZWZpbmVkLCBvYmplY3QsIGFycmF5LCBudW1iZXIsIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW17b2JqfVxyXG4gKiBAcmV0dXJue3N0cmluZ31cclxuICpcclxuICovXHJcblR5cGUub2YgPSBmdW5jdGlvbiAob2JqKSB7XHJcblxyXG4gICAgdmFyIHQgPSB0eXBlb2Ygb2JqO1xyXG5cclxuICAgIGlmKHQgPT0gXCJvYmplY3RcIiAmJiBvYmogaW5zdGFuY2VvZiBBcnJheSl7XHJcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZihvYmopID09IFwiYm9vbGVhblwiKXtcclxuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBhcnJheVxyXG4gKlxyXG4gKiBAcGFyYW17dmFsdWV9IHZhbHVlIHRvIGNoZWNrXHJcbiAqIEByZXR1cm4gVHJ1ZXxGYWxzZVxyXG4gKlxyXG4gKi9cclxuVHlwZS5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KTtcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBhcnJheVxyXG4gKlxyXG4gKiBAcGFyYW17dmFsdWV9IHZhbHVlIHRvIGNoZWNrXHJcbiAqIEByZXR1cm4gVHJ1ZXxGYWxzZVxyXG4gKlxyXG4gKi9cclxuVHlwZS5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gXCJib29sZWFuXCI7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gYXJyYXlcclxuICpcclxuICogQHBhcmFte3ZhbHVlfSB2YWx1ZSB0byBjaGVja1xyXG4gKiBAcmV0dXJuIFRydWV8RmFsc2VcclxuICpcclxuICovXHJcblR5cGUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSBcImZ1bmN0aW9uXCI7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmdcclxuICpcclxuICogQHBhcmFte3ZhbHVlfSB2YWx1ZSB0byBjaGVja1xyXG4gKiBAcmV0dXJuIFRydWV8RmFsc2VcclxuICpcclxuICovXHJcblR5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiB8fFxyXG4gICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nOyAgICAgICAgIC8vLyBzdXBwb3J0IHRvIGN1c3RvbSBTdHJpbmcgZGVjbGFyYXRpb25zXHJcblxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXt2YWx1ZX0gdmFsdWUgdG8gY2hlY2tcclxuICogQHJldHVybiBUcnVlfEZhbHNlXHJcbiAqXHJcbiAqL1xyXG5UeXBlLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgLy8gbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzIGFyZSBvYmplY3RzLCBidXQgd2UgZG9uJ3QgY2FyZVxyXG4gICAgLyoganNoaW50IC1XMDQxICovXHJcbiAgICBpZih2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZihUeXBlLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCI7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuICpcclxuICogQHBhcmFtICB7Kn0gICAgICAgICAgdmFsdWVcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcblR5cGUuaXNSZWdFeHAgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogSXMgdmFsdWUgb24gdGhlIHJlZ2V4cCBzdHJpbmcgZm9ybWF0XHJcbiAqXHJcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgIHZhbHVlXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqXHJcbiAqL1xyXG5UeXBlLmlzUmVnRXhwU3RyID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgaWYoIVR5cGUuaXNTdHJpbmcodmFsdWUpKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEhSW50ZXJuYWwuUmVnRXhwRm9ybWF0LmV4ZWModmFsdWUpO1xyXG5cclxufTtcclxuXHJcbi8qXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXJcclxuICpcclxuICogQHBhcmFte3ZhbHVlfSB2YWx1ZSB0byBjaGVja1xyXG4gKiBAcmV0dXJuIFRydWV8RmFsc2VcclxuICpcclxuICovXHJcblR5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZih2YWx1ZSk7XHJcbiAgICBpZih0eXBlICE9IFwibnVtYmVyXCIgJiYgdHlwZSAhPSBcInN0cmluZ1wiKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIGVtcHR5IHN0cmluZ3MgYXJlIGVxdWFsIHRvIDBcclxuICAgIGlmKHR5cGUgPT0gXCJzdHJpbmdcIiAmJiAhdmFsdWUpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICByZXR1cm4gIWlzTmFOKHZhbHVlKTtcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogVGVzdCBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCBvciBub3RcclxuICpcclxuICogQHBhcmFtIHt2b2lkfSB2YWx1ZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuVHlwZS5pc0RlZmluZWQgPSBmdW5jdGlvbih2YWx1ZSl7XHJcblxyXG4gICAgLyoganNoaW50IC1XMDQxICovXHJcbiAgICBpZih2YWx1ZSAhPSBudWxsKXtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFRlc3QgaWYgdmFsdWUgaXMgaW5zdGFuY2VPZiAnZm4nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICogQHBhcmFtIHsqfSBmblxyXG4gKiBcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogXHJcbiAqL1xyXG5UeXBlLmluc3RhbmNlT2YgPSBmdW5jdGlvbih2YWx1ZSwgZm4pe1xyXG5cclxuICAgIC8vLyB0YWtlIGNhcmUgb2YgamF2YXNjcmlwdCBxdWlya3MgZmlyc3QhXHJcbiAgICBcclxuICAgIGlmKFR5cGUuaXNTdHJpbmcodmFsdWUpICYmIGZuID09IFN0cmluZyl7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKFR5cGUuaXNOdW1iZXIodmFsdWUpICYmIGZuID09IE51bWJlcil7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7ICAgXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKFR5cGUuaXNCb29sZWFuKHZhbHVlKSAmJiBmbiA9PSBCb29sZWFuKXtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgZm4pO1xyXG4gICAgXHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogVGVzdHMgaWYgdGhlIHZhbHVlIGlzIEVtcHR5XHJcbiAqXHJcbiAqIEBwYXJhbSAgeyp9ICB2YWx1ZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKlxyXG4gKi9cclxuVHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24odmFsdWUpe1xyXG5cclxuICAgIGlmKCAhVHlwZS5pc0RlZmluZWQodmFsdWUpICl7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCBUeXBlLmlzU3RyaW5nKHZhbHVlKSApe1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIFR5cGUuaXNPYmplY3QodmFsdWUpIHx8IFR5cGUuaXNBcnJheSh2YWx1ZSkgKXtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbmNlbCBpdGVyYXRpb24gYmVjYXVzZSBpdCBoYXMgc29tZSBkYXRhXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoXCIpLFxuICAgIFVybFBhcnNlciAgID0gcmVxdWlyZShcIi4vVXJsL1BhcnNlclwiKTtcblxuXG4vKipcbiAqXG4gKiBAY2xhc3NcbiAqIFRoZSBVcmwgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtbdHlwZV19IHVybCBUaGUgVXJsXG4gKlxuICovXG52YXIgVXJsID0gZnVuY3Rpb24odXJsKXtcblxuICAgIHVybCA9IFVybFBhcnNlci5ub3JtYWxpemUodXJsKTtcblxuICAgIHZhciBfdGhpcyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgaWYgdGhlIHVybCBpcyBhYnNvbHV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaXNBYnNvbHV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBVcmxQYXJzZXIuaXNBYnNvbHV0ZSh1cmwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBiYXNlVXJsXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VVcmw6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gVXJsUGFyc2VyLmJhc2VVcmwodXJsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcHJvdG9jb2xcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvdG9jb2w6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gVXJsUGFyc2VyLnByb3RvY29sKHVybCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHBhdGggb2YgdGhlIHVybFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIFVybFBhcnNlci5wYXRoKHVybCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZpbGUgbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxlbmFtZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBVcmxQYXJzZXIuZmlsZW5hbWUodXJsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZmlsZSBwYXRoXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVwYXRoOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIFVybFBhcnNlci5maWxlcGF0aCh1cmwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBwYXRoIG9mIHRoZSB1cmxcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGF0aDogZnVuY3Rpb24ocGF0aCl7XG5cbiAgICAgICAgICAgIHBhdGggPSBVcmxQYXJzZXIubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IFVybFBhcnNlci5pc0Fic29sdXRlKHBhdGgpO1xuICAgICAgICAgICAgaWYoaXNBYnNvbHV0ZSl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICBpZihwYXRoLmluZGV4T2YoXCIvXCIpID09PSAwKXtcbiAgICAgICAgICAgICAgICB1cmwgPSBVcmxQYXJzZXIubm9ybWFsaXplKCBfdGhpcy5iYXNlVXJsKCkgKyBwYXRoICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHVybCA9IFVybFBhcnNlci5ub3JtYWxpemUoIF90aGlzLmJhc2VVcmwoKSArIF90aGlzLnBhdGgoKSArIHBhdGggKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBVcmxQYXJzZXIubm9ybWFsaXplKHVybCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIHJldHVybiBfdGhpcztcblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgXyAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXHJcbiAgICBUeXBlICAgID0gcmVxdWlyZShcIi4uL1R5cGVcIik7XHJcblxyXG5cclxuLy8vIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBnZXQgdGhlIGJhc2VVcmxcclxudmFyIEJhc2VVcmxSZWdFeFN0ciA9ICdeW2Etel0rOi8vW2Etei4tXSsoPzo6WzAtOV0rKT8nO1xyXG4vLy8gcmVndWxhciBleHByZXNzaW9uIHRvIGdldCB0aGUgcHJvdG9jb2xcclxudmFyIFByb3RvY29sUmVnRXhTdHIgPSAnXihbYS16XSspOi8vJztcclxuXHJcblxyXG5cclxudmFyIFVybFBhcnNlciA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZSB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJue1N0cmluZ30gdGhlIGN1cnJlbnQgdXJsXHJcbiAgICAgKi9cclxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24odXJsKSB7XHJcbiAgICBcclxuICAgICAgICBpZighdXJsKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgLy8vIHJlcGxhY2UgYWxsIC8vLy8gdG8gYSBzaW5nbGUgc2xhc2hcclxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XHJcbiAgICAgICAgLy8vIGJlY2F1c2UgcHJldmlvdWx5IGFsbCAvLyB3ZXJlIHJlcGxhY2VkIGxldHMgZml4IHRoZSBwcm90b2NvbCBzeW50YXggKGh0dHA6Ly8pXHJcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoLzpcXC8vZywgXCI6Ly9cIik7XHJcblxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhlIHVybCBpcyBhYnNvbHV0ZVxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKHVybCl7XHJcblxyXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoQmFzZVVybFJlZ0V4U3RyLCBcImlcIik7XHJcbiAgICAgICAgcmV0dXJuICEhIHJlZ2V4LmV4ZWModXJsKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcHJvdG9jb2wgb2YgdGhlIHVybCBcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmxcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgcHJvdG9jb2w6IGZ1bmN0aW9uKHVybCl7XHJcblxyXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoUHJvdG9jb2xSZWdFeFN0ciwgXCJnaVwiKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnZXguZXhlYyh1cmwpO1xyXG4gICAgICAgIGlmKHJlc3VsdCkgcmV0dXJuIHJlc3VsdFsxXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmFzZVVybCBmb3IgdGhlIGdpdmVuIHVybFxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBiYXNlVXJsOiBmdW5jdGlvbih1cmwpe1xyXG5cclxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKEJhc2VVcmxSZWdFeFN0ciwgXCJpXCIpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIixcclxuICAgICAgICAgICAgcmVnZXhSZXN1bHQgPSByZWdleC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgIGlmKHJlZ2V4UmVzdWx0KXtcclxuICAgICAgICAgICAgLy8vIGFsd2F5cyBhZGQgLyBhdCB0aGUgZW5kIG9mIGJhc2VVcmxcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVnZXhSZXN1bHQuc2hpZnQoKSArIFwiL1wiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFVybFBhcnNlci5ub3JtYWxpemUocmVzdWx0KTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBwYXRoIG9mIHRoZSB1cmxcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmxcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgcGF0aDogZnVuY3Rpb24odXJsKXtcclxuXHJcbiAgICAgICAgLy8gc2FuaXRpemUgaW5wdXRcclxuICAgICAgICB1cmwgPSB1cmwgfHwgXCJcIjtcclxuXHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBVcmxQYXJzZXIuYmFzZVVybCh1cmwpIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgYmFzZSB1cmxcclxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShiYXNlVXJsLCBcIlwiKTtcclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHVybC4gdGhpcyBtYXkgYmUgYSBcIi9cIlwiIG9yIFwiZmlsZWhhbmRsZXJcIlxyXG4gICAgICAgIHZhciB1cmxQYXJ0cyA9IHVybC5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgdXJsUGFydHMucG9wKCk7XHJcbiAgICAgICAgdXJsUGFydHMucHVzaChcIlwiKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBqb2luIGFsbFxyXG4gICAgICAgIHVybCA9IHVybFBhcnRzLmpvaW4oXCIvXCIpO1xyXG5cclxuICAgICAgICByZXR1cm4gVXJsUGFyc2VyLm5vcm1hbGl6ZSh1cmwpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZmlsZSBuYW1lXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIGZpbGVuYW1lOiBmdW5jdGlvbih1cmwpe1xyXG5cclxuICAgICAgICAvLyBzYW5pdGl6ZSBpbnB1dFxyXG4gICAgICAgIHVybCA9IHVybCB8fCBcIlwiO1xyXG5cclxuICAgICAgICB2YXIgdXJsUGFydHMgPSB1cmwuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHVybFBhcnRzLnBvcCgpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcclxuXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGVudGlyZSBGaWxlIFBhdGhcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB1cmxcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZmlsZXBhdGg6IGZ1bmN0aW9uKHVybCl7IFxyXG5cclxuICAgICAgICByZXR1cm4gVXJsUGFyc2VyLm5vcm1hbGl6ZShcclxuICAgICAgICAgICAgVXJsUGFyc2VyLmJhc2VVcmwodXJsKSArIFxyXG4gICAgICAgICAgICBVcmxQYXJzZXIucGF0aCh1cmwpICsgXHJcbiAgICAgICAgICAgIFVybFBhcnNlci5maWxlbmFtZSh1cmwpKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0J3MgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIHRoZSB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW17aHJlZn0gVGhlIGZ1bGwgdXJsIG9yIG51bGwgdG8gZ2V0IHRoZSBjdXJyZW50XHJcbiAgICAgKiBAcGFyYW17c2VwYXJhdG9yfSBUaGUgdXJsIHFzIHNlcGFyYXRvci4gTm9ybWFsbHkgaXMgP1xyXG4gICAgICogQHJldHVybntTdHJpbmd9IFRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiB0aGUgdXJsXHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5U3RyaW5nOiBmdW5jdGlvbihocmVmLCBzZXBhcmF0b3IpIHtcclxuXHJcbiAgICAgICAgaHJlZiA9IGhyZWYgfHwgXCJcIjtcclxuICAgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJz8nO1xyXG5cclxuICAgICAgICB2YXIgaHJlZlNwbGl0ID0gaHJlZi5zcGxpdChzZXBhcmF0b3IpIHx8IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGhyZWZTcGxpdC5sZW5ndGggPiAxKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHN0cmluIGNhbiBiZSBtYWxmb3JtZWQgbGlrZSA/YT0xJj9iPTJcclxuICAgICAgICAgICAgLy8gd2UgY2FuIGZpeCB0aGlzXHJcbiAgICAgICAgICAgIHZhciBxU3RyaW5nUGFydCA9IGhyZWZTcGxpdC5zcGxpY2UoMSwgaHJlZlNwbGl0Lmxlbmd0aC0xKTtcclxuICAgICAgICAgICAgdmFyIHFTdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICBfLmZvckVhY2gocVN0cmluZ1BhcnQsIGZ1bmN0aW9uKHFzKXtcclxuICAgICAgICAgICAgICAgIHFTdHJpbmcgKz0gcXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHFTdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgICAqIFBhcnNlIHF1ZXJ5IHN0cmluZyBmcm9tIHVybFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXtzZXBhcmF0b3J9IFRoZSB1cmwgcXMgc2VwYXJhdG9yLiBOb3JtYWxseSBpcyA/XHJcbiAgICAgKiBAcmV0dXJuIEFuIGhhc2ggd2l0aCBhbGwgdGhlIHF1ZXJ5IHN0cmluZyBrZXkvdmFsdWUnc1xyXG4gICAgICovXHJcbiAgICBxdWVyeVN0cmluZ09iajogZnVuY3Rpb24oaHJlZiwgc2VwYXJhdG9yKSB7XHJcbiAgICBcclxuICAgICAgICBocmVmID0gaHJlZiB8fCBcIlwiO1xyXG5cclxuICAgICAgICB2YXIgcVN0cmluZyA9IFVybFBhcnNlci5xdWVyeVN0cmluZyhocmVmLCBzZXBhcmF0b3IpLFxyXG4gICAgICAgICAgICB2YWx1ZXMgPSB7fTtcclxuXHJcbiAgICAgICAgcVN0cmluZyA9IGRlY29kZVVSSShxU3RyaW5nIHx8IFwiXCIpO1xyXG4gICAgICAgIF8uZWFjaChcclxuICAgICAgICAgICAgcVN0cmluZy5zcGxpdChcIiZcIiksXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGtleVZhbHVlKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaWYgXHJcbiAgICAgICAgICAgICAgICBpZigha2V5VmFsdWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGtleVZhbHVlLnNwbGl0KFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYocGFpci5sZW5ndGg+MSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbcGFpclswXV0gPSBwYWlyWzFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1twYWlyWzBdXSA9IHRydWU7IC8vIGl0J3MgbW9yZSBlYXN5IHRvIHVzZSBvbiBjb25kaXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuXHJcblxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXJsUGFyc2VyO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb21tb24gPSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR5cGUgdXRpbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIFR5cGU6IHJlcXVpcmUoXCIuL0NvbW1vbi9UeXBlXCIpLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTYWZlIHV0aWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICBTYWZlOiByZXF1aXJlKFwiLi9Db21tb24vU2FmZVwiKSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQXJyYXkgdXRpbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIEFycjogcmVxdWlyZShcIi4vQ29tbW9uL0FyclwiKSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT2JqZWN0IHV0aWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICBPYmo6IHJlcXVpcmUoXCIuL0NvbW1vbi9PYmpcIiksXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEkxOE4gdXRpbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIEkxOE46IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogSTE4TlN0cmluZyB1dGlsaXR5XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtJMThOU3RyaW5nfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nOiByZXF1aXJlKFwiLi9Db21tb24vSTE4Ti9TdHJpbmdcIiksXG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeGNlcHRpb25zIHBhY2thZ2VcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICBFeGNlcHRpb246IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogRXhjZXB0aW9uIENsYXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFeGNlcHRpb259XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBFeGNlcHRpb246IHJlcXVpcmUoXCIuL0NvbW1vbi9FeGNlcHRpb24vRXhjZXB0aW9uXCIpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGNlcHRpb25MaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFeGNlcHRpb25MaXN0fVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgRXhjZXB0aW9uTGlzdDogcmVxdWlyZShcIi4vQ29tbW9uL0V4Y2VwdGlvbi9FeGNlcHRpb25MaXN0XCIpLFxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXJsIHV0aWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKlxuICAgICAqL1xuICAgIFVybDogcmVxdWlyZShcIi4vQ29tbW9uL1VybFwiKSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hhaW4gZmFjaWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICBDaGFpbjogcmVxdWlyZShcIi4vQ29tbW9uL0NoYWluXCIpLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IEFzc2VydGlvbiBpbnN0YW5jZSB1dGlsaXR5LiBUaGlzIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZGVmYXVsdFxuICAgICAqIEFzc2VydCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqXG4gICAgICovXG4gICAgQXNzZXJ0OiByZXF1aXJlKFwiLi9Db21tb24vQXNzZXJ0XCIpLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBc3NlcnRpb24gdXRpbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqXG4gICAgICovXG4gICAgQXNzZXJ0aW9uOiByZXF1aXJlKFwiLi9Db21tb24vQXNzZXJ0aW9uXCIpLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTY2hlbWEgdXRpbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIFNjaGVtYTogcmVxdWlyZShcIi4vQ29tbW9uL1NjaGVtYVwiKSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3VzdG9tIFNjaGVtYVxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIEN1c3RvbVNjaGVtYTogcmVxdWlyZShcIi4vQ29tbW9uL0N1c3RvbVNjaGVtYVwiKSxcblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1vbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2hcIiksXG4gICAgRGl2aGlkZSA9IHJlcXVpcmUoXCIuL0luZGV4LmpzXCIpO1xuXG4vKipcbiAqXG4gKiBTcGVjcyBtYWluIG1vZHVsZS5cbiAqXG4gKiBUaGlzIGV4cG9zZXMgdGhlIHNwZWNzIHRoYXQgYXJlIG9uIC5yZWFkbWUgZm9sZGVyLiBOb3RlIHRoYXQgdGhlXG4gKiBzcGVjIGZpbGVzIGFyZSBpbmNsdWRlZCBvbiB0aGUgZ2VuZXJhdGVkIGRvY3VtZW50YXRpb25cbiAqXG4gKi9cbnZhciBTcGVjSW5kZXggPSBfLmV4dGVuZCh7fSwgRGl2aGlkZSwge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeHBvc2Ugc3ViLW1vZHVsZXMuIFRoZXNlIHdpbGwgYmUgdXNlZCBmb3IgdW5pdC10ZXN0c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKlxuICAgICAqL1xuICAgIFN1Yk1vZHVsZXM6IHtcblxuICAgICAgICBVcmw6IHtcbiAgICAgICAgICAgIFBhcnNlcjogcmVxdWlyZShcIi4vQ29tbW9uL1VybC9QYXJzZXJcIilcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NlcnQ6IHtcbiAgICAgICAgICAgIEFycmF5OiByZXF1aXJlKFwiLi9Db21tb24vQXNzZXJ0L0FycmF5XCIpLFxuICAgICAgICAgICAgTWF4OiByZXF1aXJlKFwiLi9Db21tb24vQXNzZXJ0L01heFwiKSxcbiAgICAgICAgICAgIE1pbjogcmVxdWlyZShcIi4vQ29tbW9uL0Fzc2VydC9NaW5cIiksXG4gICAgICAgICAgICBOdW1iZXI6IHJlcXVpcmUoXCIuL0NvbW1vbi9Bc3NlcnQvTnVtYmVyXCIpLFxuICAgICAgICAgICAgUmVnZXg6IHJlcXVpcmUoXCIuL0NvbW1vbi9Bc3NlcnQvUmVnZXhcIiksXG4gICAgICAgICAgICBSZXF1aXJlZDogcmVxdWlyZShcIi4vQ29tbW9uL0Fzc2VydC9SZXF1aXJlZFwiKSxcbiAgICAgICAgICAgIFN0cmluZzogcmVxdWlyZShcIi4vQ29tbW9uL0Fzc2VydC9TdHJpbmdcIiksXG4gICAgICAgICAgICBPYmplY3Q6IHJlcXVpcmUoXCIuL0NvbW1vbi9Bc3NlcnQvT2JqZWN0XCIpLFxuICAgICAgICAgICAgSW5zdGFuY2VPZjogcmVxdWlyZShcIi4vQ29tbW9uL0Fzc2VydC9JbnN0YW5jZU9mXCIpLFxuICAgICAgICB9LFxuXG4gICAgICAgIENoYWluOiB7XG4gICAgICAgICAgICBDaGFpbkNvbnRleHQ6IHJlcXVpcmUoXCIuL0NvbW1vbi9DaGFpbi9DaGFpbkNvbnRleHRcIiksXG4gICAgICAgICAgICBDaGFpbkZ1bmN0aW9uOiByZXF1aXJlKFwiLi9Db21tb24vQ2hhaW4vQ2hhaW5GdW5jdGlvblwiKSxcbiAgICAgICAgfSxcblxuICAgICAgICBTY2hlbWE6IHtcblxuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbjogcmVxdWlyZShcIi4vQ29tbW9uL1NjaGVtYS9TY2hlbWFEZWZpbml0aW9uXCIpLFxuXG4gICAgICAgICAgICBNaXhpbnM6IHtcbiAgICAgICAgICAgICAgICBTY2hlbWFFeGVjdXRpb246IHJlcXVpcmUoXCIuL0NvbW1vbi9TY2hlbWEvTWl4aW5zL1NjaGVtYUV4ZWN1dGlvblwiKSxcbiAgICAgICAgICAgICAgICBTY2hlbWFFeGVjdXRpb25IZWxwZXI6IHJlcXVpcmUoXCIuL0NvbW1vbi9TY2hlbWEvTWl4aW5zL1NjaGVtYUV4ZWN1dGlvbkhlbHBlclwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBTcGVjczoge1xuXG4gICAgICAgIEFyckV4YW1wbGUgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9BcnIvQXJyRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgQXNzZXJ0aW9uRXhhbXBsZSAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL0Fzc2VydGlvbi9Bc3NlcnRpb25FeGFtcGxlXCIpOyB9LFxuICAgICAgICBBc3NlcnRFeGFtcGxlICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvQXNzZXJ0L0Fzc2VydEV4YW1wbGVcIik7IH0sXG4gICAgICAgIENoYWluRXhhbXBsZSAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9DaGFpbi9DaGFpbkV4YW1wbGVcIik7IH0sXG4gICAgICAgIEV4Y2VwdGlvbkRvY0V4YW1wbGUgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9FeGNlcHRpb24vRXhjZXB0aW9uRG9jRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgRXhjZXB0aW9uTGlzdERvY0V4YW1wbGUgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL0V4Y2VwdGlvbi9FeGNlcHRpb25MaXN0RG9jRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgSTE4TlN0cmluZ0RvY0V4YW1wbGUgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL0kxOE4vSTE4TlN0cmluZ0RvY0V4YW1wbGVcIik7IH0sXG4gICAgICAgIE9iakV4YW1wbGUgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9PYmovT2JqRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2FmZUFycmF5RXhhbXBsZSAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZUFycmF5RXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2FmZUJvb2xlYW5FeGFtcGxlICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZUJvb2xlYW5FeGFtcGxlXCIpOyB9LFxuICAgICAgICBTYWZlRnVuY3Rpb25FeGFtcGxlICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlRnVuY3Rpb25FeGFtcGxlXCIpOyB9LFxuICAgICAgICBTYWZlTGVuZ3RoRXhhbXBsZSAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlTGVuZ3RoRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2FmZU51bWJlckV4YW1wbGUgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZU51bWJlckV4YW1wbGVcIik7IH0sXG4gICAgICAgIFNhZmVPYmplY3RFeGFtcGxlICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9TYWZlL1NhZmVPYmplY3RFeGFtcGxlXCIpOyB9LFxuICAgICAgICBTYWZlUmVnZXhFeGFtcGxlICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlUmVnZXhFeGFtcGxlXCIpOyB9LFxuICAgICAgICBTYWZlU3RyaW5nRXhhbXBsZSAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2FmZS9TYWZlU3RyaW5nRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2FmZVZhbHVlRXhhbXBsZSAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NhZmUvU2FmZVZhbHVlRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2NoZW1hQW55RXhhbXBsZSAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NjaGVtYS9TY2hlbWFBbnlFeGFtcGxlXCIpOyB9LFxuICAgICAgICBTY2hlbWFBcnJheUV4YW1wbGUgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2NoZW1hL1NjaGVtYUFycmF5RXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2NoZW1hTnVtYmVyRXhhbXBsZSAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NjaGVtYS9TY2hlbWFOdW1iZXJFeGFtcGxlXCIpOyB9LFxuICAgICAgICBTY2hlbWFPYmplY3RFeGFtcGxlICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmVxdWlyZShcIi4uLy5yZWFkbWUvaW5jbHVkZXMvU2NoZW1hL1NjaGVtYU9iamVjdEV4YW1wbGVcIik7IH0sXG4gICAgICAgIFNjaGVtYU92ZXJ2aWV3ICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9TY2hlbWEvU2NoZW1hT3ZlcnZpZXdcIik7IH0sXG4gICAgICAgIFNjaGVtYVN0cmluZ0V4YW1wbGUgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXF1aXJlKFwiLi4vLnJlYWRtZS9pbmNsdWRlcy9TY2hlbWEvU2NoZW1hU3RyaW5nRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgU2NoZW1hU2VyaWFsaXphdGlvbkV4YW1wbGUgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1NjaGVtYS9TY2hlbWFTZXJpYWxpemF0aW9uRXhhbXBsZVwiKTsgfSxcbiAgICAgICAgVHlwZUV4YW1wbGUgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJlcXVpcmUoXCIuLi8ucmVhZG1lL2luY2x1ZGVzL1R5cGUvVHlwZUV4YW1wbGVcIik7IH0sXG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwZWNJbmRleDtcbiJdfQ==
